<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Binary Search | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Binary Search" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Binary Search is a searching algorithm that is used to search an element in a sorted list or array. It works by repeatedly dividing the search interval in half. The idea is to begin by comparing the middle element of the array with the target value. If the target value matches the middle element, the search ends successfully. Otherwise, depending on whether the target value is greater or less than the middle element, the search continues either in the left or the right half of the array respectively. It is a widely-used algorithm in computer science due to its efficiency in searching." />
<meta property="og:description" content="Introduction Binary Search is a searching algorithm that is used to search an element in a sorted list or array. It works by repeatedly dividing the search interval in half. The idea is to begin by comparing the middle element of the array with the target value. If the target value matches the middle element, the search ends successfully. Otherwise, depending on whether the target value is greater or less than the middle element, the search continues either in the left or the right half of the array respectively. It is a widely-used algorithm in computer science due to its efficiency in searching." />
<link rel="canonical" href="/algorithm/2022/01/10/binary-search.html" />
<meta property="og:url" content="/algorithm/2022/01/10/binary-search.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-10T07:03:06+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Binary Search" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2022-01-10T07:03:06+02:00","datePublished":"2022-01-10T07:03:06+02:00","description":"Introduction Binary Search is a searching algorithm that is used to search an element in a sorted list or array. It works by repeatedly dividing the search interval in half. The idea is to begin by comparing the middle element of the array with the target value. If the target value matches the middle element, the search ends successfully. Otherwise, depending on whether the target value is greater or less than the middle element, the search continues either in the left or the right half of the array respectively. It is a widely-used algorithm in computer science due to its efficiency in searching.","headline":"Binary Search","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2022/01/10/binary-search.html"},"url":"/algorithm/2022/01/10/binary-search.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Binary Search</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-01-10T07:03:06+02:00" itemprop="datePublished">
        Jan 10, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Binary Search is a searching algorithm that is used to search an element in a sorted list or array. It works by repeatedly dividing the search interval in half. The idea is to begin by comparing the middle element of the array with the target value. If the target value matches the middle element, the search ends successfully. Otherwise, depending on whether the target value is greater or less than the middle element, the search continues either in the left or the right half of the array respectively. It is a widely-used algorithm in computer science due to its efficiency in searching.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">(* Binary Search *)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">binary_search</span> <span class="n">a</span> <span class="n">value</span> <span class="n">low</span> <span class="n">high</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">high</span> <span class="o">=</span> <span class="n">low</span> <span class="k">then</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span> <span class="k">then</span>
      <span class="n">low</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="nc">Not_found</span>
  <span class="k">else</span> <span class="k">let</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">value</span> <span class="k">then</span>
      <span class="n">binary_search</span> <span class="n">a</span> <span class="n">value</span> <span class="n">low</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">value</span> <span class="k">then</span>
      <span class="n">binary_search</span> <span class="n">a</span> <span class="n">value</span> <span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">high</span>
    <span class="k">else</span>
      <span class="n">mid</span>

</code></pre></div></div>

<p>The binary_search algorithm takes in four parameters: an array <code class="language-plaintext highlighter-rouge">a</code>, the <code class="language-plaintext highlighter-rouge">value</code> to be searched for in the array, the <code class="language-plaintext highlighter-rouge">low</code> index and the <code class="language-plaintext highlighter-rouge">high</code> index of the search interval. It then proceeds based on the value comparison between the middle element and the search value.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The algorithm begins with the search interval defined by the <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> indices.</li>
  <li>If the <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> indices are the same, the algorithm checks if the element at the <code class="language-plaintext highlighter-rouge">low</code> index is equal to the search <code class="language-plaintext highlighter-rouge">value</code>. If it is, the algorithm returns the index <code class="language-plaintext highlighter-rouge">low</code>, otherwise, it raises a <code class="language-plaintext highlighter-rouge">Not_found</code> exception indicating that the element is not in the array.</li>
  <li>If the search interval has a length greater than 1 (<code class="language-plaintext highlighter-rouge">high</code> &gt; <code class="language-plaintext highlighter-rouge">low</code>), the algorithm proceeds to calculate the <code class="language-plaintext highlighter-rouge">mid</code> index by taking the average value of the <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> indices: <code class="language-plaintext highlighter-rouge">mid = (low + high) / 2</code>.</li>
  <li>The algorithm then checks if the <code class="language-plaintext highlighter-rouge">value</code> to be searched for is greater than or less than the element at the <code class="language-plaintext highlighter-rouge">mid</code> index:
    <ol>
      <li>If the <code class="language-plaintext highlighter-rouge">mid</code> element is greater than the <code class="language-plaintext highlighter-rouge">value</code>, the search interval is partitioned into the left half, and the algorithm is called recursively with the search interval now defined by the <code class="language-plaintext highlighter-rouge">low</code> index and (<code class="language-plaintext highlighter-rouge">mid</code> - 1) index.</li>
      <li>If the <code class="language-plaintext highlighter-rouge">mid</code> element is less than the <code class="language-plaintext highlighter-rouge">value</code>, the search interval is partitioned into the right half, and the algorithm is called recursively with the search interval now defined by the (<code class="language-plaintext highlighter-rouge">mid</code> + 1) index and <code class="language-plaintext highlighter-rouge">high</code> index.</li>
      <li>If the <code class="language-plaintext highlighter-rouge">mid</code> element is equal to the <code class="language-plaintext highlighter-rouge">value</code>, then the algorithm returns the index of the <code class="language-plaintext highlighter-rouge">mid</code> element.</li>
    </ol>
  </li>
  <li>The algorithm repeats steps 2–4 until the search value is found, or the entire array has been traversed unsuccessfully.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The best-case time complexity for binary search is O(1), which occurs when the target element being searched for is the middle element of the sorted array. The worst-case time complexity is O(log n), whereby the search interval is partitioned into halves at each step of the recursive call until the target element is found or the search space is exhausted. The space complexity for binary search is O(1) as it does not require additional space other than what is used to store the sorted array.</p>

  </div><a class="u-url" href="/algorithm/2022/01/10/binary-search.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
