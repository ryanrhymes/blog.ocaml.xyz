<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Bisection Algorithm | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Bisection Algorithm" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval. Implementation The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root. let bisec ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let x, d = match fa &lt; 0. with | true -&gt; ref a, ref (b -. a) | false -&gt; ref b, ref (a -. b) in try for _i = 1 to max_iter do d := !d *. 0.5; let c = !x +. !d in let fc = f c in if fc &lt;= 0. then x := c; assert (abs_float !d &gt;= xtol &amp;&amp; fc != 0.) done; !x with | _ -&gt; !x) Step-by-step Explanation The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error. If f(a) is 0, the function returns a, since a is already a root. If f(b) is 0, the function returns b, since b is already a root. The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b. The function enters a loop that runs for a maximum of max_iter iterations. In each iteration, the function bisects the interval by setting d to d/2. The function computes the midpoint c of the interval by adding d to x. The function evaluates the function at c. If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval. The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop. If the loop completes without finding a root, the function returns the last value of x. Complexity Analysis The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits. The algorithm’s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy. The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm. Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant." />
<meta property="og:description" content="Introduction The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval. Implementation The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root. let bisec ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let x, d = match fa &lt; 0. with | true -&gt; ref a, ref (b -. a) | false -&gt; ref b, ref (a -. b) in try for _i = 1 to max_iter do d := !d *. 0.5; let c = !x +. !d in let fc = f c in if fc &lt;= 0. then x := c; assert (abs_float !d &gt;= xtol &amp;&amp; fc != 0.) done; !x with | _ -&gt; !x) Step-by-step Explanation The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error. If f(a) is 0, the function returns a, since a is already a root. If f(b) is 0, the function returns b, since b is already a root. The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b. The function enters a loop that runs for a maximum of max_iter iterations. In each iteration, the function bisects the interval by setting d to d/2. The function computes the midpoint c of the interval by adding d to x. The function evaluates the function at c. If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval. The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop. If the loop completes without finding a root, the function returns the last value of x. Complexity Analysis The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits. The algorithm’s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy. The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm. Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant." />
<link rel="canonical" href="https://blog.ocaml.xyz/algorithm/2023/11/21/bisec-algorithm.html" />
<meta property="og:url" content="https://blog.ocaml.xyz/algorithm/2023/11/21/bisec-algorithm.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-21T04:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Bisection Algorithm" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-21T04:00:00+02:00","datePublished":"2023-11-21T04:00:00+02:00","description":"Introduction The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval. Implementation The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root. let bisec ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let x, d = match fa &lt; 0. with | true -&gt; ref a, ref (b -. a) | false -&gt; ref b, ref (a -. b) in try for _i = 1 to max_iter do d := !d *. 0.5; let c = !x +. !d in let fc = f c in if fc &lt;= 0. then x := c; assert (abs_float !d &gt;= xtol &amp;&amp; fc != 0.) done; !x with | _ -&gt; !x) Step-by-step Explanation The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error. If f(a) is 0, the function returns a, since a is already a root. If f(b) is 0, the function returns b, since b is already a root. The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b. The function enters a loop that runs for a maximum of max_iter iterations. In each iteration, the function bisects the interval by setting d to d/2. The function computes the midpoint c of the interval by adding d to x. The function evaluates the function at c. If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval. The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop. If the loop completes without finding a root, the function returns the last value of x. Complexity Analysis The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits. The algorithm’s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy. The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm. Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant.","headline":"Bisection Algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.ocaml.xyz/algorithm/2023/11/21/bisec-algorithm.html"},"url":"https://blog.ocaml.xyz/algorithm/2023/11/21/bisec-algorithm.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.ocaml.xyz/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bisection Algorithm</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-21T04:00:00+02:00" itemprop="datePublished">
        Nov 21, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval.</p>

<h2 id="implementation">Implementation</h2>

<p>The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bisec</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">d</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">true</span>  <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">a</span><span class="o">,</span> <span class="n">ref</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span>
      <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="p">(</span><span class="n">a</span> <span class="o">-.</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span> <span class="o">*.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+.</span> <span class="o">!</span><span class="n">d</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">f</span> <span class="n">c</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="o">!</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">xtol</span> <span class="o">&amp;&amp;</span> <span class="n">fc</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">x</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>
    <p>The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points.</p>
  </li>
  <li>
    <p>The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error.</p>
  </li>
  <li>
    <p>If f(a) is 0, the function returns a, since a is already a root.</p>
  </li>
  <li>
    <p>If f(b) is 0, the function returns b, since b is already a root.</p>
  </li>
  <li>
    <p>The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b.</p>
  </li>
  <li>
    <p>The function enters a loop that runs for a maximum of max_iter iterations.</p>
  </li>
  <li>
    <p>In each iteration, the function bisects the interval by setting d to d/2.</p>
  </li>
  <li>
    <p>The function computes the midpoint c of the interval by adding d to x.</p>
  </li>
  <li>
    <p>The function evaluates the function at c.</p>
  </li>
  <li>
    <p>If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval.</p>
  </li>
  <li>
    <p>The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop.</p>
  </li>
  <li>
    <p>If the loop completes without finding a root, the function returns the last value of x.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits.</p>

<p>The algorithm’s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy.</p>

<p>The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm.</p>

<p>Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant.</p>

  </div><a class="u-url" href="/algorithm/2023/11/21/bisec-algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="https://blog.ocaml.xyz/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
