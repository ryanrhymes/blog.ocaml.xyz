<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Simpson’s Rule | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Simpson’s Rule" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration. Implementation The following implementation is in OCaml: let simpson ?(n = 20) ?(eps = 1e-6) f a b = let s_new = ref 0. in let s_old = ref 0. in let o_new = ref 0. in let o_old = ref 0. in (try for i = 1 to n do s_new := trapzd f a b i; s_old := ((4. *. !s_new) -. !o_new) /. 3.; if i &gt; 5 then ( let d = abs_float (!s_old -. !o_old) in let e = eps *. abs_float !o_old in assert (not (d &lt; e || (!s_old = 0. &amp;&amp; !o_old = 0.))); o_old := !s_old; o_new := !s_new) done with | _ -&gt; ()); !s_new The function simpson takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. Step-by-step Explanation The simpson function takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. The function initializes four variables: s_new, s_old, o_new, and o_old, all of which are set to 0. s_new and s_old will be used to store the current and previous approximations of the integral, respectively, while o_new and o_old will be used to store the current and previous approximations of the error, respectively. The function uses a try-with block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs. The function then enters a for loop that iterates from 1 to n. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the trapzd function, and stores it in the s_new variable. The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula: s_old = (4 * s_new - o_new) / 3 where s_old is the new approximation, s_new is the current approximation, and o_new is the previous approximation. The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (eps). If it is, the function returns the current approximation of the integral (s_new). If it is not, the function updates the o_old and o_new variables to store the current and previous approximations of the error, respectively. The function exits the loop and returns the current approximation of the integral (s_new). If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (s_new). Overall, the simpson function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into n subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the trapzd function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. Complexity Analysis The time complexity of the simpson function depends on the number of intervals used in the approximation (n) and the maximum relative error allowed (eps). The trapzd function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a for loop that iterates n times to compute the sum of the areas of the trapezoids. The simpson function uses the trapzd function n times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. The time complexity of the simpson function can be approximated as follows: The for loop that iterates from 1 to n has a time complexity of O(n). The trapzd function is called n times, so its time complexity is O(n^2). The time complexity of the computations inside the loop is O(1). The if statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1). The try-with block has a time complexity of O(1). The function returns the current approximation of the integral, which has a time complexity of O(1). Therefore, the overall time complexity of the simpson function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (n) increases. The maximum relative error allowed (eps) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of eps will result in a more accurate approximation, but will also require more iterations of the for loop and hence increase the running time of the function." />
<meta property="og:description" content="Introduction The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration. Implementation The following implementation is in OCaml: let simpson ?(n = 20) ?(eps = 1e-6) f a b = let s_new = ref 0. in let s_old = ref 0. in let o_new = ref 0. in let o_old = ref 0. in (try for i = 1 to n do s_new := trapzd f a b i; s_old := ((4. *. !s_new) -. !o_new) /. 3.; if i &gt; 5 then ( let d = abs_float (!s_old -. !o_old) in let e = eps *. abs_float !o_old in assert (not (d &lt; e || (!s_old = 0. &amp;&amp; !o_old = 0.))); o_old := !s_old; o_new := !s_new) done with | _ -&gt; ()); !s_new The function simpson takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. Step-by-step Explanation The simpson function takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. The function initializes four variables: s_new, s_old, o_new, and o_old, all of which are set to 0. s_new and s_old will be used to store the current and previous approximations of the integral, respectively, while o_new and o_old will be used to store the current and previous approximations of the error, respectively. The function uses a try-with block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs. The function then enters a for loop that iterates from 1 to n. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the trapzd function, and stores it in the s_new variable. The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula: s_old = (4 * s_new - o_new) / 3 where s_old is the new approximation, s_new is the current approximation, and o_new is the previous approximation. The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (eps). If it is, the function returns the current approximation of the integral (s_new). If it is not, the function updates the o_old and o_new variables to store the current and previous approximations of the error, respectively. The function exits the loop and returns the current approximation of the integral (s_new). If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (s_new). Overall, the simpson function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into n subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the trapzd function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. Complexity Analysis The time complexity of the simpson function depends on the number of intervals used in the approximation (n) and the maximum relative error allowed (eps). The trapzd function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a for loop that iterates n times to compute the sum of the areas of the trapezoids. The simpson function uses the trapzd function n times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. The time complexity of the simpson function can be approximated as follows: The for loop that iterates from 1 to n has a time complexity of O(n). The trapzd function is called n times, so its time complexity is O(n^2). The time complexity of the computations inside the loop is O(1). The if statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1). The try-with block has a time complexity of O(1). The function returns the current approximation of the integral, which has a time complexity of O(1). Therefore, the overall time complexity of the simpson function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (n) increases. The maximum relative error allowed (eps) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of eps will result in a more accurate approximation, but will also require more iterations of the for loop and hence increase the running time of the function." />
<link rel="canonical" href="/algorithm/2023/11/21/simpson-rule.html" />
<meta property="og:url" content="/algorithm/2023/11/21/simpson-rule.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-21T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simpson’s Rule" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-21T02:00:00+02:00","datePublished":"2023-11-21T02:00:00+02:00","description":"Introduction The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration. Implementation The following implementation is in OCaml: let simpson ?(n = 20) ?(eps = 1e-6) f a b = let s_new = ref 0. in let s_old = ref 0. in let o_new = ref 0. in let o_old = ref 0. in (try for i = 1 to n do s_new := trapzd f a b i; s_old := ((4. *. !s_new) -. !o_new) /. 3.; if i &gt; 5 then ( let d = abs_float (!s_old -. !o_old) in let e = eps *. abs_float !o_old in assert (not (d &lt; e || (!s_old = 0. &amp;&amp; !o_old = 0.))); o_old := !s_old; o_new := !s_new) done with | _ -&gt; ()); !s_new The function simpson takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. Step-by-step Explanation The simpson function takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. The function initializes four variables: s_new, s_old, o_new, and o_old, all of which are set to 0. s_new and s_old will be used to store the current and previous approximations of the integral, respectively, while o_new and o_old will be used to store the current and previous approximations of the error, respectively. The function uses a try-with block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs. The function then enters a for loop that iterates from 1 to n. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the trapzd function, and stores it in the s_new variable. The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula: s_old = (4 * s_new - o_new) / 3 where s_old is the new approximation, s_new is the current approximation, and o_new is the previous approximation. The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (eps). If it is, the function returns the current approximation of the integral (s_new). If it is not, the function updates the o_old and o_new variables to store the current and previous approximations of the error, respectively. The function exits the loop and returns the current approximation of the integral (s_new). If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (s_new). Overall, the simpson function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into n subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the trapzd function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. Complexity Analysis The time complexity of the simpson function depends on the number of intervals used in the approximation (n) and the maximum relative error allowed (eps). The trapzd function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a for loop that iterates n times to compute the sum of the areas of the trapezoids. The simpson function uses the trapzd function n times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. The time complexity of the simpson function can be approximated as follows: The for loop that iterates from 1 to n has a time complexity of O(n). The trapzd function is called n times, so its time complexity is O(n^2). The time complexity of the computations inside the loop is O(1). The if statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1). The try-with block has a time complexity of O(1). The function returns the current approximation of the integral, which has a time complexity of O(1). Therefore, the overall time complexity of the simpson function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (n) increases. The maximum relative error allowed (eps) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of eps will result in a more accurate approximation, but will also require more iterations of the for loop and hence increase the running time of the function.","headline":"Simpson’s Rule","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/21/simpson-rule.html"},"url":"/algorithm/2023/11/21/simpson-rule.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simpson&#39;s Rule</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-21T02:00:00+02:00" itemprop="datePublished">
        Nov 21, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration.</p>

<h2 id="implementation">Implementation</h2>
<p>The following implementation is in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">simpson</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="p">(</span><span class="k">try</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
       <span class="n">s_new</span> <span class="o">:=</span> <span class="n">trapzd</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span><span class="p">;</span>
       <span class="n">s_old</span> <span class="o">:=</span> <span class="p">((</span><span class="mi">4</span><span class="o">.</span> <span class="o">*.</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_new</span><span class="p">)</span> <span class="o">/.</span> <span class="mi">3</span><span class="o">.;</span>
       <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span>
       <span class="k">then</span> <span class="p">(</span>
         <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_old</span><span class="p">)</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*.</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">o_old</span> <span class="k">in</span>
         <span class="k">assert</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)));</span>
         <span class="n">o_old</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_old</span><span class="p">;</span>
         <span class="n">o_new</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span>
     <span class="k">done</span>
   <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
  <span class="o">!</span><span class="n">s_new</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">simpson</code> takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">simpson</code> function takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>
  </li>
  <li>
    <p>The function initializes four variables: <code class="language-plaintext highlighter-rouge">s_new</code>, <code class="language-plaintext highlighter-rouge">s_old</code>, <code class="language-plaintext highlighter-rouge">o_new</code>, and <code class="language-plaintext highlighter-rouge">o_old</code>, all of which are set to 0. <code class="language-plaintext highlighter-rouge">s_new</code> and <code class="language-plaintext highlighter-rouge">s_old</code> will be used to store the current and previous approximations of the integral, respectively, while <code class="language-plaintext highlighter-rouge">o_new</code> and <code class="language-plaintext highlighter-rouge">o_old</code> will be used to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function uses a <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs.</p>
  </li>
  <li>
    <p>The function then enters a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code>. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the <code class="language-plaintext highlighter-rouge">trapzd</code> function, and stores it in the <code class="language-plaintext highlighter-rouge">s_new</code> variable.</p>
  </li>
  <li>
    <p>The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s_old = (4 * s_new - o_new) / 3  
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">s_old</code> is the new approximation, <code class="language-plaintext highlighter-rouge">s_new</code> is the current approximation, and <code class="language-plaintext highlighter-rouge">o_new</code> is the previous approximation.</p>

<ol>
  <li>
    <p>The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>). If it is, the function returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>). If it is not, the function updates the <code class="language-plaintext highlighter-rouge">o_old</code> and <code class="language-plaintext highlighter-rouge">o_new</code> variables to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function exits the loop and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
  <li>
    <p>If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
</ol>

<p>Overall, the <code class="language-plaintext highlighter-rouge">simpson</code> function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into <code class="language-plaintext highlighter-rouge">n</code> subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function depends on the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) and the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">trapzd</code> function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates <code class="language-plaintext highlighter-rouge">n</code> times to compute the sum of the areas of the trapezoids.</p>

<p>The <code class="language-plaintext highlighter-rouge">simpson</code> function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function <code class="language-plaintext highlighter-rouge">n</code> times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function can be approximated as follows:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code> has a time complexity of O(n).</li>
  <li>The <code class="language-plaintext highlighter-rouge">trapzd</code> function is called <code class="language-plaintext highlighter-rouge">n</code> times, so its time complexity is O(n^2).</li>
  <li>The time complexity of the computations inside the loop is O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">if</code> statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block has a time complexity of O(1).</li>
  <li>The function returns the current approximation of the integral, which has a time complexity of O(1).</li>
</ul>

<p>Therefore, the overall time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) increases. The maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of <code class="language-plaintext highlighter-rouge">eps</code> will result in a more accurate approximation, but will also require more iterations of the <code class="language-plaintext highlighter-rouge">for</code> loop and hence increase the running time of the function.</p>

  </div><a class="u-url" href="/algorithm/2023/11/21/simpson-rule.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
