<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Brent’s Algorithm | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Brent’s Algorithm" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle." />
<meta property="og:description" content="Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle." />
<link rel="canonical" href="/algorithm/2023/11/21/brents-algorithm.html" />
<meta property="og:url" content="/algorithm/2023/11/21/brents-algorithm.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-21T03:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Brent’s Algorithm" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-21T03:00:00+02:00","datePublished":"2023-11-21T03:00:00+02:00","description":"Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.","headline":"Brent’s Algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/21/brents-algorithm.html"},"url":"/algorithm/2023/11/21/brents-algorithm.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Brent&#39;s Algorithm</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-21T03:00:00+02:00" itemprop="datePublished">
        Nov 21, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Brent’s algorithm in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">power</span> <span class="n">lam</span> <span class="n">tortoise</span> <span class="n">hare</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">hare</span> <span class="k">then</span> <span class="n">lam</span>  
    <span class="k">else</span> <span class="k">if</span> <span class="n">power</span> <span class="o">=</span> <span class="n">lam</span> <span class="k">then</span> <span class="n">loop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="mi">0</span> <span class="n">hare</span> <span class="n">hare</span>  
    <span class="k">else</span> <span class="n">loop</span> <span class="n">power</span> <span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tortoise</span> <span class="p">(</span><span class="n">f</span> <span class="n">hare</span><span class="p">)</span>  
  <span class="k">in</span> <span class="n">loop</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x0</span> <span class="p">(</span><span class="n">f</span> <span class="n">x0</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function takes two arguments: <code class="language-plaintext highlighter-rouge">f</code>, a function that takes a value and returns the next value in the sequence, and <code class="language-plaintext highlighter-rouge">x0</code>, the initial value in the sequence. The function returns the length of the cycle in the sequence.</p>

<p>Here is an example of how to use the <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">23</span>  
<span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="k">let</span> <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span>  
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">f</code> is a function that generates a sequence of values using the formula <code class="language-plaintext highlighter-rouge">x^2 + 1 (mod 23)</code>, <code class="language-plaintext highlighter-rouge">x0</code> is the initial value of the sequence, and <code class="language-plaintext highlighter-rouge">cycle_length</code> is the length of the cycle in the sequence.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before.</p>

<p>At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence.</p>

<p>The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time.</p>

<p>The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables.</p>

<p>Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.</p>

  </div><a class="u-url" href="/algorithm/2023/11/21/brents-algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
