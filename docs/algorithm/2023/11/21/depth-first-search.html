<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Depth-First Search | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Depth-First Search" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type &#39;a graph = (&#39;a * &#39;a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (explore (node :: visited) graph) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [(&quot;A&quot;, [&quot;B&quot;; &quot;C&quot;; &quot;D&quot;]); (&quot;B&quot;, [&quot;E&quot;]); (&quot;C&quot;, [&quot;F&quot;]); (&quot;D&quot;, []); (&quot;E&quot;, []); (&quot;F&quot;, [&quot;G&quot;]); (&quot;G&quot;, [])] let visited = dfs graph &quot;A&quot; let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls." />
<meta property="og:description" content="Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type &#39;a graph = (&#39;a * &#39;a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (explore (node :: visited) graph) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [(&quot;A&quot;, [&quot;B&quot;; &quot;C&quot;; &quot;D&quot;]); (&quot;B&quot;, [&quot;E&quot;]); (&quot;C&quot;, [&quot;F&quot;]); (&quot;D&quot;, []); (&quot;E&quot;, []); (&quot;F&quot;, [&quot;G&quot;]); (&quot;G&quot;, [])] let visited = dfs graph &quot;A&quot; let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls." />
<link rel="canonical" href="/algorithm/2023/11/21/depth-first-search.html" />
<meta property="og:url" content="/algorithm/2023/11/21/depth-first-search.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-21T01:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Depth-First Search" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-21T01:00:00+02:00","datePublished":"2023-11-21T01:00:00+02:00","description":"Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type &#39;a graph = (&#39;a * &#39;a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (explore (node :: visited) graph) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [(&quot;A&quot;, [&quot;B&quot;; &quot;C&quot;; &quot;D&quot;]); (&quot;B&quot;, [&quot;E&quot;]); (&quot;C&quot;, [&quot;F&quot;]); (&quot;D&quot;, []); (&quot;E&quot;, []); (&quot;F&quot;, [&quot;G&quot;]); (&quot;G&quot;, [])] let visited = dfs graph &quot;A&quot; let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.","headline":"Depth-First Search","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/21/depth-first-search.html"},"url":"/algorithm/2023/11/21/depth-first-search.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Depth-First Search</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-21T01:00:00+02:00" itemprop="datePublished">
        Nov 21, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of DFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>  
   
<span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">graph</span> <span class="n">node</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">visited</span>  
  <span class="k">else</span> <span class="n">node</span> <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="n">explore</span> <span class="p">(</span><span class="n">node</span> <span class="o">::</span> <span class="n">visited</span><span class="p">)</span> <span class="n">graph</span><span class="p">)</span> <span class="n">visited</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span><span class="p">)</span>  
   
<span class="k">let</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="n">start</span> <span class="o">=</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="p">(</span><span class="n">explore</span> <span class="bp">[]</span> <span class="n">graph</span> <span class="n">start</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">explore</code> function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">visited</code> parameter keeps track of the visited nodes to avoid visiting them again. The <code class="language-plaintext highlighter-rouge">dfs</code> function calls <code class="language-plaintext highlighter-rouge">explore</code> with an empty <code class="language-plaintext highlighter-rouge">visited</code> list and the starting node and returns the visited nodes in reverse order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">dfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"E"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"F"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"G"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"G"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)]</span>  
   
<span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="s2">"A"</span>  
   
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">visited</span>  
</code></pre></div></div>

<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
B  
E  
C  
F  
G  
D  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start at the given starting node.</li>
  <li>Mark the node as visited and add it to the visited list.</li>
  <li>For each adjacent node that is not visited, recursively call <code class="language-plaintext highlighter-rouge">explore</code> with the visited list and the adjacent node.</li>
  <li>Return the visited list in reverse order.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.</p>

  </div><a class="u-url" href="/algorithm/2023/11/21/depth-first-search.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
