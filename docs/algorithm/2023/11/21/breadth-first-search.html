<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Breadth-First Search | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Breadth-First Search" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list" />
<meta property="og:description" content="Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list" />
<link rel="canonical" href="/algorithm/2023/11/21/breadth-first-search.html" />
<meta property="og:url" content="/algorithm/2023/11/21/breadth-first-search.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-21T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Breadth-First Search" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-21T02:00:00+02:00","datePublished":"2023-11-21T02:00:00+02:00","description":"Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list","headline":"Breadth-First Search","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/21/breadth-first-search.html"},"url":"/algorithm/2023/11/21/breadth-first-search.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Breadth-First Search</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-21T02:00:00+02:00" itemprop="datePublished">
        Nov 21, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of BFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">bfs</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">queue</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">queue</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">visited</span>
    <span class="o">|</span> <span class="n">node</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span>
          <span class="n">explore</span> <span class="n">visited</span> <span class="n">rest</span>
        <span class="k">else</span>
          <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">new_nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">n</span> <span class="n">visited</span><span class="p">))</span> <span class="n">neighbors</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">updated_queue</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">@</span> <span class="n">new_nodes</span> <span class="k">in</span>
          <span class="n">explore</span> <span class="p">(</span><span class="n">visited</span> <span class="o">@</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="n">updated_queue</span>
  <span class="k">in</span> <span class="n">explore</span> <span class="bp">[]</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> parameter is a list of tuples, where the first element is a node and the second element is a list of its neighboring nodes. The <code class="language-plaintext highlighter-rouge">start</code> parameter is the node where the search begins. The function returns a list of nodes visited in breadth-first order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">bfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="p">[</span>
    <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
  <span class="p">]</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span> <span class="n">graph</span> <span class="s2">"A"</span> <span class="c">(* ["A"; "B"; "C"; "D"; "E"; "F"] *)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an empty <code class="language-plaintext highlighter-rouge">visited</code> list and a <code class="language-plaintext highlighter-rouge">queue</code> with the starting node in it.</li>
  <li>While the <code class="language-plaintext highlighter-rouge">queue</code> is not empty, take the first node from the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has already been visited, skip it and continue to the next node in the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has not been visited, add it to the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
  <li>Get the list of neighboring nodes for the current node from the <code class="language-plaintext highlighter-rouge">graph</code>.</li>
  <li>Filter out the nodes that have already been visited.</li>
  <li>Add the remaining nodes to the end of the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>Repeat steps 2-7 until the <code class="language-plaintext highlighter-rouge">queue</code> is empty.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices and <code class="language-plaintext highlighter-rouge">|E|</code> is the number of edges in the graph. This is because BFS visits each vertex and edge exactly once.</p>

<p>The space complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices in the graph. This is because BFS uses a queue to store the nodes to be visited, and the maximum size of the queue is the number of vertices at the maximum depth of the graph. In the worst case, this is all the vertices, so the space complexity is <code class="language-plaintext highlighter-rouge">O(|V|)</code>.</p>

  </div><a class="u-url" href="/algorithm/2023/11/21/breadth-first-search.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
