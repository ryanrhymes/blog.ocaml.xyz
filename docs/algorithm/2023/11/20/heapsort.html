<!-- _layouts/default.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Heapsort</title>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-123353217-1');
  </script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script>

</head>
<body>

  <div id="main-content">
    <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Heapsort</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-11-20T22:04:00+02:00" itemprop="datePublished">Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of heapsort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
   
<span class="k">let</span> <span class="k">rec</span> <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">in</span>  
  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">left</span><span class="p">;</span>  
  <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">right</span><span class="p">;</span>  
  <span class="k">if</span> <span class="o">!</span><span class="n">largest</span> <span class="o">&lt;&gt;</span> <span class="n">i</span> <span class="k">then</span> <span class="p">(</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="o">!</span><span class="n">largest</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="o">!</span><span class="n">largest</span>  
  <span class="p">)</span>  
   
<span class="k">let</span> <span class="n">heapsort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="mi">0</span> <span class="n">i</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">i</span> <span class="mi">0</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here is an example of how to use the heapsort function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="n">heapsort</span> <span class="n">arr</span><span class="p">;</span>  
<span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 7  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap.</li>
  <li>Swap the root node with the last element in the array. Decrease the heap size by 1.</li>
  <li>Call heapify on the root node to restore the heap property.</li>
  <li>Repeat steps 2-3 until the heap size is 1.</li>
</ol>

<p>The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n).</p>

<p>Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.</p>

  </div><a class="u-url" href="/algorithm/2023/11/20/heapsort.html" hidden></a>
</article>

  </div>

</body>
</html>
