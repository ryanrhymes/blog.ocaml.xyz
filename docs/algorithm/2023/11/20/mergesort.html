<!-- _layouts/default.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Merge Sort</title>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-123353217-1');
  </script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script>

</head>
<body>

  <div id="main-content">
    <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Merge Sort</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-11-20T23:01:00+02:00" itemprop="datePublished">Nov 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>

  </div><a class="u-url" href="/algorithm/2023/11/20/mergesort.html" hidden></a>
</article>

  </div>

</body>
</html>
