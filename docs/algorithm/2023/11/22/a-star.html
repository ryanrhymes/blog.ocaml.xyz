<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>A* (A-Star) Algorithm | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="A* (A-Star) Algorithm" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step. Implementation The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function find_path takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path. ```ocaml module IntPairs = struct type t = int * int let compare (x0,y0) (x1,y1) = match Stdlib.compare x0 x1 with | 0 -&gt; Stdlib.compare y0 y1 | c -&gt; c end" />
<meta property="og:description" content="Introduction The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step. Implementation The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function find_path takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path. ```ocaml module IntPairs = struct type t = int * int let compare (x0,y0) (x1,y1) = match Stdlib.compare x0 x1 with | 0 -&gt; Stdlib.compare y0 y1 | c -&gt; c end" />
<link rel="canonical" href="/algorithm/2023/11/22/a-star.html" />
<meta property="og:url" content="/algorithm/2023/11/22/a-star.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-22T09:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="A* (A-Star) Algorithm" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-22T09:00:00+02:00","datePublished":"2023-11-22T09:00:00+02:00","description":"Introduction The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step. Implementation The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function find_path takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path. ```ocaml module IntPairs = struct type t = int * int let compare (x0,y0) (x1,y1) = match Stdlib.compare x0 x1 with | 0 -&gt; Stdlib.compare y0 y1 | c -&gt; c end","headline":"A* (A-Star) Algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/22/a-star.html"},"url":"/algorithm/2023/11/22/a-star.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">A* (A-Star) Algorithm</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-22T09:00:00+02:00" itemprop="datePublished">
        Nov 22, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step.</p>

<h2 id="implementation">Implementation</h2>

<p>The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function <code class="language-plaintext highlighter-rouge">find_path</code> takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">IntPairs</span> <span class="o">=</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
    <span class="k">let</span> <span class="n">compare</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span><span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
      <span class="k">match</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">x0</span> <span class="n">x1</span> <span class="k">with</span>
      <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">y0</span> <span class="n">y1</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="k">end</span>

<span class="k">module</span> <span class="nc">PairsMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>
<span class="k">module</span> <span class="nc">PairsSet</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>


<span class="k">let</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">get_neighbors</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">moves</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
                 <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">_x</span><span class="o">,</span> <span class="n">_y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+_</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+_</span><span class="n">y</span><span class="p">)</span> <span class="n">moves</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">max_x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">max_y</span>
        <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="n">ms</span> <span class="k">in</span>
    <span class="p">(</span><span class="n">ms</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">h</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span> <span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">abs</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span> <span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="p">(</span><span class="n">h</span> <span class="n">goal</span> <span class="n">start</span><span class="p">)</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="mi">0</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">current</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">from</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">from</span> <span class="o">=</span> <span class="n">start</span> <span class="k">then</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span> <span class="n">from</span>
    <span class="k">in</span>
    <span class="n">aux</span> <span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="n">current</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="k">in</span>
    <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="n">gScore</span> <span class="n">cell</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">cell</span> <span class="n">gScore</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">max_int</span>
  <span class="k">in</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">is_empty</span> <span class="n">openSet</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span>
      <span class="nn">PairsSet</span><span class="p">.</span><span class="n">fold</span> <span class="p">(</span><span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span>
          <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p1</span> <span class="n">fScore</span>
          <span class="ow">and</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p2</span> <span class="n">fScore</span> <span class="k">in</span>
          <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span> <span class="n">p2</span>
      <span class="p">)</span> <span class="n">openSet</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="k">if</span> <span class="n">current</span> <span class="o">=</span> <span class="n">goal</span> <span class="k">then</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span><span class="p">)</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">remove</span> <span class="n">current</span> <span class="n">openSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">current</span> <span class="n">closedSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span> <span class="n">current</span> <span class="k">in</span>
    <span class="n">neighbors</span> <span class="o">|&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span>
        <span class="p">(</span><span class="k">fun</span> <span class="p">((</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="k">as</span> <span class="n">v</span><span class="p">)</span> <span class="n">neighbor</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">closedSet</span> <span class="k">then</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">else</span>
            <span class="k">let</span> <span class="n">tentative_gScore</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">tentative_gScore</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">then</span>
              <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">tentative_gScore</span> <span class="n">gScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="n">neighbor</span> <span class="n">goal</span><span class="p">)</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">f</span> <span class="n">fScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span>
                <span class="k">if</span> <span class="n">not</span> <span class="p">(</span><span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">openSet</span><span class="p">)</span>
                <span class="k">then</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">openSet</span> <span class="k">else</span> <span class="n">openSet</span>
              <span class="k">in</span>
              <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">)</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">_find_path</span>
  <span class="k">in</span>
  <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>

</code></pre></div></div>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
  <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">dim_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dim_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"path not found"</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" (%d, %d)</span><span class="se">\n</span><span class="s2">"</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">_board</span> <span class="o">=</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_y</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span>
          <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_x</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">'</span><span class="o">#</span><span class="k">'</span> <span class="k">else</span> <span class="sc">'.'</span><span class="p">))</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="k">'</span><span class="o">*</span><span class="k">'</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>

      <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
          <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" %c"</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">)</span> <span class="n">line</span><span class="p">;</span>
        <span class="n">print_newline</span> <span class="bp">()</span>
      <span class="p">)</span> <span class="n">_board</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The maximum x and y coordinates of the board are obtained using the <code class="language-plaintext highlighter-rouge">Array.length</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">get_neighbors</code> function takes a position (x,y) and returns a list of neighboring positions that are not obstacles.</li>
  <li>The <code class="language-plaintext highlighter-rouge">h</code> function takes two positions and returns the Manhattan distance between them.</li>
  <li>The openSet is initialized with the starting position, and the closedSet is empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">fScore</code> and <code class="language-plaintext highlighter-rouge">gScore</code> maps are initialized with the starting position, where <code class="language-plaintext highlighter-rouge">fScore</code> is the sum of <code class="language-plaintext highlighter-rouge">gScore</code> and the heuristic function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">cameFrom</code> map is initialized as empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">reconstruct_path</code> function takes the <code class="language-plaintext highlighter-rouge">cameFrom</code> map and the current position and returns the path from the starting position to the current position.</li>
  <li>The <code class="language-plaintext highlighter-rouge">d</code> function takes two positions and returns the cost of moving from the first position to the second.</li>
  <li>The <code class="language-plaintext highlighter-rouge">g</code> function takes the <code class="language-plaintext highlighter-rouge">gScore</code> map and a position and returns its <code class="language-plaintext highlighter-rouge">gScore</code> value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">_find_path</code> function takes the current state of the search and performs the following steps:
    <ul>
      <li>If the openSet is empty, return None.</li>
      <li>Select the node with the lowest <code class="language-plaintext highlighter-rouge">fScore</code> value from the openSet.</li>
      <li>If the selected node is the goal, return the reconstructed path from the starting position to the goal.</li>
      <li>Remove the selected node from the openSet and add it to the closedSet.</li>
      <li>Generate a list of neighboring nodes.</li>
      <li>For each neighboring node:</li>
    </ul>
    <ul>
      <li>If it is in the closedSet, skip it.</li>
      <li>Calculate the tentative <code class="language-plaintext highlighter-rouge">gScore</code> value for the node.</li>
      <li>If the <code class="language-plaintext highlighter-rouge">gScore</code> value is better than the current value, update the <code class="language-plaintext highlighter-rouge">gScore</code>, <code class="language-plaintext highlighter-rouge">fScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps.</li>
      <li>If the node is not in the openSet, add it to the openSet.<br />
        - Recursively call <code class="language-plaintext highlighter-rouge">_find_path</code> with the updated state.</li>
    </ul>
  </li>
  <li>Call <code class="language-plaintext highlighter-rouge">_find_path</code> with the initial state.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of the A* algorithm depends on the heuristic function used and the size of the board. In the worst case, where the heuristic function overestimates the true distance, the algorithm can explore all nodes in the board, resulting in a time complexity of O(b^d), where b is the branching factor (number of neighbors per node) and d is the depth of the goal node. However, in practice, the algorithm often explores fewer nodes than this worst-case bound.</p>

<p>The space complexity of the algorithm is also dependent on the size of the board, as it stores the openSet, closedSet, <code class="language-plaintext highlighter-rouge">fScore</code>, <code class="language-plaintext highlighter-rouge">gScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps. However, the space complexity can be reduced by using a more memory-efficient data structure for the</p>

  </div><a class="u-url" href="/algorithm/2023/11/22/a-star.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
