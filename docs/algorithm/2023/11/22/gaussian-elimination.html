<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Gaussian Elimination | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Gaussian Elimination" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics. Implementation The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix a representing the coefficients of the linear equations, and a matrix b representing the constants of the linear equations. The function returns two matrices: the transformed matrix a and the solution matrix b. let linsolve_gauss a b = let dims_a, dims_b = M.shape a, M.shape b in let _, _ = _check_is_matrix dims_a, _check_is_matrix dims_b in let a = M.copy a in let b = M.copy b in let n = dims_a.(0) in let m = dims_b.(1) in let icol = ref 0 in let irow = ref 0 in let dum = ref 0.0 in let pivinv = ref 0.0 in let indxc = Array.make n 0 in let indxr = Array.make n 0 in let ipiv = Array.make n 0 in (* Main loop over the columns to be reduced. *) for i = 0 to n - 1 do let big = ref 0.0 in (* Outer loop of the search for at pivot element *) for j = 0 to n - 1 do if ipiv.(j) &lt;&gt; 1 then for k = 0 to n - 1 do if ipiv.(k) == 0 then ( let v = M.get a [| j; k |] |&gt; abs_float in if v &gt;= !big then ( big := v; irow := j; icol := k)) done done; ipiv.(!icol) &lt;- ipiv.(!icol) + 1; if !irow &lt;&gt; !icol then ( for l = 0 to n - 1 do let u = M.get a [| !irow; l |] in let v = M.get a [| !icol; l |] in M.set a [| !icol; l |] u; M.set a [| !irow; l |] v done; for l = 0 to m - 1 do let u = M.get b [| !irow; l |] in let v = M.get b [| !icol; l |] in M.set b [| !icol; l |] u; M.set b [| !irow; l |] v done); indxr.(i) &lt;- !irow; indxc.(i) &lt;- !icol; let p = M.get a [| !icol; !icol |] in if p = 0.0 then raise Owl_exception.SINGULAR; pivinv := 1.0 /. p; M.set a [| !icol; !icol |] 1.0; for l = 0 to n - 1 do let prev = M.get a [| !icol; l |] in M.set a [| !icol; l |] (prev *. !pivinv) done; for l = 0 to m - 1 do let prev = M.get b [| !icol; l |] in M.set b [| !icol; l |] (prev *. !pivinv) done; for ll = 0 to n - 1 do if ll &lt;&gt; !icol then ( dum := M.get a [| ll; !icol |]; M.set a [| ll; !icol |] 0.0; for l = 0 to n - 1 do let p = M.get a [| !icol; l |] in let prev = M.get a [| ll; l |] in M.set a [| ll; l |] (prev -. (p *. !dum)) done; for l = 0 to m - 1 do let p = M.get b [| !icol; l |] in let prev = M.get b [| ll; l |] in M.set b [| ll; l |] (prev -. (p *. !dum)) done) done done; for l = n - 1 downto 0 do if indxr.(l) &lt;&gt; indxc.(l) then for k = 0 to n - 1 do let u = M.get a [| k; indxr.(l) |] in let v = M.get a [| k; indxc.(l) |] in M.set a [| k; indxc.(l) |] u; M.set a [| k; indxr.(l) |] v done done; a, b Step-by-step Explanation The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0. The implementation of the algorithm in OCaml begins by checking that the input matrices a and b are valid matrices. The function then creates copies of a and b to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm. The main loop of the algorithm iterates over the columns of the matrix a to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular. After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix a is in row echelon form. The algorithm then performs back substitution to transform the row echelon form of a into the reduced row echelon form. The algorithm iterates over the rows of a in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix a is in reduced row echelon form. Finally, the algorithm returns the transformed matrix a and the solution matrix b. Complexity Analysis The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3. The space complexity of the algorithm is O(n^2), which is the size of the matrices a and b. The algorithm creates copies of a and b, so the space complexity is doubled. In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate." />
<meta property="og:description" content="Introduction Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics. Implementation The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix a representing the coefficients of the linear equations, and a matrix b representing the constants of the linear equations. The function returns two matrices: the transformed matrix a and the solution matrix b. let linsolve_gauss a b = let dims_a, dims_b = M.shape a, M.shape b in let _, _ = _check_is_matrix dims_a, _check_is_matrix dims_b in let a = M.copy a in let b = M.copy b in let n = dims_a.(0) in let m = dims_b.(1) in let icol = ref 0 in let irow = ref 0 in let dum = ref 0.0 in let pivinv = ref 0.0 in let indxc = Array.make n 0 in let indxr = Array.make n 0 in let ipiv = Array.make n 0 in (* Main loop over the columns to be reduced. *) for i = 0 to n - 1 do let big = ref 0.0 in (* Outer loop of the search for at pivot element *) for j = 0 to n - 1 do if ipiv.(j) &lt;&gt; 1 then for k = 0 to n - 1 do if ipiv.(k) == 0 then ( let v = M.get a [| j; k |] |&gt; abs_float in if v &gt;= !big then ( big := v; irow := j; icol := k)) done done; ipiv.(!icol) &lt;- ipiv.(!icol) + 1; if !irow &lt;&gt; !icol then ( for l = 0 to n - 1 do let u = M.get a [| !irow; l |] in let v = M.get a [| !icol; l |] in M.set a [| !icol; l |] u; M.set a [| !irow; l |] v done; for l = 0 to m - 1 do let u = M.get b [| !irow; l |] in let v = M.get b [| !icol; l |] in M.set b [| !icol; l |] u; M.set b [| !irow; l |] v done); indxr.(i) &lt;- !irow; indxc.(i) &lt;- !icol; let p = M.get a [| !icol; !icol |] in if p = 0.0 then raise Owl_exception.SINGULAR; pivinv := 1.0 /. p; M.set a [| !icol; !icol |] 1.0; for l = 0 to n - 1 do let prev = M.get a [| !icol; l |] in M.set a [| !icol; l |] (prev *. !pivinv) done; for l = 0 to m - 1 do let prev = M.get b [| !icol; l |] in M.set b [| !icol; l |] (prev *. !pivinv) done; for ll = 0 to n - 1 do if ll &lt;&gt; !icol then ( dum := M.get a [| ll; !icol |]; M.set a [| ll; !icol |] 0.0; for l = 0 to n - 1 do let p = M.get a [| !icol; l |] in let prev = M.get a [| ll; l |] in M.set a [| ll; l |] (prev -. (p *. !dum)) done; for l = 0 to m - 1 do let p = M.get b [| !icol; l |] in let prev = M.get b [| ll; l |] in M.set b [| ll; l |] (prev -. (p *. !dum)) done) done done; for l = n - 1 downto 0 do if indxr.(l) &lt;&gt; indxc.(l) then for k = 0 to n - 1 do let u = M.get a [| k; indxr.(l) |] in let v = M.get a [| k; indxc.(l) |] in M.set a [| k; indxc.(l) |] u; M.set a [| k; indxr.(l) |] v done done; a, b Step-by-step Explanation The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0. The implementation of the algorithm in OCaml begins by checking that the input matrices a and b are valid matrices. The function then creates copies of a and b to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm. The main loop of the algorithm iterates over the columns of the matrix a to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular. After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix a is in row echelon form. The algorithm then performs back substitution to transform the row echelon form of a into the reduced row echelon form. The algorithm iterates over the rows of a in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix a is in reduced row echelon form. Finally, the algorithm returns the transformed matrix a and the solution matrix b. Complexity Analysis The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3. The space complexity of the algorithm is O(n^2), which is the size of the matrices a and b. The algorithm creates copies of a and b, so the space complexity is doubled. In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate." />
<link rel="canonical" href="/algorithm/2023/11/22/gaussian-elimination.html" />
<meta property="og:url" content="/algorithm/2023/11/22/gaussian-elimination.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-22T03:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Gaussian Elimination" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-22T03:00:00+02:00","datePublished":"2023-11-22T03:00:00+02:00","description":"Introduction Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics. Implementation The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix a representing the coefficients of the linear equations, and a matrix b representing the constants of the linear equations. The function returns two matrices: the transformed matrix a and the solution matrix b. let linsolve_gauss a b = let dims_a, dims_b = M.shape a, M.shape b in let _, _ = _check_is_matrix dims_a, _check_is_matrix dims_b in let a = M.copy a in let b = M.copy b in let n = dims_a.(0) in let m = dims_b.(1) in let icol = ref 0 in let irow = ref 0 in let dum = ref 0.0 in let pivinv = ref 0.0 in let indxc = Array.make n 0 in let indxr = Array.make n 0 in let ipiv = Array.make n 0 in (* Main loop over the columns to be reduced. *) for i = 0 to n - 1 do let big = ref 0.0 in (* Outer loop of the search for at pivot element *) for j = 0 to n - 1 do if ipiv.(j) &lt;&gt; 1 then for k = 0 to n - 1 do if ipiv.(k) == 0 then ( let v = M.get a [| j; k |] |&gt; abs_float in if v &gt;= !big then ( big := v; irow := j; icol := k)) done done; ipiv.(!icol) &lt;- ipiv.(!icol) + 1; if !irow &lt;&gt; !icol then ( for l = 0 to n - 1 do let u = M.get a [| !irow; l |] in let v = M.get a [| !icol; l |] in M.set a [| !icol; l |] u; M.set a [| !irow; l |] v done; for l = 0 to m - 1 do let u = M.get b [| !irow; l |] in let v = M.get b [| !icol; l |] in M.set b [| !icol; l |] u; M.set b [| !irow; l |] v done); indxr.(i) &lt;- !irow; indxc.(i) &lt;- !icol; let p = M.get a [| !icol; !icol |] in if p = 0.0 then raise Owl_exception.SINGULAR; pivinv := 1.0 /. p; M.set a [| !icol; !icol |] 1.0; for l = 0 to n - 1 do let prev = M.get a [| !icol; l |] in M.set a [| !icol; l |] (prev *. !pivinv) done; for l = 0 to m - 1 do let prev = M.get b [| !icol; l |] in M.set b [| !icol; l |] (prev *. !pivinv) done; for ll = 0 to n - 1 do if ll &lt;&gt; !icol then ( dum := M.get a [| ll; !icol |]; M.set a [| ll; !icol |] 0.0; for l = 0 to n - 1 do let p = M.get a [| !icol; l |] in let prev = M.get a [| ll; l |] in M.set a [| ll; l |] (prev -. (p *. !dum)) done; for l = 0 to m - 1 do let p = M.get b [| !icol; l |] in let prev = M.get b [| ll; l |] in M.set b [| ll; l |] (prev -. (p *. !dum)) done) done done; for l = n - 1 downto 0 do if indxr.(l) &lt;&gt; indxc.(l) then for k = 0 to n - 1 do let u = M.get a [| k; indxr.(l) |] in let v = M.get a [| k; indxc.(l) |] in M.set a [| k; indxc.(l) |] u; M.set a [| k; indxr.(l) |] v done done; a, b Step-by-step Explanation The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0. The implementation of the algorithm in OCaml begins by checking that the input matrices a and b are valid matrices. The function then creates copies of a and b to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm. The main loop of the algorithm iterates over the columns of the matrix a to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular. After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix a is in row echelon form. The algorithm then performs back substitution to transform the row echelon form of a into the reduced row echelon form. The algorithm iterates over the rows of a in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix a is in reduced row echelon form. Finally, the algorithm returns the transformed matrix a and the solution matrix b. Complexity Analysis The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3. The space complexity of the algorithm is O(n^2), which is the size of the matrices a and b. The algorithm creates copies of a and b, so the space complexity is doubled. In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate.","headline":"Gaussian Elimination","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/22/gaussian-elimination.html"},"url":"/algorithm/2023/11/22/gaussian-elimination.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Gaussian Elimination</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-22T03:00:00+02:00" itemprop="datePublished">
        Nov 22, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics.</p>

<h2 id="implementation">Implementation</h2>
<p>The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix <code class="language-plaintext highlighter-rouge">a</code> representing the coefficients of the linear equations, and a matrix <code class="language-plaintext highlighter-rouge">b</code> representing the constants of the linear equations. The function returns two matrices: the transformed matrix <code class="language-plaintext highlighter-rouge">a</code> and the solution matrix <code class="language-plaintext highlighter-rouge">b</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">linsolve_gauss</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">dims_a</span><span class="o">,</span> <span class="n">dims_b</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="o">,</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_check_is_matrix</span> <span class="n">dims_a</span><span class="o">,</span> <span class="n">_check_is_matrix</span> <span class="n">dims_b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dims_a</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">dims_b</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">icol</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">irow</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dum</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pivinv</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">indxc</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">indxr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ipiv</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* Main loop over the columns to be reduced. *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">big</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
    <span class="c">(* Outer loop of the search for at pivot element *)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">1</span>
      <span class="k">then</span>
        <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">if</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">abs_float</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="o">!</span><span class="n">big</span>
            <span class="k">then</span> <span class="p">(</span>
              <span class="n">big</span> <span class="o">:=</span> <span class="n">v</span><span class="p">;</span>
              <span class="n">irow</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
              <span class="n">icol</span> <span class="o">:=</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">done</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">icol</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">icol</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">irow</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">icol</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span><span class="p">);</span>
    <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span>
    <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">then</span> <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">SINGULAR</span><span class="p">;</span>
    <span class="n">pivinv</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">/.</span> <span class="n">p</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pivinv</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pivinv</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">ll</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">icol</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">dum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">];</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">-.</span> <span class="p">(</span><span class="n">p</span> <span class="o">*.</span> <span class="o">!</span><span class="n">dum</span><span class="p">))</span>
        <span class="k">done</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">-.</span> <span class="p">(</span><span class="n">p</span> <span class="o">*.</span> <span class="o">!</span><span class="n">dum</span><span class="p">))</span>
        <span class="k">done</span><span class="p">)</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">then</span>
      <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">a</span><span class="o">,</span> <span class="n">b</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0.</p>

<p>The implementation of the algorithm in OCaml begins by checking that the input matrices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are valid matrices. The function then creates copies of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm.</p>

<p>The main loop of the algorithm iterates over the columns of the matrix <code class="language-plaintext highlighter-rouge">a</code> to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular.</p>

<p>After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix <code class="language-plaintext highlighter-rouge">a</code> is in row echelon form.</p>

<p>The algorithm then performs back substitution to transform the row echelon form of <code class="language-plaintext highlighter-rouge">a</code> into the reduced row echelon form. The algorithm iterates over the rows of <code class="language-plaintext highlighter-rouge">a</code> in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix <code class="language-plaintext highlighter-rouge">a</code> is in reduced row echelon form.</p>

<p>Finally, the algorithm returns the transformed matrix <code class="language-plaintext highlighter-rouge">a</code> and the solution matrix <code class="language-plaintext highlighter-rouge">b</code>.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3.</p>

<p>The space complexity of the algorithm is O(n^2), which is the size of the matrices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. The algorithm creates copies of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, so the space complexity is doubled.</p>

<p>In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate.</p>

  </div><a class="u-url" href="/algorithm/2023/11/22/gaussian-elimination.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
