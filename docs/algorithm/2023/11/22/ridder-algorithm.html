<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ridder’s Algorithm | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Ridder’s Algorithm" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Ridder’s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications. Implementation The algorithm is implemented in OCaml as follows: let ridder ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let xa = ref a in let xb = ref b in let fa = ref fa in let fb = ref fb in let x = ref infinity in try for _i = 1 to max_iter do let dm = 0.5 *. (!xb -. !xa) in let xm = !xa +. dm in let fm = f xm in let s = sqrt ((fm *. fm) -. (!fa *. !fb)) in assert (s &lt;&gt; 0.); let sgn = if !fa &lt; !fb then -1. else 1. in x := xm +. (sgn *. dm *. fm /. s); let fn = f !x in if Owl_base_maths.same_sign fn fm = false then ( xa := !x; xb := xm; fa := fn; fb := fm) else if Owl_base_maths.same_sign fn !fa = false then ( xb := !x; fb := fn) else ( xa := !x; fa := fn); assert (abs_float (!xb -. !xa) &gt;= xtol &amp;&amp; fn != 0.) done; !x with | _ -&gt; !x) The function takes three arguments: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. The function returns the estimated value of the root. Step-by-step Explanation The function ridder takes three input parameters: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. It also has two optional parameters: max_iter (maximum number of iterations) and xtol (tolerance level). The function returns the estimated value of the root. The function computes the value of f at the two endpoints a and b, and stores them in the variables fa and fb, respectively. The function checks if the product of fa and fb is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval [a, b]. The function checks if either fa or fb is zero. If either of them is zero, the function returns the corresponding value of a or b since the root is already found. The function initializes the variables xa, xb, fa, and fb with the values of a, b, fa, and fb, respectively. It also initializes the variable x with a value of infinity. The function enters a loop that runs for a maximum of max_iter iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge. Within the loop, the function computes the midpoint xm of the interval [xa, xb]. The function computes the value of f at xm and stores it in the variable fm. The function computes the value of s, which is the square root of (fm^2 - fa*fb). This value is used to determine the new estimate for the root. The function checks if s is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error. The function computes the sign of fa and fb and stores it in the variable sgn. If fa &lt; fb, sgn is set to -1, otherwise it is set to 1. The function computes the new estimate for the root using the formula x = xm + (sgn * dm * fm / s), where dm is half the distance between xa and xb. The function computes the value of f at the new estimate x and stores it in the variable fn. The function checks if fn and fm have opposite signs. If they do, the root is between xm and x, so the interval is updated to [xa, x] and fa and fb are updated accordingly. If they don’t, the root is between xa and x, so the interval is updated to [x, xb] and fa and fb are also updated accordingly. The function checks if fn and fa have opposite signs. If they do, the root is between xa and x, so the interval is updated to [xa, x] and fa is updated to fn. If they don’t, the root is between x and xb, so the interval is updated to [x, xb] and fb is updated to fn. The function checks if the absolute difference between xa and xb is less than xtol. If it is, the algorithm has converged and the function returns the estimated value of the root. If the loop has completed max_iter iterations without converging, the function raises an error. If an error occurs during the loop, the function returns the current estimate of the root. Overall, the algorithm works by iteratively refining the interval [xa, xb] until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint xm of the interval and the value of f at xm. It then uses these values to compute a new estimate for the root using the Ridder’s formula. The algorithm then updates the interval and the values of fa and fb based on whether the new estimate is closer to xa or xb. The algorithm repeats this process until the root is found or the maximum number of iterations is reached. Complexity Analysis The time complexity of the Ridder’s algorithm is O(log2(1/ε)), where ε is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of O(1) since it only uses a fixed number of variables regardless of the size of the input. However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval [a, b] is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm." />
<meta property="og:description" content="Introduction Ridder’s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications. Implementation The algorithm is implemented in OCaml as follows: let ridder ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let xa = ref a in let xb = ref b in let fa = ref fa in let fb = ref fb in let x = ref infinity in try for _i = 1 to max_iter do let dm = 0.5 *. (!xb -. !xa) in let xm = !xa +. dm in let fm = f xm in let s = sqrt ((fm *. fm) -. (!fa *. !fb)) in assert (s &lt;&gt; 0.); let sgn = if !fa &lt; !fb then -1. else 1. in x := xm +. (sgn *. dm *. fm /. s); let fn = f !x in if Owl_base_maths.same_sign fn fm = false then ( xa := !x; xb := xm; fa := fn; fb := fm) else if Owl_base_maths.same_sign fn !fa = false then ( xb := !x; fb := fn) else ( xa := !x; fa := fn); assert (abs_float (!xb -. !xa) &gt;= xtol &amp;&amp; fn != 0.) done; !x with | _ -&gt; !x) The function takes three arguments: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. The function returns the estimated value of the root. Step-by-step Explanation The function ridder takes three input parameters: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. It also has two optional parameters: max_iter (maximum number of iterations) and xtol (tolerance level). The function returns the estimated value of the root. The function computes the value of f at the two endpoints a and b, and stores them in the variables fa and fb, respectively. The function checks if the product of fa and fb is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval [a, b]. The function checks if either fa or fb is zero. If either of them is zero, the function returns the corresponding value of a or b since the root is already found. The function initializes the variables xa, xb, fa, and fb with the values of a, b, fa, and fb, respectively. It also initializes the variable x with a value of infinity. The function enters a loop that runs for a maximum of max_iter iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge. Within the loop, the function computes the midpoint xm of the interval [xa, xb]. The function computes the value of f at xm and stores it in the variable fm. The function computes the value of s, which is the square root of (fm^2 - fa*fb). This value is used to determine the new estimate for the root. The function checks if s is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error. The function computes the sign of fa and fb and stores it in the variable sgn. If fa &lt; fb, sgn is set to -1, otherwise it is set to 1. The function computes the new estimate for the root using the formula x = xm + (sgn * dm * fm / s), where dm is half the distance between xa and xb. The function computes the value of f at the new estimate x and stores it in the variable fn. The function checks if fn and fm have opposite signs. If they do, the root is between xm and x, so the interval is updated to [xa, x] and fa and fb are updated accordingly. If they don’t, the root is between xa and x, so the interval is updated to [x, xb] and fa and fb are also updated accordingly. The function checks if fn and fa have opposite signs. If they do, the root is between xa and x, so the interval is updated to [xa, x] and fa is updated to fn. If they don’t, the root is between x and xb, so the interval is updated to [x, xb] and fb is updated to fn. The function checks if the absolute difference between xa and xb is less than xtol. If it is, the algorithm has converged and the function returns the estimated value of the root. If the loop has completed max_iter iterations without converging, the function raises an error. If an error occurs during the loop, the function returns the current estimate of the root. Overall, the algorithm works by iteratively refining the interval [xa, xb] until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint xm of the interval and the value of f at xm. It then uses these values to compute a new estimate for the root using the Ridder’s formula. The algorithm then updates the interval and the values of fa and fb based on whether the new estimate is closer to xa or xb. The algorithm repeats this process until the root is found or the maximum number of iterations is reached. Complexity Analysis The time complexity of the Ridder’s algorithm is O(log2(1/ε)), where ε is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of O(1) since it only uses a fixed number of variables regardless of the size of the input. However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval [a, b] is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm." />
<link rel="canonical" href="/algorithm/2023/11/22/ridder-algorithm.html" />
<meta property="og:url" content="/algorithm/2023/11/22/ridder-algorithm.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-22T02:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ridder’s Algorithm" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2023-11-22T02:00:00+02:00","datePublished":"2023-11-22T02:00:00+02:00","description":"Introduction Ridder’s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications. Implementation The algorithm is implemented in OCaml as follows: let ridder ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf &quot;f(a) *. f(b) = %g *. %g should be negative.&quot; fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let xa = ref a in let xb = ref b in let fa = ref fa in let fb = ref fb in let x = ref infinity in try for _i = 1 to max_iter do let dm = 0.5 *. (!xb -. !xa) in let xm = !xa +. dm in let fm = f xm in let s = sqrt ((fm *. fm) -. (!fa *. !fb)) in assert (s &lt;&gt; 0.); let sgn = if !fa &lt; !fb then -1. else 1. in x := xm +. (sgn *. dm *. fm /. s); let fn = f !x in if Owl_base_maths.same_sign fn fm = false then ( xa := !x; xb := xm; fa := fn; fb := fm) else if Owl_base_maths.same_sign fn !fa = false then ( xb := !x; fb := fn) else ( xa := !x; fa := fn); assert (abs_float (!xb -. !xa) &gt;= xtol &amp;&amp; fn != 0.) done; !x with | _ -&gt; !x) The function takes three arguments: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. The function returns the estimated value of the root. Step-by-step Explanation The function ridder takes three input parameters: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. It also has two optional parameters: max_iter (maximum number of iterations) and xtol (tolerance level). The function returns the estimated value of the root. The function computes the value of f at the two endpoints a and b, and stores them in the variables fa and fb, respectively. The function checks if the product of fa and fb is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval [a, b]. The function checks if either fa or fb is zero. If either of them is zero, the function returns the corresponding value of a or b since the root is already found. The function initializes the variables xa, xb, fa, and fb with the values of a, b, fa, and fb, respectively. It also initializes the variable x with a value of infinity. The function enters a loop that runs for a maximum of max_iter iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge. Within the loop, the function computes the midpoint xm of the interval [xa, xb]. The function computes the value of f at xm and stores it in the variable fm. The function computes the value of s, which is the square root of (fm^2 - fa*fb). This value is used to determine the new estimate for the root. The function checks if s is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error. The function computes the sign of fa and fb and stores it in the variable sgn. If fa &lt; fb, sgn is set to -1, otherwise it is set to 1. The function computes the new estimate for the root using the formula x = xm + (sgn * dm * fm / s), where dm is half the distance between xa and xb. The function computes the value of f at the new estimate x and stores it in the variable fn. The function checks if fn and fm have opposite signs. If they do, the root is between xm and x, so the interval is updated to [xa, x] and fa and fb are updated accordingly. If they don’t, the root is between xa and x, so the interval is updated to [x, xb] and fa and fb are also updated accordingly. The function checks if fn and fa have opposite signs. If they do, the root is between xa and x, so the interval is updated to [xa, x] and fa is updated to fn. If they don’t, the root is between x and xb, so the interval is updated to [x, xb] and fb is updated to fn. The function checks if the absolute difference between xa and xb is less than xtol. If it is, the algorithm has converged and the function returns the estimated value of the root. If the loop has completed max_iter iterations without converging, the function raises an error. If an error occurs during the loop, the function returns the current estimate of the root. Overall, the algorithm works by iteratively refining the interval [xa, xb] until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint xm of the interval and the value of f at xm. It then uses these values to compute a new estimate for the root using the Ridder’s formula. The algorithm then updates the interval and the values of fa and fb based on whether the new estimate is closer to xa or xb. The algorithm repeats this process until the root is found or the maximum number of iterations is reached. Complexity Analysis The time complexity of the Ridder’s algorithm is O(log2(1/ε)), where ε is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of O(1) since it only uses a fixed number of variables regardless of the size of the input. However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval [a, b] is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm.","headline":"Ridder’s Algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2023/11/22/ridder-algorithm.html"},"url":"/algorithm/2023/11/22/ridder-algorithm.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ridder&#39;s Algorithm</h1>
    <p class="post-meta"><time class="dt-published" datetime="2023-11-22T02:00:00+02:00" itemprop="datePublished">
        Nov 22, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>Ridder’s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications.</p>

<h2 id="implementation">Implementation</h2>

<p>The algorithm is implemented in OCaml as follows:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ridder</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">xa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">a</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">xb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fa</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">dm</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">xm</span> <span class="o">=</span> <span class="o">!</span><span class="n">xa</span> <span class="o">+.</span> <span class="n">dm</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">f</span> <span class="n">xm</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">((</span><span class="n">fm</span> <span class="o">*.</span> <span class="n">fm</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">fa</span> <span class="o">*.</span> <span class="o">!</span><span class="n">fb</span><span class="p">))</span> <span class="k">in</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sgn</span> <span class="o">=</span> <span class="k">if</span> <span class="o">!</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">fb</span> <span class="k">then</span> <span class="o">-</span><span class="mi">1</span><span class="o">.</span> <span class="k">else</span> <span class="mi">1</span><span class="o">.</span> <span class="k">in</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">xm</span> <span class="o">+.</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">*.</span> <span class="n">dm</span> <span class="o">*.</span> <span class="n">fm</span> <span class="o">/.</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">f</span> <span class="o">!</span><span class="n">x</span> <span class="k">in</span>
        <span class="k">if</span> <span class="nn">Owl_base_maths</span><span class="p">.</span><span class="n">same_sign</span> <span class="n">fn</span> <span class="n">fm</span> <span class="o">=</span> <span class="bp">false</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="n">xm</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="n">fm</span><span class="p">)</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nn">Owl_base_maths</span><span class="p">.</span><span class="n">same_sign</span> <span class="n">fn</span> <span class="o">!</span><span class="n">fa</span> <span class="o">=</span> <span class="bp">false</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">(</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">);</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">xtol</span> <span class="o">&amp;&amp;</span> <span class="n">fn</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">x</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The function takes three arguments: the function <code class="language-plaintext highlighter-rouge">f</code> whose root needs to be found, and the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> within which to search for the root. The function returns the estimated value of the root.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">ridder</code> takes three input parameters: the function <code class="language-plaintext highlighter-rouge">f</code> whose root needs to be found, and the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> within which to search for the root. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">max_iter</code> (maximum number of iterations) and <code class="language-plaintext highlighter-rouge">xtol</code> (tolerance level). The function returns the estimated value of the root.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at the two endpoints <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, and stores them in the variables <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code>, respectively.</p>
  </li>
  <li>
    <p>The function checks if the product of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval <code class="language-plaintext highlighter-rouge">[a, b]</code>.</p>
  </li>
  <li>
    <p>The function checks if either <code class="language-plaintext highlighter-rouge">fa</code> or <code class="language-plaintext highlighter-rouge">fb</code> is zero. If either of them is zero, the function returns the corresponding value of <code class="language-plaintext highlighter-rouge">a</code> or <code class="language-plaintext highlighter-rouge">b</code> since the root is already found.</p>
  </li>
  <li>
    <p>The function initializes the variables <code class="language-plaintext highlighter-rouge">xa</code>, <code class="language-plaintext highlighter-rouge">xb</code>, <code class="language-plaintext highlighter-rouge">fa</code>, and <code class="language-plaintext highlighter-rouge">fb</code> with the values of <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">fa</code>, and <code class="language-plaintext highlighter-rouge">fb</code>, respectively. It also initializes the variable <code class="language-plaintext highlighter-rouge">x</code> with a value of infinity.</p>
  </li>
  <li>
    <p>The function enters a loop that runs for a maximum of <code class="language-plaintext highlighter-rouge">max_iter</code> iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge.</p>
  </li>
  <li>
    <p>Within the loop, the function computes the midpoint <code class="language-plaintext highlighter-rouge">xm</code> of the interval <code class="language-plaintext highlighter-rouge">[xa, xb]</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">xm</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">fm</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">s</code>, which is the square root of <code class="language-plaintext highlighter-rouge">(fm^2 - fa*fb)</code>. This value is used to determine the new estimate for the root.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">s</code> is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error.</p>
  </li>
  <li>
    <p>The function computes the sign of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">sgn</code>. If <code class="language-plaintext highlighter-rouge">fa &lt; fb</code>, <code class="language-plaintext highlighter-rouge">sgn</code> is set to <code class="language-plaintext highlighter-rouge">-1</code>, otherwise it is set to <code class="language-plaintext highlighter-rouge">1</code>.</p>
  </li>
  <li>
    <p>The function computes the new estimate for the root using the formula <code class="language-plaintext highlighter-rouge">x = xm + (sgn * dm * fm / s)</code>, where <code class="language-plaintext highlighter-rouge">dm</code> is half the distance between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">xb</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at the new estimate <code class="language-plaintext highlighter-rouge">x</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">fn</code>.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">fn</code> and <code class="language-plaintext highlighter-rouge">fm</code> have opposite signs. If they do, the root is between <code class="language-plaintext highlighter-rouge">xm</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[xa, x]</code> and <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> are updated accordingly. If they don’t, the root is between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[x, xb]</code> and <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> are also updated accordingly.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">fn</code> and <code class="language-plaintext highlighter-rouge">fa</code> have opposite signs. If they do, the root is between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[xa, x]</code> and <code class="language-plaintext highlighter-rouge">fa</code> is updated to <code class="language-plaintext highlighter-rouge">fn</code>. If they don’t, the root is between <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xb</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[x, xb]</code> and <code class="language-plaintext highlighter-rouge">fb</code> is updated to <code class="language-plaintext highlighter-rouge">fn</code>.</p>
  </li>
  <li>
    <p>The function checks if the absolute difference between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">xb</code> is less than <code class="language-plaintext highlighter-rouge">xtol</code>. If it is, the algorithm has converged and the function returns the estimated value of the root.</p>
  </li>
  <li>
    <p>If the loop has completed <code class="language-plaintext highlighter-rouge">max_iter</code> iterations without converging, the function raises an error.</p>
  </li>
  <li>
    <p>If an error occurs during the loop, the function returns the current estimate of the root.</p>
  </li>
</ol>

<p>Overall, the algorithm works by iteratively refining the interval <code class="language-plaintext highlighter-rouge">[xa, xb]</code> until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint <code class="language-plaintext highlighter-rouge">xm</code> of the interval and the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">xm</code>. It then uses these values to compute a new estimate for the root using the Ridder’s formula. The algorithm then updates the interval and the values of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> based on whether the new estimate is closer to <code class="language-plaintext highlighter-rouge">xa</code> or <code class="language-plaintext highlighter-rouge">xb</code>. The algorithm repeats this process until the root is found or the maximum number of iterations is reached.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of the Ridder’s algorithm is <code class="language-plaintext highlighter-rouge">O(log2(1/ε))</code>, where <code class="language-plaintext highlighter-rouge">ε</code> is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> since it only uses a fixed number of variables regardless of the size of the input.</p>

<p>However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm.</p>

  </div><a class="u-url" href="/algorithm/2023/11/22/ridder-algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
