<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Brownian Tree | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Brownian Tree" />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction Brownian Tree algorithm is a probabilistic method that creates a pattern resembling branches of a tree and is used mainly in computer graphics and physics simulations. The algorithm was named after Robert Brown, the first person who studied the movement of microscopic particles in liquids, known as Brownian motion. In image processing, the Brownian Tree can simulate the aggregation of particles under different conditions and generate fractal-like patterns." />
<meta property="og:description" content="Introduction Brownian Tree algorithm is a probabilistic method that creates a pattern resembling branches of a tree and is used mainly in computer graphics and physics simulations. The algorithm was named after Robert Brown, the first person who studied the movement of microscopic particles in liquids, known as Brownian motion. In image processing, the Brownian Tree can simulate the aggregation of particles under different conditions and generate fractal-like patterns." />
<link rel="canonical" href="/algorithm/2021/05/09/brownian-tree.html" />
<meta property="og:url" content="/algorithm/2021/05/09/brownian-tree.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-09T20:35:09+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Brownian Tree" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2021-05-09T20:35:09+03:00","datePublished":"2021-05-09T20:35:09+03:00","description":"Introduction Brownian Tree algorithm is a probabilistic method that creates a pattern resembling branches of a tree and is used mainly in computer graphics and physics simulations. The algorithm was named after Robert Brown, the first person who studied the movement of microscopic particles in liquids, known as Brownian motion. In image processing, the Brownian Tree can simulate the aggregation of particles under different conditions and generate fractal-like patterns.","headline":"Brownian Tree","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2021/05/09/brownian-tree.html"},"url":"/algorithm/2021/05/09/brownian-tree.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Brownian Tree</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-05-09T20:35:09+03:00" itemprop="datePublished">
        May 9, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>
<p>Brownian Tree algorithm is a probabilistic method that creates a pattern resembling branches of a tree and is used mainly in computer graphics and physics simulations. The algorithm was named after Robert Brown, the first person who studied the movement of microscopic particles in liquids, known as Brownian motion. In image processing, the Brownian Tree can simulate the aggregation of particles under different conditions and generate fractal-like patterns.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">(* Brownian Tree *)</span>

<span class="k">let</span> <span class="n">world_width</span> <span class="o">=</span> <span class="mi">400</span>
<span class="k">let</span> <span class="n">world_height</span> <span class="o">=</span> <span class="mi">400</span>
<span class="k">let</span> <span class="n">num_particles</span> <span class="o">=</span> <span class="mi">20_000</span>
 
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">assert</span><span class="p">(</span><span class="n">num_particles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">assert</span><span class="p">(</span><span class="n">world_width</span> <span class="o">*</span> <span class="n">world_height</span> <span class="o">&gt;</span> <span class="n">num_particles</span><span class="p">);</span>
<span class="p">;;</span> 
 
<span class="k">let</span> <span class="n">dla</span> <span class="o">~</span><span class="n">world</span> <span class="o">=</span>
  <span class="c">(* put the tree seed *)</span>
  <span class="n">world</span><span class="o">.</span><span class="p">(</span><span class="n">world_height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">world_width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">;</span>
 
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">num_particles</span> <span class="k">do</span>
    <span class="c">(* looping helper function *)</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">px</span> <span class="n">py</span> <span class="o">=</span>
      <span class="c">(* randomly choose a direction *)</span>
      <span class="k">let</span> <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c">(* offsets *)</span>
      <span class="ow">and</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">in</span>

      <span class="k">if</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">px</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">px</span> <span class="o">&gt;=</span> <span class="n">world_width</span> <span class="o">||</span>
         <span class="n">dy</span> <span class="o">+</span> <span class="n">py</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">dy</span> <span class="o">+</span> <span class="n">py</span> <span class="o">&gt;=</span> <span class="n">world_height</span> <span class="k">then</span>
        <span class="c">(* plop the particle into some other random location *)</span>
        <span class="n">aux</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">world_width</span><span class="p">)</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">world_height</span><span class="p">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="n">world</span><span class="o">.</span><span class="p">(</span><span class="n">py</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">px</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="k">then</span>
        <span class="c">(* bumped into something, particle set *)</span>
        <span class="n">world</span><span class="o">.</span><span class="p">(</span><span class="n">py</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">px</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">1</span>
      <span class="k">else</span>
        <span class="n">aux</span> <span class="p">(</span><span class="n">px</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="p">(</span><span class="n">py</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="c">(* set particle's initial position *)</span>
    <span class="n">aux</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">world_width</span><span class="p">)</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">world_height</span><span class="p">)</span>
  <span class="k">done</span>
 
<span class="k">let</span> <span class="n">to_pbm</span> <span class="o">~</span><span class="n">world</span> <span class="o">=</span>
  <span class="n">print_endline</span> <span class="s2">"P1"</span><span class="p">;</span>  <span class="c">(* Type=Portable bitmap, Encoding=ASCII *)</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d %d
"</span> <span class="n">world_width</span> <span class="n">world_height</span><span class="p">;</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span>
    <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_int</span> <span class="n">line</span><span class="p">;</span>
    <span class="n">print_newline</span><span class="bp">()</span>
  <span class="p">)</span> <span class="n">world</span>
 
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Random</span><span class="p">.</span><span class="n">self_init</span><span class="bp">()</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make_matrix</span> <span class="n">world_width</span> <span class="n">world_height</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="n">dla</span> <span class="o">~</span><span class="n">world</span><span class="p">;</span>
  <span class="n">to_pbm</span> <span class="o">~</span><span class="n">world</span><span class="p">;</span>
<span class="p">;;</span>

</code></pre></div></div>

<p>The Brownian Tree algorithm starts with a seed particle placed at the center of an image, representing the trunk of a tree. The algorithm then randomly adds particles, called walkers, to the image. Each walker moves in a random direction until it collides with another particle, which forms a new branch. The process repeats until the desired number of particles is reached, resulting in a fractal-like pattern.</p>

<p>The implementation is done using the programming language OCaml. The code creates a two-dimensional world with given dimensions <code class="language-plaintext highlighter-rouge">world_width</code> and <code class="language-plaintext highlighter-rouge">world_height</code>. The number of particles to add is defined by <code class="language-plaintext highlighter-rouge">num_particles</code>. The <code class="language-plaintext highlighter-rouge">dla</code> function implements the algorithm according to the above description. The <code class="language-plaintext highlighter-rouge">to_pbm</code> function converts the resulting matrix into a Portable Bitmap file format.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">world</code> matrix is initialized with zeros.</li>
  <li>The center of the matrix is set to <code class="language-plaintext highlighter-rouge">1</code>, representing the seed particle.</li>
  <li>A loop from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">num_particles</code> adds random particles called walkers.</li>
  <li>The <code class="language-plaintext highlighter-rouge">aux</code> function is a helper function that takes the position <code class="language-plaintext highlighter-rouge">(px, py)</code> of the current walker.</li>
  <li>At each step, a direction is randomly chosen for the walker by generating random integers <code class="language-plaintext highlighter-rouge">dx</code> and <code class="language-plaintext highlighter-rouge">dy</code> between <code class="language-plaintext highlighter-rouge">-1</code> and <code class="language-plaintext highlighter-rouge">1</code>.</li>
  <li>If the next position of the walker is outside the boundaries of the world, the walker is plopped into another random location.</li>
  <li>If the next position overlaps with another particle in the world, that particle is set as the new branch, and the current walker is removed.</li>
  <li>If none of the above conditions is met, the walker moves to the new position <code class="language-plaintext highlighter-rouge">(px + dx, py + dy)</code>, and the <code class="language-plaintext highlighter-rouge">aux</code> function is called recursively with this new position.</li>
  <li>The resulting world matrix is converted to a Portable Bitmap file format.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brownian Tree algorithm depends mainly on the number of iterations, which is the number of particles to add to the world. The algorithm uses a recursive function, which can go up to the maximum depth of <code class="language-plaintext highlighter-rouge">num_particles</code>. The worst-case time complexity of the algorithm can be approximated by O(num_particles * (world_width * world_height)^2), but in practice, the actual time complexity is much lower. The space complexity of the algorithm is O(world_width * world_height), which is the size of the 2D world matrix.</p>

  </div><a class="u-url" href="/algorithm/2021/05/09/brownian-tree.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
