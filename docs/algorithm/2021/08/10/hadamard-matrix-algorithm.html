<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hadamard Matrix algorithm. | Algorithm Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Hadamard Matrix algorithm." />
<meta name="author" content="Liang Wang" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="/algorithm/2021/08/10/hadamard-matrix-algorithm.html" />
<meta property="og:url" content="/algorithm/2021/08/10/hadamard-matrix-algorithm.html" />
<meta property="og:site_name" content="Algorithm Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-10T08:29:17+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hadamard Matrix algorithm." />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Liang Wang"},"dateModified":"2021-08-10T08:29:17+03:00","datePublished":"2021-08-10T08:29:17+03:00","description":"Introduction","headline":"Hadamard Matrix algorithm.","mainEntityOfPage":{"@type":"WebPage","@id":"/algorithm/2021/08/10/hadamard-matrix-algorithm.html"},"url":"/algorithm/2021/08/10/hadamard-matrix-algorithm.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Algorithm Blog" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-123353217-1"></script>
<script>
  window['ga-disable-UA-123353217-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123353217-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1868946892712371" crossorigin="anonymous"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Algorithm Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hadamard Matrix algorithm.</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-08-10T08:29:17+03:00" itemprop="datePublished">
        Aug 10, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>The Hadamard matrix, invented by French mathematician Jacques Philippe Marie Binet and named after Jacobi’s friend, James Joseph Sylvester, is a square matrix whose size is a power of two integers. The Hadamard matrix is significant and is widely used in many applications in diverse fields such as coding theory, signal processing, quantum computing, data encryption, and compression, among others. The matrix is orthogonal, meaning its rows and columns are mutually orthogonal, and it has a determinant of either 1 or -1.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">(* Hadamard Matrix *)</span>

<span class="k">let</span> <span class="n">hadamard</span> <span class="n">k</span> <span class="n">n</span> <span class="o">=</span>
  <span class="c">(* function to build up hadamard matrix recursively *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">_make_hadamard</span>
      <span class="p">(</span><span class="n">cp_op</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="nn">Owl_core_types</span><span class="p">.</span><span class="n">owl_arr_op18</span><span class="p">)</span>
      <span class="p">(</span><span class="n">neg_op</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="nn">Owl_core_types</span><span class="p">.</span><span class="n">owl_arr_op18</span><span class="p">)</span>
      <span class="n">len</span>
      <span class="n">n</span>
      <span class="n">base</span>
      <span class="n">x</span>
    <span class="o">=</span>
    <span class="k">if</span> <span class="n">len</span> <span class="o">=</span> <span class="n">base</span>
    <span class="k">then</span> <span class="bp">()</span>
    <span class="k">else</span> <span class="p">(</span>
      <span class="k">let</span> <span class="n">len'</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
      <span class="n">_make_hadamard</span> <span class="n">cp_op</span> <span class="n">neg_op</span> <span class="n">len'</span> <span class="n">n</span> <span class="n">base</span> <span class="n">x</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">ofsx</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len'</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">x1_ofs</span> <span class="o">=</span> <span class="o">!</span><span class="n">ofsx</span> <span class="o">+</span> <span class="n">len'</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">x2_ofs</span> <span class="o">=</span> <span class="o">!</span><span class="n">ofsx</span> <span class="o">+</span> <span class="p">(</span><span class="n">len'</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">x3_ofs</span> <span class="o">=</span> <span class="n">x2_ofs</span> <span class="o">+</span> <span class="n">len'</span> <span class="k">in</span>
        <span class="n">cp_op</span> <span class="n">len'</span> <span class="o">~</span><span class="n">ofsx</span><span class="o">:!</span><span class="n">ofsx</span> <span class="o">~</span><span class="n">incx</span><span class="o">:</span><span class="mi">1</span> <span class="o">~</span><span class="n">ofsy</span><span class="o">:</span><span class="n">x1_ofs</span> <span class="o">~</span><span class="n">incy</span><span class="o">:</span><span class="mi">1</span> <span class="n">x</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">cp_op</span> <span class="n">len'</span> <span class="o">~</span><span class="n">ofsx</span><span class="o">:!</span><span class="n">ofsx</span> <span class="o">~</span><span class="n">incx</span><span class="o">:</span><span class="mi">1</span> <span class="o">~</span><span class="n">ofsy</span><span class="o">:</span><span class="n">x2_ofs</span> <span class="o">~</span><span class="n">incy</span><span class="o">:</span><span class="mi">1</span> <span class="n">x</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">cp_op</span> <span class="n">len'</span> <span class="o">~</span><span class="n">ofsx</span><span class="o">:!</span><span class="n">ofsx</span> <span class="o">~</span><span class="n">incx</span><span class="o">:</span><span class="mi">1</span> <span class="o">~</span><span class="n">ofsy</span><span class="o">:</span><span class="n">x3_ofs</span> <span class="o">~</span><span class="n">incy</span><span class="o">:</span><span class="mi">1</span> <span class="n">x</span> <span class="n">x</span><span class="p">;</span>
        <span class="c">(* negate the bottom right block *)</span>
        <span class="n">neg_op</span> <span class="n">len'</span> <span class="o">~</span><span class="n">ofsx</span><span class="o">:</span><span class="n">x3_ofs</span> <span class="o">~</span><span class="n">incx</span><span class="o">:</span><span class="mi">1</span> <span class="o">~</span><span class="n">ofsy</span><span class="o">:</span><span class="n">x3_ofs</span> <span class="o">~</span><span class="n">incy</span><span class="o">:</span><span class="mi">1</span> <span class="n">x</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">ofsx</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ofsx</span> <span class="o">+</span> <span class="n">n</span>
      <span class="k">done</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="c">(* function to convert the pre-calculated hadamard array into type k *)</span>
  <span class="k">let</span> <span class="n">_float_array_to_k</span> <span class="o">:</span> <span class="k">type</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">kind</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="kt">array</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="kt">array</span> <span class="o">=</span>
   <span class="k">fun</span> <span class="n">k</span> <span class="n">a</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">k</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nc">Float32</span>   <span class="o">-&gt;</span> <span class="n">a</span>
    <span class="o">|</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nc">Float64</span>   <span class="o">-&gt;</span> <span class="n">a</span>
    <span class="o">|</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nc">Complex32</span> <span class="o">-&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="nn">Complex</span><span class="p">.{</span> <span class="n">re</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">im</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="p">})</span> <span class="n">a</span>
    <span class="o">|</span> <span class="nn">Bigarray</span><span class="p">.</span><span class="nc">Complex64</span> <span class="o">-&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="nn">Complex</span><span class="p">.{</span> <span class="n">re</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">im</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="p">})</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">_</span>                  <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Owl_dense_matrix_generic.hadamard"</span>
  <span class="k">in</span>
  <span class="c">(* start building, only deal with pow2 of n, n/12, n/20. *)</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">empty</span> <span class="n">k</span> <span class="n">n</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cp_op</span> <span class="o">=</span> <span class="n">_owl_copy</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">neg_op</span> <span class="o">=</span> <span class="n">_owl_neg</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">if</span> <span class="nn">Owl_maths</span><span class="p">.</span><span class="n">is_pow2</span> <span class="n">n</span>
  <span class="k">then</span> <span class="p">(</span>
    <span class="nn">Owl_dense_ndarray_generic</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="nn">Owl_const</span><span class="p">.</span><span class="n">one</span> <span class="n">k</span><span class="p">);</span>
    <span class="n">_make_hadamard</span> <span class="n">cp_op</span> <span class="n">neg_op</span> <span class="n">n</span> <span class="n">n</span> <span class="mi">1</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="p">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="nn">Owl_maths</span><span class="p">.</span><span class="n">is_pow2</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nn">Stdlib</span><span class="p">.(</span><span class="n">n</span> <span class="ow">mod</span> <span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">then</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_float_array_to_k</span> <span class="n">k</span> <span class="n">_hadamard_12</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">of_array</span> <span class="n">k</span> <span class="n">y</span> <span class="mi">12</span> <span class="mi">12</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">_area</span> <span class="o">=</span> <span class="n">area</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">11</span> <span class="mi">11</span> <span class="k">in</span>
    <span class="n">copy_area_to</span> <span class="n">y</span> <span class="n">_area</span> <span class="n">x</span> <span class="n">_area</span><span class="p">;</span>
    <span class="n">_make_hadamard</span> <span class="n">cp_op</span> <span class="n">neg_op</span> <span class="n">n</span> <span class="n">n</span> <span class="mi">12</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="p">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="nn">Owl_maths</span><span class="p">.</span><span class="n">is_pow2</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nn">Stdlib</span><span class="p">.(</span><span class="n">n</span> <span class="ow">mod</span> <span class="mi">20</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">then</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">_float_array_to_k</span> <span class="n">k</span> <span class="n">_hadamard_20</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">of_array</span> <span class="n">k</span> <span class="n">y</span> <span class="mi">20</span> <span class="mi">20</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">_area</span> <span class="o">=</span> <span class="n">area</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">19</span> <span class="mi">19</span> <span class="k">in</span>
    <span class="n">copy_area_to</span> <span class="n">y</span> <span class="n">_area</span> <span class="n">x</span> <span class="n">_area</span><span class="p">;</span>
    <span class="n">_make_hadamard</span> <span class="n">cp_op</span> <span class="n">neg_op</span> <span class="n">n</span> <span class="n">n</span> <span class="mi">20</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="p">)</span>
  <span class="k">else</span> <span class="n">failwith</span> <span class="s2">"Owl_dense_matrix_generic:hadamard"</span>

</code></pre></div></div>

<p>The Hadamard matrix algorithm in OCaml implements the process of generating Hadamard matrices using a recursive method. The algorithm builds a Hadamard matrix pad the base size of one by one. Afterward, the algorithm passes through the up-to-down and the left-to-right direction of the base size matrix, creating a block of tam by tam matrices that are negated.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<p>The Hadamard matrix algorithm builds up the Hadamard matrix using the following steps:</p>

<ul>
  <li>The algorithm contains a recursive internal function <code class="language-plaintext highlighter-rouge">_make_hadamard</code> that takes the pre-calculated matrix and performs recursive operations on it.</li>
  <li><code class="language-plaintext highlighter-rouge">_make_hadamard</code> is responsible for generating the Hadamard matrix recursively from the base size of one by one to the final size, n.</li>
  <li>If the length of the matrix equals the base size, then the execution stops. Otherwise, it continues to divide the matrix into four pieces.</li>
  <li>The first recursive call in building the matrix calls <code class="language-plaintext highlighter-rouge">_make_hadamard</code> function with the next size that is halved. The operation then keeps on continuing until it reaches the base case.</li>
  <li>The current matrix block gets negated in the bottom-right part of the matrix and continued to move to the rest nested levels.</li>
  <li>If n’s size is not a power of two or n modulo 12 or 20 is not zero, the function fails.</li>
</ul>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The Hadamard matrix algorithm has a time complexity of O(n^2log⁡n). The algorithm uses a recursive function to build the matrix, and if the size <code class="language-plaintext highlighter-rouge">n</code> is a power of two, it recursively makes four calls with a matrix of size <code class="language-plaintext highlighter-rouge">n / 2</code>. The function complexity grows with the recursion depth, which is log⁡n. The recursive function visits all the cells in the matrix while maintaining a constant overhead per cell. Therefore, the running time is O(n^2log⁡n). The algorithm’s space complexity is O(n^2) since it maintains a constant overhead for each cell.</p>

  </div><a class="u-url" href="/algorithm/2021/08/10/hadamard-matrix-algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Liang Wang</li>
          <li><a class="u-email" href="mailto:liang@ocaml.xyz">liang@ocaml.xyz</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
