<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-20T23:18:15+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Insertion Sort</title><link href="/algorithm/2023/11/20/insertion-sort.html" rel="alternate" type="text/html" title="Insertion Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/insertion-sort</id><content type="html" xml:base="/algorithm/2023/11/20/insertion-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.]]></summary></entry><entry><title type="html">Radix Sort</title><link href="/algorithm/2023/11/20/radix-sort.html" rel="alternate" type="text/html" title="Radix Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/radix-sort</id><content type="html" xml:base="/algorithm/2023/11/20/radix-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of radix sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">arr</span> <span class="n">exp</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span> <span class="k">else</span>  
      <span class="k">let</span> <span class="n">zeroes</span><span class="o">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
      <span class="n">loop</span> <span class="n">zeroes</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">loop</span> <span class="n">ones</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
  <span class="k">in</span>  
  <span class="n">loop</span> <span class="n">arr</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">int_of_float</span> <span class="p">(</span><span class="n">log10</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))))</span> <span class="mi">0</span> <span class="n">arr</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">radix_sort</code> takes in an array of integers <code class="language-plaintext highlighter-rouge">arr</code> and returns a sorted array. The <code class="language-plaintext highlighter-rouge">loop</code> function recursively sorts the array by partitioning it into two subarrays based on the value of the <code class="language-plaintext highlighter-rouge">exp</code>-th bit (starting from the most significant bit). The <code class="language-plaintext highlighter-rouge">exp</code> parameter is initially set to the maximum number of digits in any element of the array. The function <code class="language-plaintext highlighter-rouge">log10</code> is used to calculate the number of digits in each element.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum number of digits in any element of the array.</li>
  <li>For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit.</li>
  <li>Recursively sort each subarray by repeating step 2 with the next bit position.</li>
  <li>Concatenate the sorted subarrays to get the final sorted array.</li>
</ol>

<p>For example, let’s say we have the following array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 45, 75, 90, 802, 24, 2, 66]  
</code></pre></div></div>

<p>The maximum number of digits is 3, so we start by partitioning the array based on the third bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 90, 802, 2, 24, 45, 75, 66]  
</code></pre></div></div>

<p>We then recursively sort each subarray by partitioning based on the second bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[802, 2, 24, 45, 66, 170, 75, 90]  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<p>Finally, we concatenate the sorted subarrays to get the final sorted array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k).</p>

<p>In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.]]></summary></entry><entry><title type="html">Merge Sort</title><link href="/algorithm/2023/11/20/mergesort.html" rel="alternate" type="text/html" title="Merge Sort" /><published>2023-11-20T23:01:00+02:00</published><updated>2023-11-20T23:01:00+02:00</updated><id>/algorithm/2023/11/20/mergesort</id><content type="html" xml:base="/algorithm/2023/11/20/mergesort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).]]></summary></entry><entry><title type="html">Heapsort</title><link href="/algorithm/2023/11/20/heapsort.html" rel="alternate" type="text/html" title="Heapsort" /><published>2023-11-20T22:04:00+02:00</published><updated>2023-11-20T22:04:00+02:00</updated><id>/algorithm/2023/11/20/heapsort</id><content type="html" xml:base="/algorithm/2023/11/20/heapsort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of heapsort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>  
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
   
<span class="k">let</span> <span class="k">rec</span> <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">in</span>  
  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">left</span><span class="p">;</span>  
  <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>  
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">right</span><span class="p">;</span>  
  <span class="k">if</span> <span class="o">!</span><span class="n">largest</span> <span class="o">&lt;&gt;</span> <span class="n">i</span> <span class="k">then</span> <span class="p">(</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="o">!</span><span class="n">largest</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="o">!</span><span class="n">largest</span>  
  <span class="p">)</span>  
   
<span class="k">let</span> <span class="n">heapsort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="n">swap</span> <span class="n">arr</span> <span class="mi">0</span> <span class="n">i</span><span class="p">;</span>  
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">i</span> <span class="mi">0</span>  
  <span class="k">done</span>  
</code></pre></div></div>

<p>Here is an example of how to use the heapsort function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="n">heapsort</span> <span class="n">arr</span><span class="p">;</span>  
<span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 7  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap.</li>
  <li>Swap the root node with the last element in the array. Decrease the heap size by 1.</li>
  <li>Call heapify on the root node to restore the heap property.</li>
  <li>Repeat steps 2-3 until the heap size is 1.</li>
</ol>

<p>The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n).</p>

<p>Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp let rec heapify arr n i = let largest = ref i in let left = 2 * i + 1 in let right = 2 * i + 2 in if left &lt; n &amp;&amp; arr.(left) &gt; arr.(!largest) then largest := left; if right &lt; n &amp;&amp; arr.(right) &gt; arr.(!largest) then largest := right; if !largest &lt;&gt; i then ( swap arr i !largest; heapify arr n !largest ) let heapsort arr = let n = Array.length arr in for i = n / 2 - 1 downto 0 do heapify arr n i done; for i = n - 1 downto 1 do swap arr 0 i; heapify arr i 0 done Here is an example of how to use the heapsort function: let arr = [|4; 2; 7; 1; 3|] in heapsort arr; Array.iter (Printf.printf "%d ") arr Output: 1 2 3 4 7 Step-by-step Explanation Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap. Swap the root node with the last element in the array. Decrease the heap size by 1. Call heapify on the root node to restore the heap property. Repeat steps 2-3 until the heap size is 1. The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap. Complexity Analysis The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n). Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.]]></summary></entry><entry><title type="html">Quicksort</title><link href="/algorithm/2023/11/20/quicksort.html" rel="alternate" type="text/html" title="Quicksort" /><published>2023-11-20T20:46:37+02:00</published><updated>2023-11-20T20:46:37+02:00</updated><id>/algorithm/2023/11/20/quicksort</id><content type="html" xml:base="/algorithm/2023/11/20/quicksort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Quicksort was developed by British computer scientist Tony Hoare in 1959. It is one of the most widely used sorting algorithms and is commonly used in computer science and engineering applications.</p>

<p>Quicksort is particularly useful when sorting large datasets because it has an average time complexity of O(n log n), which is faster than many other sorting algorithms. It is also an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input array.</p>

<p>Quicksort is used in a variety of applications, including sorting large databases, sorting elements in computer graphics and image processing, and in network routing algorithms. It is also used in many programming languages as a built-in sorting function, such as Python’s <code class="language-plaintext highlighter-rouge">sorted()</code> function and C++’s <code class="language-plaintext highlighter-rouge">std::sort()</code> function.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec quicksort = function  
  | [] -&gt; []  
  | pivot::tail -&gt;  
    let lesser, greater = List.partition (fun x -&gt; x &lt; pivot) tail in  
    quicksort lesser @ [pivot] @ quicksort greater  
</code></pre></div></div>

<p>This implementation uses a functional programming style and takes advantage of pattern matching to handle the two cases of the input list: the empty list, which is already sorted, and a non-empty list, which is partitioned into two sub-lists based on a pivot element (in this case, the first element of the list).</p>

<p>The <code class="language-plaintext highlighter-rouge">List.partition</code> function is used to split the tail of the input list into two sub-lists: <code class="language-plaintext highlighter-rouge">lesser</code>, which contains all elements that are strictly less than the pivot, and <code class="language-plaintext highlighter-rouge">greater</code>, which contains all elements that are greater than or equal to the pivot. The <code class="language-plaintext highlighter-rouge">@</code> operator is used to concatenate the sorted <code class="language-plaintext highlighter-rouge">lesser</code> sub-list, the pivot element, and the sorted <code class="language-plaintext highlighter-rouge">greater</code> sub-list into a single sorted list.</p>

<p>Here’s an example usage of the <code class="language-plaintext highlighter-rouge">quicksort</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let unsorted = [5; 1; 3; 9; 2]  
let sorted = quicksort unsorted  
</code></pre></div></div>

<p>After running this code, the <code class="language-plaintext highlighter-rouge">sorted</code> variable should contain the list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>, which is the sorted version of the <code class="language-plaintext highlighter-rouge">unsorted</code> list.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<p>Here’s a step-by-step explanation of how the quicksort algorithm works:</p>

<ol>
  <li>
    <p>Choose a pivot element from the list. This can be any element, but a common choice is the first or last element in the list.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists, with one sub-list containing elements less than the pivot and the other sub-list containing elements greater than or equal to the pivot. This can be done by iterating through the list and swapping elements as necessary to ensure that all elements less than the pivot are on one side of the pivot and all elements greater than or equal to the pivot are on the other side.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists until the entire list is sorted. This can be done by calling the quicksort function on each sub-list.</p>
  </li>
</ol>

<p>Here’s an example of how this algorithm would sort the list <code class="language-plaintext highlighter-rouge">[5; 1; 3; 9; 2]</code>:</p>

<ol>
  <li>
    <p>Choose the first element, <code class="language-plaintext highlighter-rouge">5</code>, as the pivot.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists: <code class="language-plaintext highlighter-rouge">[1; 3; 2]</code> and <code class="language-plaintext highlighter-rouge">[9]</code>. All elements less than <code class="language-plaintext highlighter-rouge">5</code> are on the left and all elements greater than or equal to <code class="language-plaintext highlighter-rouge">5</code> are on the right.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to each sub-list. For the left sub-list, choose <code class="language-plaintext highlighter-rouge">1</code> as the pivot and partition it into <code class="language-plaintext highlighter-rouge">[ ]</code>, <code class="language-plaintext highlighter-rouge">[1]</code>, and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. For the right sub-list, it is already sorted.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists <code class="language-plaintext highlighter-rouge">[1]</code> and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. Both sub-lists are already sorted, so no further partitioning is necessary.</p>
  </li>
  <li>
    <p>Concatenate the sorted sub-lists in the order <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2; 3]</code>, <code class="language-plaintext highlighter-rouge">[5]</code>, and <code class="language-plaintext highlighter-rouge">[9]</code> to obtain the sorted list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>.</p>
  </li>
</ol>

<p>This example shows how the quicksort algorithm works by recursively dividing the input list into smaller sub-lists, sorting them, and then combining them to obtain the final sorted list.</p>

<h2 id="complexity">Complexity</h2>

<p>The time complexity of quicksort is O(n log n) on average, where n is the number of elements in the input list.</p>

<p>The average case occurs when the pivot element is chosen randomly and is close to the median value of the list. In this case, the list is divided roughly in half with each partition, and the algorithm will make log n recursive calls to sort the entire list. The partitioning step takes linear time, so the total time complexity is O(n log n).</p>

<p>However, in the worst case, quicksort can have a time complexity of O(n^2) if the pivot element is consistently chosen poorly. For example, if the pivot is always chosen as the smallest or largest element in the list, then each partition will only remove one element from the list, and the algorithm will make n recursive calls to sort the entire list. This worst-case scenario is rare in practice, but it can occur in certain edge cases.</p>

<p>In terms of space complexity, quicksort is an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input list. However, the recursive nature of the algorithm means that it has a space complexity of O(log n) due to the call stack used for the recursive calls.</p>

<p>Overall, quicksort is a highly efficient sorting algorithm with a time complexity of O(n log n) on average, making it a popular choice for sorting large datasets.</p>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>