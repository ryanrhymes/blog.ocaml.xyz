<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-27T21:53:58+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Gauss-Legendre Algorithm</title><link href="/algorithm/2023/11/21/gaussian-legendre.html" rel="alternate" type="text/html" title="Gauss-Legendre Algorithm" /><published>2023-11-21T12:00:00+02:00</published><updated>2023-11-21T12:00:00+02:00</updated><id>/algorithm/2023/11/21/gaussian-legendre</id><content type="html" xml:base="/algorithm/2023/11/21/gaussian-legendre.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Gauss-Legendre algorithm is an iterative numerical integration technique used for approximating definite integrals. The algorithm is based on the idea of interpolating a function over a given interval using Legendre polynomials. The resulting approximation is then used to compute the integral of the function over the same interval. The Gauss-Legendre algorithm is widely used in numerical analysis and scientific computing.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">gauss_legendre</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">3e-11</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create_float</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create_float</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">xm</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">+.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">xl</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">m</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">i'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">i</span> <span class="k">in</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="n">cos</span> <span class="p">(</span><span class="nn">Owl_const</span><span class="p">.</span><span class="n">pi</span> <span class="o">*.</span> <span class="p">(</span><span class="n">i'</span> <span class="o">-.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">25</span><span class="p">)</span> <span class="o">/.</span> <span class="p">(</span><span class="n">n'</span> <span class="o">+.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">));</span>
    <span class="p">(</span><span class="k">try</span>
       <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="n">p1</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.;</span>
         <span class="n">p2</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">.;</span>
         <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
           <span class="n">p3</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p2</span><span class="p">;</span>
           <span class="n">p2</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p1</span><span class="p">;</span>
           <span class="k">let</span> <span class="n">j'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">j</span> <span class="k">in</span>
           <span class="n">p1</span> <span class="o">:=</span> <span class="p">((((</span><span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">j'</span><span class="p">)</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p2</span><span class="p">)</span> <span class="o">-.</span> <span class="p">((</span><span class="n">j'</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p3</span><span class="p">))</span> <span class="o">/.</span> <span class="n">j'</span>
         <span class="k">done</span><span class="p">;</span>
         <span class="n">pp</span> <span class="o">:=</span> <span class="n">n'</span> <span class="o">*.</span> <span class="p">((</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p1</span><span class="p">)</span> <span class="o">-.</span> <span class="o">!</span><span class="n">p2</span><span class="p">)</span> <span class="o">/.</span> <span class="p">((</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">)</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span>
         <span class="k">let</span> <span class="n">z1</span> <span class="o">=</span> <span class="o">!</span><span class="n">z</span> <span class="k">in</span>
         <span class="n">z</span> <span class="o">:=</span> <span class="n">z1</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">p1</span> <span class="o">/.</span> <span class="o">!</span><span class="n">pp</span><span class="p">);</span>
         <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">z</span> <span class="o">-.</span> <span class="n">z1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>
       <span class="k">done</span>
     <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xm</span> <span class="o">-.</span> <span class="p">(</span><span class="n">xl</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xm</span> <span class="o">+.</span> <span class="p">(</span><span class="n">xl</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">);</span>
    <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">xl</span> <span class="o">/.</span> <span class="p">((</span><span class="mi">1</span><span class="o">.</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">))</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pp</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pp</span><span class="p">);</span>
    <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span><span class="o">,</span> <span class="n">w</span>


<span class="k">let</span> <span class="n">gauss_legendre_cache</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="mi">50</span> <span class="n">gauss_legendre</span>

<span class="k">let</span> <span class="n">_gauss_laguerre</span> <span class="o">?</span><span class="p">(</span><span class="n">_eps</span> <span class="o">=</span> <span class="mf">3e-11</span><span class="p">)</span> <span class="n">_a</span> <span class="n">_b</span> <span class="n">_n</span> <span class="o">=</span> <span class="bp">()</span>

<span class="k">let</span> <span class="n">gaussian_fixed</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">gauss_legendre_cache</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">true</span>  <span class="o">-&gt;</span> <span class="n">gauss_legendre_cache</span><span class="o">.</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">gauss_legendre</span> <span class="n">n</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">xr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span> <span class="o">*.</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+.</span> <span class="mi">1</span><span class="o">.</span><span class="p">))</span> <span class="o">+.</span> <span class="n">a</span> <span class="k">in</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s</span> <span class="o">+.</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*.</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">s</span> <span class="o">*.</span> <span class="n">xr</span>


<span class="k">let</span> <span class="n">gaussian</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="p">(</span><span class="k">try</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
       <span class="n">s_new</span> <span class="o">:=</span> <span class="n">gaussian_fixed</span> <span class="o">~</span><span class="n">n</span><span class="o">:</span><span class="n">i</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">;</span>
       <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">s_new</span> <span class="o">-.</span> <span class="o">!</span><span class="n">s_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">);</span>
       <span class="n">s_old</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_new</span>
     <span class="k">done</span>
   <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
  <span class="o">!</span><span class="n">s_new</span>
</code></pre></div></div>

<p>The Gauss-Legendre algorithm is implemented in OCaml as a function <code class="language-plaintext highlighter-rouge">gaussian</code> which takes in the following arguments:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">n</code>: the number of iterations to perform (default 50)</li>
  <li><code class="language-plaintext highlighter-rouge">eps</code>: the desired accuracy of the approximation (default 1e-6)</li>
  <li><code class="language-plaintext highlighter-rouge">f</code>: the function to integrate</li>
  <li><code class="language-plaintext highlighter-rouge">a</code>: the lower bound of the integration interval</li>
  <li><code class="language-plaintext highlighter-rouge">b</code>: the upper bound of the integration interval</li>
</ul>

<p>The implementation is split into two functions: <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> and <code class="language-plaintext highlighter-rouge">gaussian</code>. The former performs a single iteration of the algorithm, while the latter performs a specified number of iterations until the desired accuracy is achieved. The <code class="language-plaintext highlighter-rouge">gaussian</code> function first checks if the desired number of iterations is available in a precomputed cache, otherwise it computes them using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The Gauss-Legendre algorithm works by approximating the integral of a function <code class="language-plaintext highlighter-rouge">f</code> over an interval <code class="language-plaintext highlighter-rouge">[a,b]</code> using Legendre polynomials. The algorithm proceeds as follows:</p>
<ol>
  <li>Compute the Legendre-Gauss nodes and weights for the given interval <code class="language-plaintext highlighter-rouge">[a,b]</code> and number of nodes <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li>Transform the integral over <code class="language-plaintext highlighter-rouge">[a,b]</code> into an integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the change of variables <code class="language-plaintext highlighter-rouge">x = ((b-a)t + b + a)/2</code>.</li>
  <li>Approximate the integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the Legendre-Gauss nodes and weights.</li>
  <li>Transform the approximation back to the integral over <code class="language-plaintext highlighter-rouge">[a,b]</code> using the same change of variables as in step 2.</li>
</ol>

<p>The Legendre-Gauss nodes and weights are computed using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function. This function uses the iterative method described by the algorithm to approximate the roots of the Legendre polynomial of degree <code class="language-plaintext highlighter-rouge">n</code>. The roots are then used as the nodes for the Gauss-Legendre quadrature, and the corresponding weights are computed using the formula <code class="language-plaintext highlighter-rouge">w_i = 2 / [(1 - z_i^2) * (P_n'(z_i))^2]</code>, where <code class="language-plaintext highlighter-rouge">P_n</code> is the Legendre polynomial of degree <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">z_i</code> is the <code class="language-plaintext highlighter-rouge">i</code>-th root.</p>

<p>The <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> function approximates the integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the Legendre-Gauss nodes and weights. It first computes the midpoint <code class="language-plaintext highlighter-rouge">xr</code> of the interval <code class="language-plaintext highlighter-rouge">[-1,1]</code> and then evaluates the function <code class="language-plaintext highlighter-rouge">f</code> at each of the nodes <code class="language-plaintext highlighter-rouge">x_i</code> transformed to the interval <code class="language-plaintext highlighter-rouge">[a,b]</code> using the change of variables described above. The approximation is then computed as the sum of the products of the weights <code class="language-plaintext highlighter-rouge">w_i</code> and the function values <code class="language-plaintext highlighter-rouge">f(x_i)</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">gaussian</code> function iteratively calls <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> with increasing numbers of nodes until the desired accuracy is achieved. It uses the precomputed cache of Legendre-Gauss nodes and weights if available, otherwise it computes them using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Gauss-Legendre algorithm is dominated by the number of iterations <code class="language-plaintext highlighter-rouge">n</code> performed by the <code class="language-plaintext highlighter-rouge">gaussian</code> function. Each iteration of <code class="language-plaintext highlighter-rouge">gaussian</code> requires evaluating the function <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points and computing the Legendre-Gauss nodes and weights. The latter is precomputed and cached for up to 50 nodes, and computed on-the-fly using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function for larger values of <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>The time complexity of computing the Legendre-Gauss nodes and weights using <code class="language-plaintext highlighter-rouge">gauss_legendre</code> is <code class="language-plaintext highlighter-rouge">O(n^2)</code>, due to the nested loop over <code class="language-plaintext highlighter-rouge">j</code> and <code class="language-plaintext highlighter-rouge">i</code>. However, this function is only called once for each unique <code class="language-plaintext highlighter-rouge">n</code>, so its time complexity is not a bottleneck for the overall algorithm.</p>

<p>The time complexity of evaluating the function <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points is dependent on the implementation of <code class="language-plaintext highlighter-rouge">f</code>. Assuming that <code class="language-plaintext highlighter-rouge">f</code> has a time complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> for each evaluation, the time complexity of evaluating <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points is <code class="language-plaintext highlighter-rouge">O(n)</code>.</p>

<p>Therefore, the overall time complexity of the Gauss-Legendre algorithm is <code class="language-plaintext highlighter-rouge">O(n^3)</code> for large values of <code class="language-plaintext highlighter-rouge">n</code>. The space complexity is <code class="language-plaintext highlighter-rouge">O(n)</code> for storing the Legendre-Gauss nodes and weights.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Gauss-Legendre algorithm is an iterative numerical integration technique used for approximating definite integrals. The algorithm is based on the idea of interpolating a function over a given interval using Legendre polynomials. The resulting approximation is then used to compute the integral of the function over the same interval. The Gauss-Legendre algorithm is widely used in numerical analysis and scientific computing. Implementation]]></summary></entry><entry><title type="html">Extended Trapezoidal Rule</title><link href="/algorithm/2023/11/21/trapzd.html" rel="alternate" type="text/html" title="Extended Trapezoidal Rule" /><published>2023-11-21T06:00:00+02:00</published><updated>2023-11-21T06:00:00+02:00</updated><id>/algorithm/2023/11/21/trapzd</id><content type="html" xml:base="/algorithm/2023/11/21/trapzd.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The trapezoidal rule is a numerical integration technique used to approximate the definite integral of a function. It approximates the area under a curve by dividing the area into a series of trapezoids. The trapezoidal rule is widely used in engineering, physics, and other fields that require numerical integration.</p>

<h2 id="implementation">Implementation</h2>
<p>The OCaml code below implements the trapezoidal rule algorithm. The function <code class="language-plaintext highlighter-rouge">trapzd</code> takes four arguments: <code class="language-plaintext highlighter-rouge">f</code> is the function to be integrated, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are the lower and upper bounds of the integral, and <code class="language-plaintext highlighter-rouge">n</code> is the number of trapezoids to be used in the approximation.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">trapzd</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"trapzd requires n &gt; 0 and a &lt;= b whereas n = %i, a = %g, b = %g"</span>
        <span class="n">n</span>
        <span class="n">a</span>
        <span class="n">b</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">then</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="o">*.</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">+.</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span> <span class="o">**</span> <span class="n">float_of_int</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="o">/.</span> <span class="n">m</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">a</span> <span class="o">+.</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="n">d</span><span class="p">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">int_of_float</span> <span class="n">m</span> <span class="k">do</span>
      <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+.</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">s</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s</span> <span class="o">+.</span> <span class="n">f</span> <span class="o">!</span><span class="n">x</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="n">d</span> <span class="o">*.</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">+.</span> <span class="n">f</span> <span class="n">b</span><span class="p">))</span> <span class="o">+.</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">*.</span> <span class="n">d</span><span class="p">))</span>
</code></pre></div></div>

<p>The function first checks that <code class="language-plaintext highlighter-rouge">n</code> is greater than zero and that <code class="language-plaintext highlighter-rouge">a</code> is less than or equal to <code class="language-plaintext highlighter-rouge">b</code>. If either of these conditions is not met, an exception is raised.</p>

<p>If <code class="language-plaintext highlighter-rouge">n</code> is equal to 1, the function returns the area of a single trapezoid. Otherwise, the function computes the width of each trapezoid <code class="language-plaintext highlighter-rouge">d</code> and the midpoint of the first trapezoid <code class="language-plaintext highlighter-rouge">x</code>. It then iterates over the remaining trapezoids, computing the area of each and summing them together.</p>

<p>The final result is the sum of the areas of all the trapezoids.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Verify that <code class="language-plaintext highlighter-rouge">n</code> is greater than zero and that <code class="language-plaintext highlighter-rouge">a</code> is less than or equal to <code class="language-plaintext highlighter-rouge">b</code>. If either of these conditions is not met, raise an exception.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is equal to 1, return the area of a single trapezoid: <code class="language-plaintext highlighter-rouge">0.5 *. (b -. a) *. (f a +. f b)</code></li>
  <li>Compute the width of each trapezoid: <code class="language-plaintext highlighter-rouge">d = (b -. a) /. m</code>, where <code class="language-plaintext highlighter-rouge">m = 2. ** float_of_int (n - 1)</code></li>
  <li>Compute the midpoint of the first trapezoid: <code class="language-plaintext highlighter-rouge">x = ref (a +. (0.5 *. d))</code></li>
  <li>Initialize the sum of the areas of all the trapezoids to 0: <code class="language-plaintext highlighter-rouge">s = ref 0.</code></li>
  <li>Iterate over the remaining trapezoids, computing the area of each and summing them together:
    <ol>
      <li>Increment the midpoint by the width of the trapezoid: <code class="language-plaintext highlighter-rouge">x := !x +. d</code></li>
      <li>Compute the area of the trapezoid and add it to the sum: <code class="language-plaintext highlighter-rouge">s := !s +. f !x</code></li>
    </ol>
  </li>
  <li>Compute the final result: <code class="language-plaintext highlighter-rouge">(0.5 *. d *. (f a +. f b)) +. (!s *. d)</code></li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The trapezoidal rule algorithm has a time complexity of O(n), where n is the number of trapezoids used in the approximation. This is because the algorithm iterates over each trapezoid once, computing its area and summing them together.</p>

<p>The space complexity of the algorithm is O(1), because it only uses a constant amount of memory to store the variables <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">s</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The trapezoidal rule is a numerical integration technique used to approximate the definite integral of a function. It approximates the area under a curve by dividing the area into a series of trapezoids. The trapezoidal rule is widely used in engineering, physics, and other fields that require numerical integration. Implementation The OCaml code below implements the trapezoidal rule algorithm. The function trapzd takes four arguments: f is the function to be integrated, a and b are the lower and upper bounds of the integral, and n is the number of trapezoids to be used in the approximation.]]></summary></entry><entry><title type="html">Polynomial Interpolation</title><link href="/algorithm/2023/11/21/polynomial-interpolation.html" rel="alternate" type="text/html" title="Polynomial Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/polynomial-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/polynomial-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), â€¦, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing.</p>

<h2 id="implementation">Implementation</h2>

<p>The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function <code class="language-plaintext highlighter-rouge">polint</code> takes three arguments - <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. The arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> represent the x-coordinates and y-coordinates of the n points, respectively. The variable <code class="language-plaintext highlighter-rouge">x</code> represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at <code class="language-plaintext highlighter-rouge">x</code> and the error estimate.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">polint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"polint requires that xs and ys have the same length, but xs length is %i \
         whereas ys length is %i"</span>
        <span class="n">n</span>
        <span class="n">m</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dif</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">dift</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">dift</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">dif</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">dif</span> <span class="o">:=</span> <span class="n">dift</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">ho</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">hp</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">ho</span> <span class="o">-.</span> <span class="n">hp</span> <span class="k">in</span>
      <span class="k">assert</span> <span class="p">(</span><span class="n">den</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">den</span> <span class="k">in</span>
      <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ho</span> <span class="o">*.</span> <span class="n">den</span><span class="p">;</span>
      <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">hp</span> <span class="o">*.</span> <span class="n">den</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">then</span> <span class="n">dy</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">(</span>
      <span class="n">dy</span> <span class="o">:=</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="o">!</span><span class="n">y</span> <span class="o">+.</span> <span class="o">!</span><span class="n">dy</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>
    <p>The function first checks if the lengths of the arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are the same. If they are not, an exception is raised.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created, which are initialized to the values in the array <code class="language-plaintext highlighter-rouge">ys</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is initialized to 0, which will be used to keep track of the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">dif</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first point in the array <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>A loop is executed over all the points in the array <code class="language-plaintext highlighter-rouge">xs</code>. For each point, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the point is computed. If this difference is less than the current value of <code class="language-plaintext highlighter-rouge">dif</code>, then the index of the point is stored in the variable <code class="language-plaintext highlighter-rouge">ns</code>, and the value of <code class="language-plaintext highlighter-rouge">dif</code> is updated to the new difference.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is initialized to the y-coordinate of the point in the array <code class="language-plaintext highlighter-rouge">ys</code> that is closest to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>A loop is executed n-1 times. In each iteration, two nested loops are executed over the remaining points in the array <code class="language-plaintext highlighter-rouge">xs</code>. The variable <code class="language-plaintext highlighter-rouge">m</code> is used to keep track of the number of iterations.</p>
  </li>
  <li>
    <p>In the inner loop, the variable <code class="language-plaintext highlighter-rouge">ho</code> is initialized to the difference between the current point and <code class="language-plaintext highlighter-rouge">x</code>, and the variable <code class="language-plaintext highlighter-rouge">hp</code> is initialized to the difference between the point m positions ahead and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">w</code> is initialized to the difference between the y-coordinates of the point m positions ahead and the current point.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is initialized to the difference between <code class="language-plaintext highlighter-rouge">ho</code> and <code class="language-plaintext highlighter-rouge">hp</code>. If <code class="language-plaintext highlighter-rouge">den</code> is 0, an exception is raised.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is updated to <code class="language-plaintext highlighter-rouge">w/den</code>.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">c</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">ho*den</code>, and the value of <code class="language-plaintext highlighter-rouge">d</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">hp*den</code>.</p>
  </li>
  <li>
    <p>If the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">n-m-1</code> multiplied by 2, then the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">c[ns+1]</code>. Otherwise, the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">d[ns]</code>, and the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is decremented by 1.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is updated to <code class="language-plaintext highlighter-rouge">y+dy</code>.</p>
  </li>
  <li>
    <p>The function returns the tuple <code class="language-plaintext highlighter-rouge">(y, dy)</code>.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The polynomial interpolation algorithm has a time complexity of O(n^2), where n is the number of points. This is because the algorithm involves a nested loop over all the points in the input arrays. In the outer loop, the algorithm iterates n-1 times, and in the inner loop, it iterates over the remaining n-m-1 points. Therefore, the total number of iterations is given by the sum of the first n-1 positive integers, which is n(n-1)/2. Thus, the time complexity of the algorithm is O(n^2).</p>

<p>In terms of space complexity, the algorithm uses two arrays of size n to store the y-coordinates and two additional variables to store the interpolated value and the error estimate. Therefore, the space complexity of the algorithm is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), â€¦, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing. Implementation The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function polint takes three arguments - xs, ys, and x. The arrays xs and ys represent the x-coordinates and y-coordinates of the n points, respectively. The variable x represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at x and the error estimate.]]></summary></entry><entry><title type="html">Rational Interpolation</title><link href="/algorithm/2023/11/21/rational-interpolation.html" rel="alternate" type="text/html" title="Rational Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/rational-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/rational-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.</p>

<h2 id="implementation">Implementation</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm is implemented in OCaml as shown below. The function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. <code class="language-plaintext highlighter-rouge">xs</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the x-coordinates of the function, <code class="language-plaintext highlighter-rouge">ys</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the y-coordinates of the function, and <code class="language-plaintext highlighter-rouge">x</code> is the point at which the function is to be approximated. The function returns a tuple containing the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ratint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"ratint requires that xs and ys have the same length, but xs length is %i \
         whereas ys length is %i"</span>
        <span class="n">n</span>
        <span class="n">m</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">hh</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-25</span> <span class="k">in</span>
  <span class="k">try</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">dy</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">.;</span>
        <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span><span class="p">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">hh</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">hh</span> <span class="o">:=</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+.</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
    <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span><span class="p">)</span> <span class="o">*.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/.</span> <span class="n">h</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-.</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"Has a pole"</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">dd</span> <span class="k">in</span>
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*.</span> <span class="n">dd</span><span class="p">;</span>
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">t</span> <span class="o">*.</span> <span class="n">dd</span>
      <span class="k">done</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
  <span class="k">with</span>
  <span class="o">|</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
  <span class="o">|</span> <span class="n">e</span>                   <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">e</span>
</code></pre></div></div>

<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">ratint</code> function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are obtained and verified to be equal. If they are not equal, an error is thrown.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created as copies of the <code class="language-plaintext highlighter-rouge">ys</code> array.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">hh</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first element of <code class="language-plaintext highlighter-rouge">xs</code>. This will be used to keep track of the smallest distance between <code class="language-plaintext highlighter-rouge">x</code> and an element of <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>Three variables <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">dy</code>, and <code class="language-plaintext highlighter-rouge">ns</code> are initialized to 0. <code class="language-plaintext highlighter-rouge">y</code> will be used to store the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">dy</code> will be used to store the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">ns</code> will be used to keep track of the index of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">eps</code> is initialized to a small number. This will be used to prevent division by zero.</p>
  </li>
  <li>
    <p>A for loop is used to iterate over the <code class="language-plaintext highlighter-rouge">xs</code> array.</p>
  </li>
  <li>
    <p>For each <code class="language-plaintext highlighter-rouge">xs[i]</code>, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xs[i]</code> is computed and stored in a variable <code class="language-plaintext highlighter-rouge">h</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is equal to 0, then <code class="language-plaintext highlighter-rouge">ys[i]</code> is the exact value of the function at <code class="language-plaintext highlighter-rouge">x</code>, so <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[i]</code>, <code class="language-plaintext highlighter-rouge">dy</code> is set to 0, and an exception is raised to exit the loop.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is less than <code class="language-plaintext highlighter-rouge">hh</code>, then <code class="language-plaintext highlighter-rouge">ns</code> is set to <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">hh</code> is set to <code class="language-plaintext highlighter-rouge">h</code>, and the <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i]</code> arrays are updated to <code class="language-plaintext highlighter-rouge">ys[i]</code>. This keeps track of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>After the loop, <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[ns]</code>, and <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>Two nested for loops are used to iterate over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays.</p>
  </li>
  <li>
    <p>For each iteration, <code class="language-plaintext highlighter-rouge">m</code> represents the current iteration of the outer loop, and <code class="language-plaintext highlighter-rouge">i</code> represents the current iteration of the inner loop.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">w</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i-1]</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">h</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">xs[i+m-1]</code> and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">t</code> is computed as <code class="language-plaintext highlighter-rouge">(xs[i-1] - x) * d[i-1] / h</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">t - c[i]</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">dd</code> is equal to 0, then the function has a pole, and an exception is thrown.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">w / dd</code>.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">d[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">c[i] * dd</code>, and the <code class="language-plaintext highlighter-rouge">c[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">t * dd</code>.</p>
  </li>
  <li>
    <p>After the loops, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">dy</code> are returned as the approximation and derivative of the function at <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>If any exceptions are raised during the computation, they are rethrown.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm has a time complexity of O(n^2), where n is the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code>.</p>

<p>This is because the algorithm has two nested loops, each iterating over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays. The outer loop iterates <code class="language-plaintext highlighter-rouge">n-1</code> times, and the inner loop iterates <code class="language-plaintext highlighter-rouge">n-m</code> times, where <code class="language-plaintext highlighter-rouge">m</code> is the current iteration of the outer loop. This gives a total of <code class="language-plaintext highlighter-rouge">(n-1) + (n-2) + ... + 1</code> iterations for the outer loop, which is equal to <code class="language-plaintext highlighter-rouge">n(n-1)/2</code>. The inner loop has a similar number of iterations, giving a total of <code class="language-plaintext highlighter-rouge">n(n-1)^2/2</code> iterations for both loops combined.</p>

<p>Therefore, the time complexity of the algorithm is O(n^2). This means that as the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> increases, the time taken by the algorithm to compute the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and its derivative also increases quadratically.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.]]></summary></entry><entry><title type="html">Bisection Algorithm</title><link href="/algorithm/2023/11/21/bisec-algorithm.html" rel="alternate" type="text/html" title="Bisection Algorithm" /><published>2023-11-21T04:00:00+02:00</published><updated>2023-11-21T04:00:00+02:00</updated><id>/algorithm/2023/11/21/bisec-algorithm</id><content type="html" xml:base="/algorithm/2023/11/21/bisec-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval.</p>

<h2 id="implementation">Implementation</h2>

<p>The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bisec</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">d</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">true</span>  <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">a</span><span class="o">,</span> <span class="n">ref</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span>
      <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="p">(</span><span class="n">a</span> <span class="o">-.</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span> <span class="o">*.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+.</span> <span class="o">!</span><span class="n">d</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">f</span> <span class="n">c</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="o">!</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">xtol</span> <span class="o">&amp;&amp;</span> <span class="n">fc</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">x</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>
    <p>The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points.</p>
  </li>
  <li>
    <p>The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error.</p>
  </li>
  <li>
    <p>If f(a) is 0, the function returns a, since a is already a root.</p>
  </li>
  <li>
    <p>If f(b) is 0, the function returns b, since b is already a root.</p>
  </li>
  <li>
    <p>The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b.</p>
  </li>
  <li>
    <p>The function enters a loop that runs for a maximum of max_iter iterations.</p>
  </li>
  <li>
    <p>In each iteration, the function bisects the interval by setting d to d/2.</p>
  </li>
  <li>
    <p>The function computes the midpoint c of the interval by adding d to x.</p>
  </li>
  <li>
    <p>The function evaluates the function at c.</p>
  </li>
  <li>
    <p>If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval.</p>
  </li>
  <li>
    <p>The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop.</p>
  </li>
  <li>
    <p>If the loop completes without finding a root, the function returns the last value of x.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits.</p>

<p>The algorithmâ€™s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy.</p>

<p>The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm.</p>

<p>Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The bisection algorithm is a root-finding algorithm that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing. It is a simple and robust method that is guaranteed to converge to a root if the function is continuous and changes sign exactly once over the interval. Implementation The implementation below is in OCaml. It takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The algorithm then bisects the interval and checks the sign of the function at the midpoint. If the sign is negative, the root must be in the left subinterval, and if the sign is positive, the root must be in the right subinterval. The algorithm repeats this process until it converges to a root. let bisec ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf "f(a) *. f(b) = %g *. %g should be negative." fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let x, d = match fa &lt; 0. with | true -&gt; ref a, ref (b -. a) | false -&gt; ref b, ref (a -. b) in try for _i = 1 to max_iter do d := !d *. 0.5; let c = !x +. !d in let fc = f c in if fc &lt;= 0. then x := c; assert (abs_float !d &gt;= xtol &amp;&amp; fc != 0.) done; !x with | _ -&gt; !x) Step-by-step Explanation The function takes a function f, and two points a and b, such that f(a) and f(b) have opposite signs, indicating that there is a root in between the two points. The function checks that f(a) and f(b) have opposite signs. If they do not, the function raises an error. If f(a) is 0, the function returns a, since a is already a root. If f(b) is 0, the function returns b, since b is already a root. The function initializes x to a or b, depending on whether f(a) is negative or positive, and initializes d to the distance between a and b. The function enters a loop that runs for a maximum of max_iter iterations. In each iteration, the function bisects the interval by setting d to d/2. The function computes the midpoint c of the interval by adding d to x. The function evaluates the function at c. If the sign of the function at c is negative, the function sets x to c, indicating that the root must be in the left subinterval. The function checks that the distance between the endpoints of the interval is greater than xtol, and that the function value at c is not 0. If either of these conditions is false, the function exits the loop. If the loop completes without finding a root, the function returns the last value of x. Complexity Analysis The bisection algorithm has a guaranteed convergence rate of O(log2((b-a)/xtol)), where a and b are the endpoints of the interval and xtol is the desired tolerance. This means that the number of iterations required to find a root decreases by a factor of 2 with each doubling of the number of correct digits. The algorithmâ€™s time complexity is O(max_iter), where max_iter is the maximum number of iterations allowed. In practice, the algorithm usually converges much faster than this worst-case bound, and the number of iterations required depends on the function being evaluated and the desired accuracy. The space complexity of the algorithm is O(1), as it only requires a constant amount of memory to store the variables used in the algorithm. Overall, the bisection algorithm is a simple and robust method for finding roots of continuous functions that is guaranteed to converge to a root if the function changes sign exactly once over the interval. Its time complexity depends on the maximum number of iterations allowed and the convergence rate, while its space complexity is constant.]]></summary></entry><entry><title type="html">Topological Sort</title><link href="/algorithm/2023/11/21/topological-sort.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2023-11-21T04:00:00+02:00</published><updated>2023-11-21T04:00:00+02:00</updated><id>/algorithm/2023/11/21/topological-sort</id><content type="html" xml:base="/algorithm/2023/11/21/topological-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of topological sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">topological_sort</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="kt">array</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">graph</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">false</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>  
  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">dfs</span> <span class="p">(</span><span class="n">u</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>  
    <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="bp">true</span><span class="p">;</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">v</span><span class="p">)</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>  
    <span class="n">stack</span> <span class="o">:=</span> <span class="n">u</span> <span class="o">::</span> <span class="o">!</span><span class="n">stack</span>  
  <span class="k">in</span>  
  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  
  <span class="o">!</span><span class="n">stack</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">graph</code> is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order.  Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">courses</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"C1"</span><span class="p">;</span> <span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">;</span> <span class="s2">"C4"</span><span class="p">;</span> <span class="s2">"C5"</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">prerequisites</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"C1"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C2"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C3"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C4"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C5"</span><span class="p">])]</span>  
  
<span class="k">let</span> <span class="n">course_graph</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">courses</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">[]</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">find_index</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="n">courses</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">index</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Course not found"</span>
  <span class="k">in</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">c</span><span class="o">,</span> <span class="n">prereqs</span><span class="p">)</span> <span class="o">-&gt;</span>  
    <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">vs</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">index_of_course</span> <span class="n">prereqs</span> <span class="k">in</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v</span> <span class="o">::</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="n">vs</span>  
  <span class="p">)</span> <span class="n">prerequisites</span><span class="p">;</span>  
  <span class="n">graph</span>  
  
<span class="k">let</span> <span class="n">course_order</span> <span class="o">=</span> <span class="n">topological_sort</span> <span class="n">course_graph</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">courses</span> <span class="n">i</span><span class="p">)</span>

<span class="k">let</span> <span class="n">print_course_order</span> <span class="n">course_order</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">course</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%s "</span> <span class="n">course</span><span class="p">)</span> <span class="n">course_order</span><span class="p">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">print_course_order</span> <span class="n">course_order</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an array <code class="language-plaintext highlighter-rouge">visited</code> of size <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the number of nodes in the graph. Initialize all elements to <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>Create an empty stack <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Define a recursive function <code class="language-plaintext highlighter-rouge">dfs</code> that takes a node <code class="language-plaintext highlighter-rouge">u</code> as input.</li>
  <li>Mark <code class="language-plaintext highlighter-rouge">u</code> as visited by setting <code class="language-plaintext highlighter-rouge">visited.(u)</code> to <code class="language-plaintext highlighter-rouge">true</code>.</li>
  <li>For each neighbor <code class="language-plaintext highlighter-rouge">v</code> of <code class="language-plaintext highlighter-rouge">u</code> in the graph, if <code class="language-plaintext highlighter-rouge">v</code> has not been visited, recursively call <code class="language-plaintext highlighter-rouge">dfs v</code>.</li>
  <li>Push <code class="language-plaintext highlighter-rouge">u</code> onto the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Loop through all nodes in the graph. If a node has not been visited, call <code class="language-plaintext highlighter-rouge">dfs</code> on it.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
</ol>

<p>The algorithm works by performing a depth-first search (DFS) on the graph. When a node is finished being explored, it is pushed onto the stack. Since a DAG has no cycles, the nodes can be ordered in reverse order of their finishing times, which gives a valid topological order.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of topological sort is O(V+E), where V is the number of vertices and E is the number of edges in the graph. This is because each vertex and edge is visited once during the DFS traversal. The space complexity is also O(V+E), since the adjacency list takes up O(V+E) space and the stack can contain all vertices in the worst case.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing. Implementation Here is an implementation of topological sort in OCaml: let topological_sort (graph: int list array) : int list = let n = Array.length graph in let visited = Array.make n false in let stack = ref [] in let rec dfs (u: int) : unit = visited.(u) &lt;- true; List.iter (fun v -&gt; if not visited.(v) then dfs v) graph.(u); stack := u :: !stack in for i = 0 to n - 1 do if not visited.(i) then dfs i done; !stack Here, graph is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order. Here is an example.]]></summary></entry><entry><title type="html">Brentâ€™s Algorithm</title><link href="/algorithm/2023/11/21/brents-algorithm.html" rel="alternate" type="text/html" title="Brentâ€™s Algorithm" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/brents-algorithm</id><content type="html" xml:base="/algorithm/2023/11/21/brents-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Brentâ€™s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Brentâ€™s algorithm in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">power</span> <span class="n">lam</span> <span class="n">tortoise</span> <span class="n">hare</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">hare</span> <span class="k">then</span> <span class="n">lam</span>  
    <span class="k">else</span> <span class="k">if</span> <span class="n">power</span> <span class="o">=</span> <span class="n">lam</span> <span class="k">then</span> <span class="n">loop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="mi">0</span> <span class="n">hare</span> <span class="n">hare</span>  
    <span class="k">else</span> <span class="n">loop</span> <span class="n">power</span> <span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tortoise</span> <span class="p">(</span><span class="n">f</span> <span class="n">hare</span><span class="p">)</span>  
  <span class="k">in</span> <span class="n">loop</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x0</span> <span class="p">(</span><span class="n">f</span> <span class="n">x0</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function takes two arguments: <code class="language-plaintext highlighter-rouge">f</code>, a function that takes a value and returns the next value in the sequence, and <code class="language-plaintext highlighter-rouge">x0</code>, the initial value in the sequence. The function returns the length of the cycle in the sequence.</p>

<p>Here is an example of how to use the <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">23</span>  
<span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="k">let</span> <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span>  
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">f</code> is a function that generates a sequence of values using the formula <code class="language-plaintext highlighter-rouge">x^2 + 1 (mod 23)</code>, <code class="language-plaintext highlighter-rouge">x0</code> is the initial value of the sequence, and <code class="language-plaintext highlighter-rouge">cycle_length</code> is the length of the cycle in the sequence.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brentâ€™s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before.</p>

<p>At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence.</p>

<p>The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brentâ€™s algorithm is O(Î¼ + Î»), where Î¼ is the distance between the start of the sequence and the start of the cycle, and Î» is the length of the cycle. This is because the algorithm performs at most 2(Î¼ + Î») iterations of the loop, and each iteration takes O(1) time.</p>

<p>The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables.</p>

<p>Brentâ€™s algorithm is generally faster than Floydâ€™s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Brentâ€™s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brentâ€™s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brentâ€™s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brentâ€™s algorithm is O(Î¼ + Î»), where Î¼ is the distance between the start of the sequence and the start of the cycle, and Î» is the length of the cycle. This is because the algorithm performs at most 2(Î¼ + Î») iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brentâ€™s algorithm is generally faster than Floydâ€™s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/fisher-yates.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/fisher-yates</id><content type="html" xml:base="/algorithm/2023/11/21/fisher-yates.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book â€œThe Art of Computer Programmingâ€. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of the Fisher-Yates shuffle in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fisher_yates_shuffle</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">in</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="n">arr</span>  
</code></pre></div></div>

<p>This function takes an array of elements and returns a shuffled version of the array. It works by iterating through the array from the last element to the first. For each element, it picks a random index between 0 and the current index, inclusive, and swaps the element at that index with the current element.</p>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">deck</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="s2">"Ace of Spades"</span><span class="p">;</span> <span class="s2">"2 of Spades"</span><span class="p">;</span> <span class="s2">"3 of Spades"</span><span class="p">;</span> <span class="s2">"King of Diamonds"</span> <span class="o">|</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">shuffled_deck</span> <span class="o">=</span> <span class="n">fisher_yates_shuffle</span> <span class="n">deck</span>  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">x</span><span class="p">)</span> <span class="n">shuffled_deck</span>  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start by initializing a variable <code class="language-plaintext highlighter-rouge">n</code> to the length of the input array.</li>
  <li>Iterate through the array from the last element to the first using a for loop. For each element at index <code class="language-plaintext highlighter-rouge">i</code>:</li>
  <li>Generate a random integer <code class="language-plaintext highlighter-rouge">j</code> between 0 and <code class="language-plaintext highlighter-rouge">i</code> inclusive using the <code class="language-plaintext highlighter-rouge">Random.int</code> function.</li>
  <li>Swap the element at index <code class="language-plaintext highlighter-rouge">j</code> with the element at index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Continue iterating until all elements have been shuffled.</li>
  <li>Return the shuffled array.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Fisher-Yates shuffle is O(n), where n is the number of elements in the input array. This is because the algorithm iterates through the array once and performs a constant amount of work for each element.</p>

<p>The space complexity of the Fisher-Yates shuffle is O(1), because the algorithm shuffles the input array in place and does not require any additional memory allocation.</p>

<p>Overall, the Fisher-Yates shuffle is a simple and efficient algorithm for shuffling collections of elements.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book â€œThe Art of Computer Programmingâ€. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography. Implementation Here is an implementation of the Fisher-Yates shuffle in OCaml: let fisher_yates_shuffle arr = let n = Array.length arr in for i = n - 1 downto 1 do let j = Random.int (i + 1) in let tmp = arr.(j) in arr.(j) &lt;- arr.(i); arr.(i) &lt;- tmp done; arr]]></summary></entry><entry><title type="html">Breadth-First Search</title><link href="/algorithm/2023/11/21/breadth-first-search.html" rel="alternate" type="text/html" title="Breadth-First Search" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/breadth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/breadth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of BFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">bfs</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">queue</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">queue</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">visited</span>
    <span class="o">|</span> <span class="n">node</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span>
          <span class="n">explore</span> <span class="n">visited</span> <span class="n">rest</span>
        <span class="k">else</span>
          <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">new_nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">n</span> <span class="n">visited</span><span class="p">))</span> <span class="n">neighbors</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">updated_queue</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">@</span> <span class="n">new_nodes</span> <span class="k">in</span>
          <span class="n">explore</span> <span class="p">(</span><span class="n">visited</span> <span class="o">@</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="n">updated_queue</span>
  <span class="k">in</span> <span class="n">explore</span> <span class="bp">[]</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> parameter is a list of tuples, where the first element is a node and the second element is a list of its neighboring nodes. The <code class="language-plaintext highlighter-rouge">start</code> parameter is the node where the search begins. The function returns a list of nodes visited in breadth-first order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">bfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="p">[</span>
    <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
  <span class="p">]</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span> <span class="n">graph</span> <span class="s2">"A"</span> <span class="c">(* ["A"; "B"; "C"; "D"; "E"; "F"] *)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an empty <code class="language-plaintext highlighter-rouge">visited</code> list and a <code class="language-plaintext highlighter-rouge">queue</code> with the starting node in it.</li>
  <li>While the <code class="language-plaintext highlighter-rouge">queue</code> is not empty, take the first node from the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has already been visited, skip it and continue to the next node in the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has not been visited, add it to the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
  <li>Get the list of neighboring nodes for the current node from the <code class="language-plaintext highlighter-rouge">graph</code>.</li>
  <li>Filter out the nodes that have already been visited.</li>
  <li>Add the remaining nodes to the end of the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>Repeat steps 2-7 until the <code class="language-plaintext highlighter-rouge">queue</code> is empty.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices and <code class="language-plaintext highlighter-rouge">|E|</code> is the number of edges in the graph. This is because BFS visits each vertex and edge exactly once.</p>

<p>The space complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices in the graph. This is because BFS uses a queue to store the nodes to be visited, and the maximum size of the queue is the number of vertices at the maximum depth of the graph. In the worst case, this is all the vertices, so the space complexity is <code class="language-plaintext highlighter-rouge">O(|V|)</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type â€˜a graph = (â€˜a * â€˜a list) list]]></summary></entry><entry><title type="html">Simpsonâ€™s Rule</title><link href="/algorithm/2023/11/21/simpson-rule.html" rel="alternate" type="text/html" title="Simpsonâ€™s Rule" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/simpson-rule</id><content type="html" xml:base="/algorithm/2023/11/21/simpson-rule.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Simpsonâ€™s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpsonâ€™s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration.</p>

<h2 id="implementation">Implementation</h2>
<p>The following implementation is in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">simpson</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="p">(</span><span class="k">try</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
       <span class="n">s_new</span> <span class="o">:=</span> <span class="n">trapzd</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span><span class="p">;</span>
       <span class="n">s_old</span> <span class="o">:=</span> <span class="p">((</span><span class="mi">4</span><span class="o">.</span> <span class="o">*.</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_new</span><span class="p">)</span> <span class="o">/.</span> <span class="mi">3</span><span class="o">.;</span>
       <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span>
       <span class="k">then</span> <span class="p">(</span>
         <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_old</span><span class="p">)</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*.</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">o_old</span> <span class="k">in</span>
         <span class="k">assert</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)));</span>
         <span class="n">o_old</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_old</span><span class="p">;</span>
         <span class="n">o_new</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span>
     <span class="k">done</span>
   <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
  <span class="o">!</span><span class="n">s_new</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">simpson</code> takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">simpson</code> function takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>
  </li>
  <li>
    <p>The function initializes four variables: <code class="language-plaintext highlighter-rouge">s_new</code>, <code class="language-plaintext highlighter-rouge">s_old</code>, <code class="language-plaintext highlighter-rouge">o_new</code>, and <code class="language-plaintext highlighter-rouge">o_old</code>, all of which are set to 0. <code class="language-plaintext highlighter-rouge">s_new</code> and <code class="language-plaintext highlighter-rouge">s_old</code> will be used to store the current and previous approximations of the integral, respectively, while <code class="language-plaintext highlighter-rouge">o_new</code> and <code class="language-plaintext highlighter-rouge">o_old</code> will be used to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function uses a <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs.</p>
  </li>
  <li>
    <p>The function then enters a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code>. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the <code class="language-plaintext highlighter-rouge">trapzd</code> function, and stores it in the <code class="language-plaintext highlighter-rouge">s_new</code> variable.</p>
  </li>
  <li>
    <p>The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s_old = (4 * s_new - o_new) / 3  
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">s_old</code> is the new approximation, <code class="language-plaintext highlighter-rouge">s_new</code> is the current approximation, and <code class="language-plaintext highlighter-rouge">o_new</code> is the previous approximation.</p>

<ol>
  <li>
    <p>The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>). If it is, the function returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>). If it is not, the function updates the <code class="language-plaintext highlighter-rouge">o_old</code> and <code class="language-plaintext highlighter-rouge">o_new</code> variables to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function exits the loop and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
  <li>
    <p>If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
</ol>

<p>Overall, the <code class="language-plaintext highlighter-rouge">simpson</code> function uses the Simpsonâ€™s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into <code class="language-plaintext highlighter-rouge">n</code> subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function depends on the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) and the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">trapzd</code> function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates <code class="language-plaintext highlighter-rouge">n</code> times to compute the sum of the areas of the trapezoids.</p>

<p>The <code class="language-plaintext highlighter-rouge">simpson</code> function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function <code class="language-plaintext highlighter-rouge">n</code> times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function can be approximated as follows:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code> has a time complexity of O(n).</li>
  <li>The <code class="language-plaintext highlighter-rouge">trapzd</code> function is called <code class="language-plaintext highlighter-rouge">n</code> times, so its time complexity is O(n^2).</li>
  <li>The time complexity of the computations inside the loop is O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">if</code> statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block has a time complexity of O(1).</li>
  <li>The function returns the current approximation of the integral, which has a time complexity of O(1).</li>
</ul>

<p>Therefore, the overall time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) increases. The maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of <code class="language-plaintext highlighter-rouge">eps</code> will result in a more accurate approximation, but will also require more iterations of the <code class="language-plaintext highlighter-rouge">for</code> loop and hence increase the running time of the function.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Simpsonâ€™s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpsonâ€™s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration. Implementation The following implementation is in OCaml: let simpson ?(n = 20) ?(eps = 1e-6) f a b = let s_new = ref 0. in let s_old = ref 0. in let o_new = ref 0. in let o_old = ref 0. in (try for i = 1 to n do s_new := trapzd f a b i; s_old := ((4. *. !s_new) -. !o_new) /. 3.; if i &gt; 5 then ( let d = abs_float (!s_old -. !o_old) in let e = eps *. abs_float !o_old in assert (not (d &lt; e || (!s_old = 0. &amp;&amp; !o_old = 0.))); o_old := !s_old; o_new := !s_new) done with | _ -&gt; ()); !s_new The function simpson takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. Step-by-step Explanation The simpson function takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. The function initializes four variables: s_new, s_old, o_new, and o_old, all of which are set to 0. s_new and s_old will be used to store the current and previous approximations of the integral, respectively, while o_new and o_old will be used to store the current and previous approximations of the error, respectively. The function uses a try-with block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs. The function then enters a for loop that iterates from 1 to n. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the trapzd function, and stores it in the s_new variable. The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula: s_old = (4 * s_new - o_new) / 3 where s_old is the new approximation, s_new is the current approximation, and o_new is the previous approximation. The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (eps). If it is, the function returns the current approximation of the integral (s_new). If it is not, the function updates the o_old and o_new variables to store the current and previous approximations of the error, respectively. The function exits the loop and returns the current approximation of the integral (s_new). If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (s_new). Overall, the simpson function uses the Simpsonâ€™s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into n subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the trapzd function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. Complexity Analysis The time complexity of the simpson function depends on the number of intervals used in the approximation (n) and the maximum relative error allowed (eps). The trapzd function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a for loop that iterates n times to compute the sum of the areas of the trapezoids. The simpson function uses the trapzd function n times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. The time complexity of the simpson function can be approximated as follows: The for loop that iterates from 1 to n has a time complexity of O(n). The trapzd function is called n times, so its time complexity is O(n^2). The time complexity of the computations inside the loop is O(1). The if statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1). The try-with block has a time complexity of O(1). The function returns the current approximation of the integral, which has a time complexity of O(1). Therefore, the overall time complexity of the simpson function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (n) increases. The maximum relative error allowed (eps) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of eps will result in a more accurate approximation, but will also require more iterations of the for loop and hence increase the running time of the function.]]></summary></entry></feed>