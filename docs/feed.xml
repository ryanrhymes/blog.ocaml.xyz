<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-27T21:45:26+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Extended Trapezoidal Rule</title><link href="/algorithm/2023/11/21/trapzd.html" rel="alternate" type="text/html" title="Extended Trapezoidal Rule" /><published>2023-11-21T06:00:00+02:00</published><updated>2023-11-21T06:00:00+02:00</updated><id>/algorithm/2023/11/21/trapzd</id><content type="html" xml:base="/algorithm/2023/11/21/trapzd.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The trapezoidal rule is a numerical integration technique used to approximate the definite integral of a function. It approximates the area under a curve by dividing the area into a series of trapezoids. The trapezoidal rule is widely used in engineering, physics, and other fields that require numerical integration.</p>

<h2 id="implementation">Implementation</h2>
<p>The OCaml code below implements the trapezoidal rule algorithm. The function <code class="language-plaintext highlighter-rouge">trapzd</code> takes four arguments: <code class="language-plaintext highlighter-rouge">f</code> is the function to be integrated, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are the lower and upper bounds of the integral, and <code class="language-plaintext highlighter-rouge">n</code> is the number of trapezoids to be used in the approximation.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">trapzd</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"trapzd requires n &gt; 0 and a &lt;= b whereas n = %i, a = %g, b = %g"</span>
        <span class="n">n</span>
        <span class="n">a</span>
        <span class="n">b</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">then</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="o">*.</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">+.</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="o">.</span> <span class="o">**</span> <span class="n">float_of_int</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="o">/.</span> <span class="n">m</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">a</span> <span class="o">+.</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="n">d</span><span class="p">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">int_of_float</span> <span class="n">m</span> <span class="k">do</span>
      <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span> <span class="o">+.</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">s</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s</span> <span class="o">+.</span> <span class="n">f</span> <span class="o">!</span><span class="n">x</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="n">d</span> <span class="o">*.</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span> <span class="o">+.</span> <span class="n">f</span> <span class="n">b</span><span class="p">))</span> <span class="o">+.</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">*.</span> <span class="n">d</span><span class="p">))</span>
</code></pre></div></div>

<p>The function first checks that <code class="language-plaintext highlighter-rouge">n</code> is greater than zero and that <code class="language-plaintext highlighter-rouge">a</code> is less than or equal to <code class="language-plaintext highlighter-rouge">b</code>. If either of these conditions is not met, an exception is raised.</p>

<p>If <code class="language-plaintext highlighter-rouge">n</code> is equal to 1, the function returns the area of a single trapezoid. Otherwise, the function computes the width of each trapezoid <code class="language-plaintext highlighter-rouge">d</code> and the midpoint of the first trapezoid <code class="language-plaintext highlighter-rouge">x</code>. It then iterates over the remaining trapezoids, computing the area of each and summing them together.</p>

<p>The final result is the sum of the areas of all the trapezoids.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Verify that <code class="language-plaintext highlighter-rouge">n</code> is greater than zero and that <code class="language-plaintext highlighter-rouge">a</code> is less than or equal to <code class="language-plaintext highlighter-rouge">b</code>. If either of these conditions is not met, raise an exception.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is equal to 1, return the area of a single trapezoid: <code class="language-plaintext highlighter-rouge">0.5 *. (b -. a) *. (f a +. f b)</code></li>
  <li>Compute the width of each trapezoid: <code class="language-plaintext highlighter-rouge">d = (b -. a) /. m</code>, where <code class="language-plaintext highlighter-rouge">m = 2. ** float_of_int (n - 1)</code></li>
  <li>Compute the midpoint of the first trapezoid: <code class="language-plaintext highlighter-rouge">x = ref (a +. (0.5 *. d))</code></li>
  <li>Initialize the sum of the areas of all the trapezoids to 0: <code class="language-plaintext highlighter-rouge">s = ref 0.</code></li>
  <li>Iterate over the remaining trapezoids, computing the area of each and summing them together:
    <ol>
      <li>Increment the midpoint by the width of the trapezoid: <code class="language-plaintext highlighter-rouge">x := !x +. d</code></li>
      <li>Compute the area of the trapezoid and add it to the sum: <code class="language-plaintext highlighter-rouge">s := !s +. f !x</code></li>
    </ol>
  </li>
  <li>Compute the final result: <code class="language-plaintext highlighter-rouge">(0.5 *. d *. (f a +. f b)) +. (!s *. d)</code></li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The trapezoidal rule algorithm has a time complexity of O(n), where n is the number of trapezoids used in the approximation. This is because the algorithm iterates over each trapezoid once, computing its area and summing them together.</p>

<p>The space complexity of the algorithm is O(1), because it only uses a constant amount of memory to store the variables <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">s</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The trapezoidal rule is a numerical integration technique used to approximate the definite integral of a function. It approximates the area under a curve by dividing the area into a series of trapezoids. The trapezoidal rule is widely used in engineering, physics, and other fields that require numerical integration. Implementation The OCaml code below implements the trapezoidal rule algorithm. The function trapzd takes four arguments: f is the function to be integrated, a and b are the lower and upper bounds of the integral, and n is the number of trapezoids to be used in the approximation.]]></summary></entry><entry><title type="html">Polynomial Interpolation</title><link href="/algorithm/2023/11/21/polynomial-interpolation.html" rel="alternate" type="text/html" title="Polynomial Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/polynomial-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/polynomial-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), …, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing.</p>

<h2 id="implementation">Implementation</h2>

<p>The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function <code class="language-plaintext highlighter-rouge">polint</code> takes three arguments - <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. The arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> represent the x-coordinates and y-coordinates of the n points, respectively. The variable <code class="language-plaintext highlighter-rouge">x</code> represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at <code class="language-plaintext highlighter-rouge">x</code> and the error estimate.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">polint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"polint requires that xs and ys have the same length, but xs length is %i \
         whereas ys length is %i"</span>
        <span class="n">n</span>
        <span class="n">m</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dif</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">dift</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">dift</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">dif</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">dif</span> <span class="o">:=</span> <span class="n">dift</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">ho</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">hp</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">ho</span> <span class="o">-.</span> <span class="n">hp</span> <span class="k">in</span>
      <span class="k">assert</span> <span class="p">(</span><span class="n">den</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">den</span> <span class="k">in</span>
      <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ho</span> <span class="o">*.</span> <span class="n">den</span><span class="p">;</span>
      <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">hp</span> <span class="o">*.</span> <span class="n">den</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">then</span> <span class="n">dy</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">(</span>
      <span class="n">dy</span> <span class="o">:=</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="o">!</span><span class="n">y</span> <span class="o">+.</span> <span class="o">!</span><span class="n">dy</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>
    <p>The function first checks if the lengths of the arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are the same. If they are not, an exception is raised.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created, which are initialized to the values in the array <code class="language-plaintext highlighter-rouge">ys</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is initialized to 0, which will be used to keep track of the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">dif</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first point in the array <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>A loop is executed over all the points in the array <code class="language-plaintext highlighter-rouge">xs</code>. For each point, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the point is computed. If this difference is less than the current value of <code class="language-plaintext highlighter-rouge">dif</code>, then the index of the point is stored in the variable <code class="language-plaintext highlighter-rouge">ns</code>, and the value of <code class="language-plaintext highlighter-rouge">dif</code> is updated to the new difference.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is initialized to the y-coordinate of the point in the array <code class="language-plaintext highlighter-rouge">ys</code> that is closest to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>A loop is executed n-1 times. In each iteration, two nested loops are executed over the remaining points in the array <code class="language-plaintext highlighter-rouge">xs</code>. The variable <code class="language-plaintext highlighter-rouge">m</code> is used to keep track of the number of iterations.</p>
  </li>
  <li>
    <p>In the inner loop, the variable <code class="language-plaintext highlighter-rouge">ho</code> is initialized to the difference between the current point and <code class="language-plaintext highlighter-rouge">x</code>, and the variable <code class="language-plaintext highlighter-rouge">hp</code> is initialized to the difference between the point m positions ahead and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">w</code> is initialized to the difference between the y-coordinates of the point m positions ahead and the current point.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is initialized to the difference between <code class="language-plaintext highlighter-rouge">ho</code> and <code class="language-plaintext highlighter-rouge">hp</code>. If <code class="language-plaintext highlighter-rouge">den</code> is 0, an exception is raised.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is updated to <code class="language-plaintext highlighter-rouge">w/den</code>.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">c</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">ho*den</code>, and the value of <code class="language-plaintext highlighter-rouge">d</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">hp*den</code>.</p>
  </li>
  <li>
    <p>If the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">n-m-1</code> multiplied by 2, then the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">c[ns+1]</code>. Otherwise, the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">d[ns]</code>, and the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is decremented by 1.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is updated to <code class="language-plaintext highlighter-rouge">y+dy</code>.</p>
  </li>
  <li>
    <p>The function returns the tuple <code class="language-plaintext highlighter-rouge">(y, dy)</code>.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The polynomial interpolation algorithm has a time complexity of O(n^2), where n is the number of points. This is because the algorithm involves a nested loop over all the points in the input arrays. In the outer loop, the algorithm iterates n-1 times, and in the inner loop, it iterates over the remaining n-m-1 points. Therefore, the total number of iterations is given by the sum of the first n-1 positive integers, which is n(n-1)/2. Thus, the time complexity of the algorithm is O(n^2).</p>

<p>In terms of space complexity, the algorithm uses two arrays of size n to store the y-coordinates and two additional variables to store the interpolated value and the error estimate. Therefore, the space complexity of the algorithm is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), …, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing. Implementation The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function polint takes three arguments - xs, ys, and x. The arrays xs and ys represent the x-coordinates and y-coordinates of the n points, respectively. The variable x represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at x and the error estimate.]]></summary></entry><entry><title type="html">Rational Interpolation</title><link href="/algorithm/2023/11/21/rational-interpolation.html" rel="alternate" type="text/html" title="Rational Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/rational-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/rational-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.</p>

<h2 id="implementation">Implementation</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm is implemented in OCaml as shown below. The function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. <code class="language-plaintext highlighter-rouge">xs</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the x-coordinates of the function, <code class="language-plaintext highlighter-rouge">ys</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the y-coordinates of the function, and <code class="language-plaintext highlighter-rouge">x</code> is the point at which the function is to be approximated. The function returns a tuple containing the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ratint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"ratint requires that xs and ys have the same length, but xs length is %i \
         whereas ys length is %i"</span>
        <span class="n">n</span>
        <span class="n">m</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">hh</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-25</span> <span class="k">in</span>
  <span class="k">try</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">dy</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">.;</span>
        <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span><span class="p">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">hh</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">hh</span> <span class="o">:=</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+.</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
    <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span><span class="p">)</span> <span class="o">*.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/.</span> <span class="n">h</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-.</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"Has a pole"</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">dd</span> <span class="k">in</span>
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*.</span> <span class="n">dd</span><span class="p">;</span>
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">t</span> <span class="o">*.</span> <span class="n">dd</span>
      <span class="k">done</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
  <span class="k">with</span>
  <span class="o">|</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
  <span class="o">|</span> <span class="n">e</span>                   <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">e</span>
</code></pre></div></div>

<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">ratint</code> function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are obtained and verified to be equal. If they are not equal, an error is thrown.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created as copies of the <code class="language-plaintext highlighter-rouge">ys</code> array.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">hh</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first element of <code class="language-plaintext highlighter-rouge">xs</code>. This will be used to keep track of the smallest distance between <code class="language-plaintext highlighter-rouge">x</code> and an element of <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>Three variables <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">dy</code>, and <code class="language-plaintext highlighter-rouge">ns</code> are initialized to 0. <code class="language-plaintext highlighter-rouge">y</code> will be used to store the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">dy</code> will be used to store the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">ns</code> will be used to keep track of the index of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">eps</code> is initialized to a small number. This will be used to prevent division by zero.</p>
  </li>
  <li>
    <p>A for loop is used to iterate over the <code class="language-plaintext highlighter-rouge">xs</code> array.</p>
  </li>
  <li>
    <p>For each <code class="language-plaintext highlighter-rouge">xs[i]</code>, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xs[i]</code> is computed and stored in a variable <code class="language-plaintext highlighter-rouge">h</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is equal to 0, then <code class="language-plaintext highlighter-rouge">ys[i]</code> is the exact value of the function at <code class="language-plaintext highlighter-rouge">x</code>, so <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[i]</code>, <code class="language-plaintext highlighter-rouge">dy</code> is set to 0, and an exception is raised to exit the loop.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is less than <code class="language-plaintext highlighter-rouge">hh</code>, then <code class="language-plaintext highlighter-rouge">ns</code> is set to <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">hh</code> is set to <code class="language-plaintext highlighter-rouge">h</code>, and the <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i]</code> arrays are updated to <code class="language-plaintext highlighter-rouge">ys[i]</code>. This keeps track of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>After the loop, <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[ns]</code>, and <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>Two nested for loops are used to iterate over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays.</p>
  </li>
  <li>
    <p>For each iteration, <code class="language-plaintext highlighter-rouge">m</code> represents the current iteration of the outer loop, and <code class="language-plaintext highlighter-rouge">i</code> represents the current iteration of the inner loop.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">w</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i-1]</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">h</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">xs[i+m-1]</code> and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">t</code> is computed as <code class="language-plaintext highlighter-rouge">(xs[i-1] - x) * d[i-1] / h</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">t - c[i]</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">dd</code> is equal to 0, then the function has a pole, and an exception is thrown.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">w / dd</code>.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">d[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">c[i] * dd</code>, and the <code class="language-plaintext highlighter-rouge">c[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">t * dd</code>.</p>
  </li>
  <li>
    <p>After the loops, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">dy</code> are returned as the approximation and derivative of the function at <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>If any exceptions are raised during the computation, they are rethrown.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm has a time complexity of O(n^2), where n is the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code>.</p>

<p>This is because the algorithm has two nested loops, each iterating over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays. The outer loop iterates <code class="language-plaintext highlighter-rouge">n-1</code> times, and the inner loop iterates <code class="language-plaintext highlighter-rouge">n-m</code> times, where <code class="language-plaintext highlighter-rouge">m</code> is the current iteration of the outer loop. This gives a total of <code class="language-plaintext highlighter-rouge">(n-1) + (n-2) + ... + 1</code> iterations for the outer loop, which is equal to <code class="language-plaintext highlighter-rouge">n(n-1)/2</code>. The inner loop has a similar number of iterations, giving a total of <code class="language-plaintext highlighter-rouge">n(n-1)^2/2</code> iterations for both loops combined.</p>

<p>Therefore, the time complexity of the algorithm is O(n^2). This means that as the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> increases, the time taken by the algorithm to compute the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and its derivative also increases quadratically.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.]]></summary></entry><entry><title type="html">Topological Sort</title><link href="/algorithm/2023/11/21/topological-sort.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2023-11-21T04:00:00+02:00</published><updated>2023-11-21T04:00:00+02:00</updated><id>/algorithm/2023/11/21/topological-sort</id><content type="html" xml:base="/algorithm/2023/11/21/topological-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of topological sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">topological_sort</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="kt">array</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">graph</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">false</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>  
  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">dfs</span> <span class="p">(</span><span class="n">u</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>  
    <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="bp">true</span><span class="p">;</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">v</span><span class="p">)</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>  
    <span class="n">stack</span> <span class="o">:=</span> <span class="n">u</span> <span class="o">::</span> <span class="o">!</span><span class="n">stack</span>  
  <span class="k">in</span>  
  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  
  <span class="o">!</span><span class="n">stack</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">graph</code> is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order.  Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">courses</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"C1"</span><span class="p">;</span> <span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">;</span> <span class="s2">"C4"</span><span class="p">;</span> <span class="s2">"C5"</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">prerequisites</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"C1"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C2"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C3"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C4"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C5"</span><span class="p">])]</span>  
  
<span class="k">let</span> <span class="n">course_graph</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">courses</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">[]</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">find_index</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="n">courses</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">index</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Course not found"</span>
  <span class="k">in</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">c</span><span class="o">,</span> <span class="n">prereqs</span><span class="p">)</span> <span class="o">-&gt;</span>  
    <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">vs</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">index_of_course</span> <span class="n">prereqs</span> <span class="k">in</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v</span> <span class="o">::</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="n">vs</span>  
  <span class="p">)</span> <span class="n">prerequisites</span><span class="p">;</span>  
  <span class="n">graph</span>  
  
<span class="k">let</span> <span class="n">course_order</span> <span class="o">=</span> <span class="n">topological_sort</span> <span class="n">course_graph</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">courses</span> <span class="n">i</span><span class="p">)</span>

<span class="k">let</span> <span class="n">print_course_order</span> <span class="n">course_order</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">course</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%s "</span> <span class="n">course</span><span class="p">)</span> <span class="n">course_order</span><span class="p">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">print_course_order</span> <span class="n">course_order</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an array <code class="language-plaintext highlighter-rouge">visited</code> of size <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the number of nodes in the graph. Initialize all elements to <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>Create an empty stack <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Define a recursive function <code class="language-plaintext highlighter-rouge">dfs</code> that takes a node <code class="language-plaintext highlighter-rouge">u</code> as input.</li>
  <li>Mark <code class="language-plaintext highlighter-rouge">u</code> as visited by setting <code class="language-plaintext highlighter-rouge">visited.(u)</code> to <code class="language-plaintext highlighter-rouge">true</code>.</li>
  <li>For each neighbor <code class="language-plaintext highlighter-rouge">v</code> of <code class="language-plaintext highlighter-rouge">u</code> in the graph, if <code class="language-plaintext highlighter-rouge">v</code> has not been visited, recursively call <code class="language-plaintext highlighter-rouge">dfs v</code>.</li>
  <li>Push <code class="language-plaintext highlighter-rouge">u</code> onto the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Loop through all nodes in the graph. If a node has not been visited, call <code class="language-plaintext highlighter-rouge">dfs</code> on it.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
</ol>

<p>The algorithm works by performing a depth-first search (DFS) on the graph. When a node is finished being explored, it is pushed onto the stack. Since a DAG has no cycles, the nodes can be ordered in reverse order of their finishing times, which gives a valid topological order.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of topological sort is O(V+E), where V is the number of vertices and E is the number of edges in the graph. This is because each vertex and edge is visited once during the DFS traversal. The space complexity is also O(V+E), since the adjacency list takes up O(V+E) space and the stack can contain all vertices in the worst case.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing. Implementation Here is an implementation of topological sort in OCaml: let topological_sort (graph: int list array) : int list = let n = Array.length graph in let visited = Array.make n false in let stack = ref [] in let rec dfs (u: int) : unit = visited.(u) &lt;- true; List.iter (fun v -&gt; if not visited.(v) then dfs v) graph.(u); stack := u :: !stack in for i = 0 to n - 1 do if not visited.(i) then dfs i done; !stack Here, graph is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order. Here is an example.]]></summary></entry><entry><title type="html">Brent’s Algorithm</title><link href="/algorithm/2023/11/21/brents-algorithm.html" rel="alternate" type="text/html" title="Brent’s Algorithm" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/brents-algorithm</id><content type="html" xml:base="/algorithm/2023/11/21/brents-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Brent’s algorithm in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">power</span> <span class="n">lam</span> <span class="n">tortoise</span> <span class="n">hare</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">hare</span> <span class="k">then</span> <span class="n">lam</span>  
    <span class="k">else</span> <span class="k">if</span> <span class="n">power</span> <span class="o">=</span> <span class="n">lam</span> <span class="k">then</span> <span class="n">loop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="mi">0</span> <span class="n">hare</span> <span class="n">hare</span>  
    <span class="k">else</span> <span class="n">loop</span> <span class="n">power</span> <span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tortoise</span> <span class="p">(</span><span class="n">f</span> <span class="n">hare</span><span class="p">)</span>  
  <span class="k">in</span> <span class="n">loop</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x0</span> <span class="p">(</span><span class="n">f</span> <span class="n">x0</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function takes two arguments: <code class="language-plaintext highlighter-rouge">f</code>, a function that takes a value and returns the next value in the sequence, and <code class="language-plaintext highlighter-rouge">x0</code>, the initial value in the sequence. The function returns the length of the cycle in the sequence.</p>

<p>Here is an example of how to use the <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">23</span>  
<span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="k">let</span> <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span>  
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">f</code> is a function that generates a sequence of values using the formula <code class="language-plaintext highlighter-rouge">x^2 + 1 (mod 23)</code>, <code class="language-plaintext highlighter-rouge">x0</code> is the initial value of the sequence, and <code class="language-plaintext highlighter-rouge">cycle_length</code> is the length of the cycle in the sequence.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before.</p>

<p>At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence.</p>

<p>The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time.</p>

<p>The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables.</p>

<p>Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/fisher-yates.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/fisher-yates</id><content type="html" xml:base="/algorithm/2023/11/21/fisher-yates.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book “The Art of Computer Programming”. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of the Fisher-Yates shuffle in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fisher_yates_shuffle</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">in</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="n">arr</span>  
</code></pre></div></div>

<p>This function takes an array of elements and returns a shuffled version of the array. It works by iterating through the array from the last element to the first. For each element, it picks a random index between 0 and the current index, inclusive, and swaps the element at that index with the current element.</p>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">deck</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="s2">"Ace of Spades"</span><span class="p">;</span> <span class="s2">"2 of Spades"</span><span class="p">;</span> <span class="s2">"3 of Spades"</span><span class="p">;</span> <span class="s2">"King of Diamonds"</span> <span class="o">|</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">shuffled_deck</span> <span class="o">=</span> <span class="n">fisher_yates_shuffle</span> <span class="n">deck</span>  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">x</span><span class="p">)</span> <span class="n">shuffled_deck</span>  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start by initializing a variable <code class="language-plaintext highlighter-rouge">n</code> to the length of the input array.</li>
  <li>Iterate through the array from the last element to the first using a for loop. For each element at index <code class="language-plaintext highlighter-rouge">i</code>:</li>
  <li>Generate a random integer <code class="language-plaintext highlighter-rouge">j</code> between 0 and <code class="language-plaintext highlighter-rouge">i</code> inclusive using the <code class="language-plaintext highlighter-rouge">Random.int</code> function.</li>
  <li>Swap the element at index <code class="language-plaintext highlighter-rouge">j</code> with the element at index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Continue iterating until all elements have been shuffled.</li>
  <li>Return the shuffled array.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Fisher-Yates shuffle is O(n), where n is the number of elements in the input array. This is because the algorithm iterates through the array once and performs a constant amount of work for each element.</p>

<p>The space complexity of the Fisher-Yates shuffle is O(1), because the algorithm shuffles the input array in place and does not require any additional memory allocation.</p>

<p>Overall, the Fisher-Yates shuffle is a simple and efficient algorithm for shuffling collections of elements.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book “The Art of Computer Programming”. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography. Implementation Here is an implementation of the Fisher-Yates shuffle in OCaml: let fisher_yates_shuffle arr = let n = Array.length arr in for i = n - 1 downto 1 do let j = Random.int (i + 1) in let tmp = arr.(j) in arr.(j) &lt;- arr.(i); arr.(i) &lt;- tmp done; arr]]></summary></entry><entry><title type="html">Breadth-First Search</title><link href="/algorithm/2023/11/21/breadth-first-search.html" rel="alternate" type="text/html" title="Breadth-First Search" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/breadth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/breadth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of BFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">bfs</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">queue</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">queue</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">visited</span>
    <span class="o">|</span> <span class="n">node</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span>
          <span class="n">explore</span> <span class="n">visited</span> <span class="n">rest</span>
        <span class="k">else</span>
          <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">new_nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">n</span> <span class="n">visited</span><span class="p">))</span> <span class="n">neighbors</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">updated_queue</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">@</span> <span class="n">new_nodes</span> <span class="k">in</span>
          <span class="n">explore</span> <span class="p">(</span><span class="n">visited</span> <span class="o">@</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="n">updated_queue</span>
  <span class="k">in</span> <span class="n">explore</span> <span class="bp">[]</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> parameter is a list of tuples, where the first element is a node and the second element is a list of its neighboring nodes. The <code class="language-plaintext highlighter-rouge">start</code> parameter is the node where the search begins. The function returns a list of nodes visited in breadth-first order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">bfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="p">[</span>
    <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
  <span class="p">]</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span> <span class="n">graph</span> <span class="s2">"A"</span> <span class="c">(* ["A"; "B"; "C"; "D"; "E"; "F"] *)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an empty <code class="language-plaintext highlighter-rouge">visited</code> list and a <code class="language-plaintext highlighter-rouge">queue</code> with the starting node in it.</li>
  <li>While the <code class="language-plaintext highlighter-rouge">queue</code> is not empty, take the first node from the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has already been visited, skip it and continue to the next node in the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has not been visited, add it to the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
  <li>Get the list of neighboring nodes for the current node from the <code class="language-plaintext highlighter-rouge">graph</code>.</li>
  <li>Filter out the nodes that have already been visited.</li>
  <li>Add the remaining nodes to the end of the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>Repeat steps 2-7 until the <code class="language-plaintext highlighter-rouge">queue</code> is empty.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices and <code class="language-plaintext highlighter-rouge">|E|</code> is the number of edges in the graph. This is because BFS visits each vertex and edge exactly once.</p>

<p>The space complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices in the graph. This is because BFS uses a queue to store the nodes to be visited, and the maximum size of the queue is the number of vertices at the maximum depth of the graph. In the worst case, this is all the vertices, so the space complexity is <code class="language-plaintext highlighter-rouge">O(|V|)</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list]]></summary></entry><entry><title type="html">Simpson’s Rule</title><link href="/algorithm/2023/11/21/simpson-rule.html" rel="alternate" type="text/html" title="Simpson’s Rule" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/simpson-rule</id><content type="html" xml:base="/algorithm/2023/11/21/simpson-rule.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration.</p>

<h2 id="implementation">Implementation</h2>
<p>The following implementation is in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">simpson</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">o_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="p">(</span><span class="k">try</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
       <span class="n">s_new</span> <span class="o">:=</span> <span class="n">trapzd</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">i</span><span class="p">;</span>
       <span class="n">s_old</span> <span class="o">:=</span> <span class="p">((</span><span class="mi">4</span><span class="o">.</span> <span class="o">*.</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_new</span><span class="p">)</span> <span class="o">/.</span> <span class="mi">3</span><span class="o">.;</span>
       <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span>
       <span class="k">then</span> <span class="p">(</span>
         <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">-.</span> <span class="o">!</span><span class="n">o_old</span><span class="p">)</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*.</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">o_old</span> <span class="k">in</span>
         <span class="k">assert</span> <span class="p">(</span><span class="n">not</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">e</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">s_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_old</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)));</span>
         <span class="n">o_old</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_old</span><span class="p">;</span>
         <span class="n">o_new</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_new</span><span class="p">)</span>
     <span class="k">done</span>
   <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
  <span class="o">!</span><span class="n">s_new</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">simpson</code> takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">simpson</code> function takes in three arguments: a function <code class="language-plaintext highlighter-rouge">f</code> that returns a float, and two floats <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> representing the lower and upper bounds of the integral. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">n</code> is the number of intervals used in the approximation, and <code class="language-plaintext highlighter-rouge">eps</code> is the maximum relative error allowed. The default values for <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">eps</code> are 20 and 1e-6, respectively.</p>
  </li>
  <li>
    <p>The function initializes four variables: <code class="language-plaintext highlighter-rouge">s_new</code>, <code class="language-plaintext highlighter-rouge">s_old</code>, <code class="language-plaintext highlighter-rouge">o_new</code>, and <code class="language-plaintext highlighter-rouge">o_old</code>, all of which are set to 0. <code class="language-plaintext highlighter-rouge">s_new</code> and <code class="language-plaintext highlighter-rouge">s_old</code> will be used to store the current and previous approximations of the integral, respectively, while <code class="language-plaintext highlighter-rouge">o_new</code> and <code class="language-plaintext highlighter-rouge">o_old</code> will be used to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function uses a <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs.</p>
  </li>
  <li>
    <p>The function then enters a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code>. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the <code class="language-plaintext highlighter-rouge">trapzd</code> function, and stores it in the <code class="language-plaintext highlighter-rouge">s_new</code> variable.</p>
  </li>
  <li>
    <p>The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula:</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s_old = (4 * s_new - o_new) / 3  
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">s_old</code> is the new approximation, <code class="language-plaintext highlighter-rouge">s_new</code> is the current approximation, and <code class="language-plaintext highlighter-rouge">o_new</code> is the previous approximation.</p>

<ol>
  <li>
    <p>The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>). If it is, the function returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>). If it is not, the function updates the <code class="language-plaintext highlighter-rouge">o_old</code> and <code class="language-plaintext highlighter-rouge">o_new</code> variables to store the current and previous approximations of the error, respectively.</p>
  </li>
  <li>
    <p>The function exits the loop and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
  <li>
    <p>If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (<code class="language-plaintext highlighter-rouge">s_new</code>).</p>
  </li>
</ol>

<p>Overall, the <code class="language-plaintext highlighter-rouge">simpson</code> function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into <code class="language-plaintext highlighter-rouge">n</code> subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function depends on the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) and the maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>).</p>

<p>The <code class="language-plaintext highlighter-rouge">trapzd</code> function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates <code class="language-plaintext highlighter-rouge">n</code> times to compute the sum of the areas of the trapezoids.</p>

<p>The <code class="language-plaintext highlighter-rouge">simpson</code> function uses the <code class="language-plaintext highlighter-rouge">trapzd</code> function <code class="language-plaintext highlighter-rouge">n</code> times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is.</p>

<p>The time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function can be approximated as follows:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">for</code> loop that iterates from 1 to <code class="language-plaintext highlighter-rouge">n</code> has a time complexity of O(n).</li>
  <li>The <code class="language-plaintext highlighter-rouge">trapzd</code> function is called <code class="language-plaintext highlighter-rouge">n</code> times, so its time complexity is O(n^2).</li>
  <li>The time complexity of the computations inside the loop is O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">if</code> statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1).</li>
  <li>The <code class="language-plaintext highlighter-rouge">try</code>-<code class="language-plaintext highlighter-rouge">with</code> block has a time complexity of O(1).</li>
  <li>The function returns the current approximation of the integral, which has a time complexity of O(1).</li>
</ul>

<p>Therefore, the overall time complexity of the <code class="language-plaintext highlighter-rouge">simpson</code> function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (<code class="language-plaintext highlighter-rouge">n</code>) increases. The maximum relative error allowed (<code class="language-plaintext highlighter-rouge">eps</code>) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of <code class="language-plaintext highlighter-rouge">eps</code> will result in a more accurate approximation, but will also require more iterations of the <code class="language-plaintext highlighter-rouge">for</code> loop and hence increase the running time of the function.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Simpson’s rule is a numerical method used to approximate the definite integral of a function. It is a closed Newton-Cotes formula that uses quadratic polynomials to approximate the function on each subinterval of the partition. It is named after Thomas Simpson, an 18th-century mathematician who first described the method. The Simpson’s rule is widely used in numerical analysis, physics, and engineering to solve problems that involve integration. Implementation The following implementation is in OCaml: let simpson ?(n = 20) ?(eps = 1e-6) f a b = let s_new = ref 0. in let s_old = ref 0. in let o_new = ref 0. in let o_old = ref 0. in (try for i = 1 to n do s_new := trapzd f a b i; s_old := ((4. *. !s_new) -. !o_new) /. 3.; if i &gt; 5 then ( let d = abs_float (!s_old -. !o_old) in let e = eps *. abs_float !o_old in assert (not (d &lt; e || (!s_old = 0. &amp;&amp; !o_old = 0.))); o_old := !s_old; o_new := !s_new) done with | _ -&gt; ()); !s_new The function simpson takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. Step-by-step Explanation The simpson function takes in three arguments: a function f that returns a float, and two floats a and b representing the lower and upper bounds of the integral. It also has two optional parameters: n is the number of intervals used in the approximation, and eps is the maximum relative error allowed. The default values for n and eps are 20 and 1e-6, respectively. The function initializes four variables: s_new, s_old, o_new, and o_old, all of which are set to 0. s_new and s_old will be used to store the current and previous approximations of the integral, respectively, while o_new and o_old will be used to store the current and previous approximations of the error, respectively. The function uses a try-with block to catch any exceptions that might be raised during the execution of the loop. This is done to ensure that the function always returns a value, even if an error occurs. The function then enters a for loop that iterates from 1 to n. For each iteration of the loop, the function computes the current approximation of the integral over the interval [a,b] using the trapzd function, and stores it in the s_new variable. The function then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. This is done using the formula: s_old = (4 * s_new - o_new) / 3 where s_old is the new approximation, s_new is the current approximation, and o_new is the previous approximation. The function then checks if the current iteration is greater than 5. If it is, the function checks if the relative error between the current and previous approximations is less than the maximum relative error allowed (eps). If it is, the function returns the current approximation of the integral (s_new). If it is not, the function updates the o_old and o_new variables to store the current and previous approximations of the error, respectively. The function exits the loop and returns the current approximation of the integral (s_new). If an exception is raised during the execution of the loop, the function catches it and returns the current approximation of the integral (s_new). Overall, the simpson function uses the Simpson’s rule to approximate the integral of a function over an interval [a,b]. It does this by dividing the interval into n subintervals, approximating the function on each subinterval using a quadratic polynomial, and summing the integrals over each subinterval to obtain an approximation of the integral over the entire interval. The function uses the trapzd function to approximate the integral over each subinterval, and uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. Complexity Analysis The time complexity of the simpson function depends on the number of intervals used in the approximation (n) and the maximum relative error allowed (eps). The trapzd function, which is used to approximate the integral over each subinterval, has a time complexity of O(n), where n is the number of intervals used in the approximation. This is because the function uses a for loop that iterates n times to compute the sum of the areas of the trapezoids. The simpson function uses the trapzd function n times to approximate the integral over each subinterval, and then uses the current and previous approximations of the integral to compute a new approximation that is more accurate. The function also checks if the relative error between the current and previous approximations is less than the maximum relative error allowed, and returns the current approximation if it is. The time complexity of the simpson function can be approximated as follows: The for loop that iterates from 1 to n has a time complexity of O(n). The trapzd function is called n times, so its time complexity is O(n^2). The time complexity of the computations inside the loop is O(1). The if statement that checks if the relative error is less than the maximum relative error allowed has a time complexity of O(1). The try-with block has a time complexity of O(1). The function returns the current approximation of the integral, which has a time complexity of O(1). Therefore, the overall time complexity of the simpson function is O(n^2). This means that the function takes longer to run as the number of intervals used in the approximation (n) increases. The maximum relative error allowed (eps) does not affect the time complexity of the function, but it does affect the accuracy of the approximation. A smaller value of eps will result in a more accurate approximation, but will also require more iterations of the for loop and hence increase the running time of the function.]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/depth-first-search.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T01:00:00+02:00</published><updated>2023-11-21T01:00:00+02:00</updated><id>/algorithm/2023/11/21/depth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/depth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of DFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>  
  
<span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">graph</span> <span class="n">node</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">visited</span>  
  <span class="k">else</span> <span class="n">node</span> <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">explore</span> <span class="n">acc</span> <span class="n">graph</span> <span class="n">n</span><span class="p">)</span> <span class="n">visited</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span><span class="p">)</span>  
  
<span class="k">let</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="n">start</span> <span class="o">=</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="p">(</span><span class="n">explore</span> <span class="bp">[]</span> <span class="n">graph</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">explore</code> function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">visited</code> parameter keeps track of the visited nodes to avoid visiting them again. The <code class="language-plaintext highlighter-rouge">dfs</code> function calls <code class="language-plaintext highlighter-rouge">explore</code> with an empty <code class="language-plaintext highlighter-rouge">visited</code> list and the starting node and returns the visited nodes in reverse order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">dfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"E"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"F"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"G"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"G"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)]</span>  
  
<span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="s2">"A"</span>  
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">visited</span>
</code></pre></div></div>

<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
B  
E  
C  
F  
G  
D  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start at the given starting node.</li>
  <li>Mark the node as visited and add it to the visited list.</li>
  <li>For each adjacent node that is not visited, recursively call <code class="language-plaintext highlighter-rouge">explore</code> with the visited list and the adjacent node.</li>
  <li>Return the visited list in reverse order.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type 'a graph = ('a * 'a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (fun acc n -&gt; explore acc graph n) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [("A", ["B"; "C"; "D"]); ("B", ["E"]); ("C", ["F"]); ("D", []); ("E", []); ("F", ["G"]); ("G", [])] let visited = dfs graph "A" let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.]]></summary></entry><entry><title type="html">Insertion Sort</title><link href="/algorithm/2023/11/20/insertion-sort.html" rel="alternate" type="text/html" title="Insertion Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/insertion-sort</id><content type="html" xml:base="/algorithm/2023/11/20/insertion-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.]]></summary></entry></feed>