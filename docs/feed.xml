<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-27T21:30:54+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Polynomial Interpolation</title><link href="/algorithm/2023/11/21/polynomial-interpolation.html" rel="alternate" type="text/html" title="Polynomial Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/polynomial-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/polynomial-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), …, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing.</p>

<h2 id="implementation">Implementation</h2>

<p>The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function <code class="language-plaintext highlighter-rouge">polint</code> takes three arguments - <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. The arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> represent the x-coordinates and y-coordinates of the n points, respectively. The variable <code class="language-plaintext highlighter-rouge">x</code> represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at <code class="language-plaintext highlighter-rouge">x</code> and the error estimate.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">polint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>
        <span class="s2">"polint requires that xs and ys have the same length, but xs length is %i \
         whereas ys length is %i"</span>
        <span class="n">n</span>
        <span class="n">m</span>
    <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dif</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">dift</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">dift</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">dif</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">dif</span> <span class="o">:=</span> <span class="n">dift</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">ho</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">hp</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">ho</span> <span class="o">-.</span> <span class="n">hp</span> <span class="k">in</span>
      <span class="k">assert</span> <span class="p">(</span><span class="n">den</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
      <span class="k">let</span> <span class="n">den</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">den</span> <span class="k">in</span>
      <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ho</span> <span class="o">*.</span> <span class="n">den</span><span class="p">;</span>
      <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">hp</span> <span class="o">*.</span> <span class="n">den</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="o">!</span><span class="n">ns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">then</span> <span class="n">dy</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span> <span class="p">(</span>
      <span class="n">dy</span> <span class="o">:=</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>
      <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">y</span> <span class="o">:=</span> <span class="o">!</span><span class="n">y</span> <span class="o">+.</span> <span class="o">!</span><span class="n">dy</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>
    <p>The function first checks if the lengths of the arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are the same. If they are not, an exception is raised.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created, which are initialized to the values in the array <code class="language-plaintext highlighter-rouge">ys</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is initialized to 0, which will be used to keep track of the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">dif</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first point in the array <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>A loop is executed over all the points in the array <code class="language-plaintext highlighter-rouge">xs</code>. For each point, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the point is computed. If this difference is less than the current value of <code class="language-plaintext highlighter-rouge">dif</code>, then the index of the point is stored in the variable <code class="language-plaintext highlighter-rouge">ns</code>, and the value of <code class="language-plaintext highlighter-rouge">dif</code> is updated to the new difference.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is initialized to the y-coordinate of the point in the array <code class="language-plaintext highlighter-rouge">ys</code> that is closest to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>A loop is executed n-1 times. In each iteration, two nested loops are executed over the remaining points in the array <code class="language-plaintext highlighter-rouge">xs</code>. The variable <code class="language-plaintext highlighter-rouge">m</code> is used to keep track of the number of iterations.</p>
  </li>
  <li>
    <p>In the inner loop, the variable <code class="language-plaintext highlighter-rouge">ho</code> is initialized to the difference between the current point and <code class="language-plaintext highlighter-rouge">x</code>, and the variable <code class="language-plaintext highlighter-rouge">hp</code> is initialized to the difference between the point m positions ahead and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">w</code> is initialized to the difference between the y-coordinates of the point m positions ahead and the current point.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is initialized to the difference between <code class="language-plaintext highlighter-rouge">ho</code> and <code class="language-plaintext highlighter-rouge">hp</code>. If <code class="language-plaintext highlighter-rouge">den</code> is 0, an exception is raised.</p>
  </li>
  <li>
    <p>The variable <code class="language-plaintext highlighter-rouge">den</code> is updated to <code class="language-plaintext highlighter-rouge">w/den</code>.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">c</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">ho*den</code>, and the value of <code class="language-plaintext highlighter-rouge">d</code> at the current index is updated to <code class="language-plaintext highlighter-rouge">hp*den</code>.</p>
  </li>
  <li>
    <p>If the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">n-m-1</code> multiplied by 2, then the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">c[ns+1]</code>. Otherwise, the value of <code class="language-plaintext highlighter-rouge">dy</code> is updated to <code class="language-plaintext highlighter-rouge">d[ns]</code>, and the index of the closest point to <code class="language-plaintext highlighter-rouge">x</code> is decremented by 1.</p>
  </li>
  <li>
    <p>The value of <code class="language-plaintext highlighter-rouge">y</code> is updated to <code class="language-plaintext highlighter-rouge">y+dy</code>.</p>
  </li>
  <li>
    <p>The function returns the tuple <code class="language-plaintext highlighter-rouge">(y, dy)</code>.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The polynomial interpolation algorithm has a time complexity of O(n^2), where n is the number of points. This is because the algorithm involves a nested loop over all the points in the input arrays. In the outer loop, the algorithm iterates n-1 times, and in the inner loop, it iterates over the remaining n-m-1 points. Therefore, the total number of iterations is given by the sum of the first n-1 positive integers, which is n(n-1)/2. Thus, the time complexity of the algorithm is O(n^2).</p>

<p>In terms of space complexity, the algorithm uses two arrays of size n to store the y-coordinates and two additional variables to store the interpolated value and the error estimate. Therefore, the space complexity of the algorithm is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Polynomial interpolation is a mathematical technique used to construct a polynomial function that passes through a given set of points. Given a set of n points (x_0, y_0), (x_1, y_1), …, (x_n-1, y_n-1), polynomial interpolation finds a unique polynomial of degree n-1 or less that passes through these points. This technique is widely used in various fields such as computer graphics, numerical analysis, and signal processing. Implementation The following code is an implementation of the polynomial interpolation algorithm in OCaml from Owl library. The function polint takes three arguments - xs, ys, and x. The arrays xs and ys represent the x-coordinates and y-coordinates of the n points, respectively. The variable x represents the point at which we want to evaluate the polynomial. The function returns a tuple of two values - the interpolated value of the polynomial at x and the error estimate.]]></summary></entry><entry><title type="html">Rational Interpolation</title><link href="/algorithm/2023/11/21/rational-interpolation.html" rel="alternate" type="text/html" title="Rational Interpolation" /><published>2023-11-21T05:00:00+02:00</published><updated>2023-11-21T05:00:00+02:00</updated><id>/algorithm/2023/11/21/rational-interpolation</id><content type="html" xml:base="/algorithm/2023/11/21/rational-interpolation.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.</p>

<h2 id="implementation">Implementation</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm is implemented in OCaml as shown below. The function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>. <code class="language-plaintext highlighter-rouge">xs</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the x-coordinates of the function, <code class="language-plaintext highlighter-rouge">ys</code> is an array of length <code class="language-plaintext highlighter-rouge">n</code> representing the y-coordinates of the function, and <code class="language-plaintext highlighter-rouge">x</code> is the point at which the function is to be approximated. The function returns a tuple containing the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ratint</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">x</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">ys</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>  
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span>  
      <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span>  
        <span class="s2">"ratint requires that xs and ys have the same length, but xs length is %i </span><span class="err">\</span><span class="s2">  
         whereas ys length is %i"</span>  
        <span class="n">n</span>  
        <span class="n">m</span>  
    <span class="k">in</span>  
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>  
  <span class="k">in</span>  
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>  
  <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">copy</span> <span class="n">ys</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">hh</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-25</span> <span class="k">in</span>  
  <span class="k">try</span>  
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>  
      <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">x</span> <span class="o">-.</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">in</span>  
      <span class="k">if</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>  
      <span class="k">then</span> <span class="p">(</span>  
        <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
        <span class="n">dy</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">.;</span>  
        <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span><span class="p">)</span>  
      <span class="k">else</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">hh</span>  
      <span class="k">then</span> <span class="p">(</span>  
        <span class="n">ns</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>  
        <span class="n">hh</span> <span class="o">:=</span> <span class="n">h</span><span class="p">;</span>  
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+.</span> <span class="n">eps</span><span class="p">)</span>  
    <span class="k">done</span><span class="p">;</span>  
    <span class="n">y</span> <span class="o">:=</span> <span class="n">ys</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">ns</span><span class="p">);</span>  
    <span class="n">ns</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ns</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  
    <span class="k">for</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="k">do</span>  
        <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-.</span> <span class="n">x</span><span class="p">)</span> <span class="o">*.</span> <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/.</span> <span class="n">h</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-.</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
        <span class="k">if</span> <span class="n">dd</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"Has a pole"</span><span class="p">;</span>  
        <span class="k">let</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/.</span> <span class="n">dd</span> <span class="k">in</span>  
        <span class="n">d</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*.</span> <span class="n">dd</span><span class="p">;</span>  
        <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">t</span> <span class="o">*.</span> <span class="n">dd</span>  
      <span class="k">done</span>  
    <span class="k">done</span><span class="p">;</span>  
    <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>  
  <span class="k">with</span>  
  <span class="o">|</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">FOUND</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">y</span><span class="o">,</span> <span class="o">!</span><span class="n">dy</span>  
  <span class="o">|</span> <span class="n">e</span>                   <span class="o">-&gt;</span> <span class="k">raise</span> <span class="n">e</span>  
</code></pre></div></div>

<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">ratint</code> function takes three arguments: <code class="language-plaintext highlighter-rouge">xs</code>, <code class="language-plaintext highlighter-rouge">ys</code>, and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> are obtained and verified to be equal. If they are not equal, an error is thrown.</p>
  </li>
  <li>
    <p>Two arrays <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> are created as copies of the <code class="language-plaintext highlighter-rouge">ys</code> array.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">hh</code> is initialized to the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and the first element of <code class="language-plaintext highlighter-rouge">xs</code>. This will be used to keep track of the smallest distance between <code class="language-plaintext highlighter-rouge">x</code> and an element of <code class="language-plaintext highlighter-rouge">xs</code>.</p>
  </li>
  <li>
    <p>Three variables <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">dy</code>, and <code class="language-plaintext highlighter-rouge">ns</code> are initialized to 0. <code class="language-plaintext highlighter-rouge">y</code> will be used to store the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">dy</code> will be used to store the derivative of the approximation at <code class="language-plaintext highlighter-rouge">x</code>, and <code class="language-plaintext highlighter-rouge">ns</code> will be used to keep track of the index of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">eps</code> is initialized to a small number. This will be used to prevent division by zero.</p>
  </li>
  <li>
    <p>A for loop is used to iterate over the <code class="language-plaintext highlighter-rouge">xs</code> array.</p>
  </li>
  <li>
    <p>For each <code class="language-plaintext highlighter-rouge">xs[i]</code>, the absolute difference between <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xs[i]</code> is computed and stored in a variable <code class="language-plaintext highlighter-rouge">h</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is equal to 0, then <code class="language-plaintext highlighter-rouge">ys[i]</code> is the exact value of the function at <code class="language-plaintext highlighter-rouge">x</code>, so <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[i]</code>, <code class="language-plaintext highlighter-rouge">dy</code> is set to 0, and an exception is raised to exit the loop.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">h</code> is less than <code class="language-plaintext highlighter-rouge">hh</code>, then <code class="language-plaintext highlighter-rouge">ns</code> is set to <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">hh</code> is set to <code class="language-plaintext highlighter-rouge">h</code>, and the <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i]</code> arrays are updated to <code class="language-plaintext highlighter-rouge">ys[i]</code>. This keeps track of the closest element of <code class="language-plaintext highlighter-rouge">xs</code> to <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>After the loop, <code class="language-plaintext highlighter-rouge">y</code> is set to <code class="language-plaintext highlighter-rouge">ys[ns]</code>, and <code class="language-plaintext highlighter-rouge">ns</code> is decremented by 1.</p>
  </li>
  <li>
    <p>Two nested for loops are used to iterate over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays.</p>
  </li>
  <li>
    <p>For each iteration, <code class="language-plaintext highlighter-rouge">m</code> represents the current iteration of the outer loop, and <code class="language-plaintext highlighter-rouge">i</code> represents the current iteration of the inner loop.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">w</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">c[i]</code> and <code class="language-plaintext highlighter-rouge">d[i-1]</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">h</code> is computed as the difference between <code class="language-plaintext highlighter-rouge">xs[i+m-1]</code> and <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">t</code> is computed as <code class="language-plaintext highlighter-rouge">(xs[i-1] - x) * d[i-1] / h</code>.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">t - c[i]</code>.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">dd</code> is equal to 0, then the function has a pole, and an exception is thrown.</p>
  </li>
  <li>
    <p>A variable <code class="language-plaintext highlighter-rouge">dd</code> is computed as <code class="language-plaintext highlighter-rouge">w / dd</code>.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">d[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">c[i] * dd</code>, and the <code class="language-plaintext highlighter-rouge">c[i-1]</code> array is updated to <code class="language-plaintext highlighter-rouge">t * dd</code>.</p>
  </li>
  <li>
    <p>After the loops, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">dy</code> are returned as the approximation and derivative of the function at <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>If any exceptions are raised during the computation, they are rethrown.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The <code class="language-plaintext highlighter-rouge">ratint</code> algorithm has a time complexity of O(n^2), where n is the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code>.</p>

<p>This is because the algorithm has two nested loops, each iterating over the <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">d</code> arrays. The outer loop iterates <code class="language-plaintext highlighter-rouge">n-1</code> times, and the inner loop iterates <code class="language-plaintext highlighter-rouge">n-m</code> times, where <code class="language-plaintext highlighter-rouge">m</code> is the current iteration of the outer loop. This gives a total of <code class="language-plaintext highlighter-rouge">(n-1) + (n-2) + ... + 1</code> iterations for the outer loop, which is equal to <code class="language-plaintext highlighter-rouge">n(n-1)/2</code>. The inner loop has a similar number of iterations, giving a total of <code class="language-plaintext highlighter-rouge">n(n-1)^2/2</code> iterations for both loops combined.</p>

<p>Therefore, the time complexity of the algorithm is O(n^2). This means that as the length of the input arrays <code class="language-plaintext highlighter-rouge">xs</code> and <code class="language-plaintext highlighter-rouge">ys</code> increases, the time taken by the algorithm to compute the approximation of the function at <code class="language-plaintext highlighter-rouge">x</code> and its derivative also increases quadratically.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Rational interpolation is a numerical method used to approximate a function using a rational function. The algorithm is used in various fields including engineering, physics, and finance.]]></summary></entry><entry><title type="html">Topological Sort</title><link href="/algorithm/2023/11/21/topological-sort.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2023-11-21T04:00:00+02:00</published><updated>2023-11-21T04:00:00+02:00</updated><id>/algorithm/2023/11/21/topological-sort</id><content type="html" xml:base="/algorithm/2023/11/21/topological-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of topological sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">topological_sort</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="kt">array</span><span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">graph</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">false</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>  
  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">dfs</span> <span class="p">(</span><span class="n">u</span><span class="o">:</span> <span class="kt">int</span><span class="p">)</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span>  
    <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="bp">true</span><span class="p">;</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">v</span><span class="p">)</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>  
    <span class="n">stack</span> <span class="o">:=</span> <span class="n">u</span> <span class="o">::</span> <span class="o">!</span><span class="n">stack</span>  
  <span class="k">in</span>  
  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">if</span> <span class="n">not</span> <span class="n">visited</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">then</span> <span class="n">dfs</span> <span class="n">i</span>  
  <span class="k">done</span><span class="p">;</span>  
  
  <span class="o">!</span><span class="n">stack</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">graph</code> is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order.  Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">courses</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"C1"</span><span class="p">;</span> <span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">;</span> <span class="s2">"C4"</span><span class="p">;</span> <span class="s2">"C5"</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">prerequisites</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"C1"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C2"</span><span class="p">;</span> <span class="s2">"C3"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C2"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C3"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C4"</span><span class="p">]);</span> <span class="p">(</span><span class="s2">"C4"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C5"</span><span class="p">])]</span>  
  
<span class="k">let</span> <span class="n">course_graph</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">courses</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">[]</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">find_index</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="n">courses</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">index</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Course not found"</span>
  <span class="k">in</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">c</span><span class="o">,</span> <span class="n">prereqs</span><span class="p">)</span> <span class="o">-&gt;</span>  
    <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="n">index_of_course</span> <span class="n">c</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">vs</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">index_of_course</span> <span class="n">prereqs</span> <span class="k">in</span>  
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">v</span> <span class="o">::</span> <span class="n">graph</span><span class="o">.</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="n">vs</span>  
  <span class="p">)</span> <span class="n">prerequisites</span><span class="p">;</span>  
  <span class="n">graph</span>  
  
<span class="k">let</span> <span class="n">course_order</span> <span class="o">=</span> <span class="n">topological_sort</span> <span class="n">course_graph</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">courses</span> <span class="n">i</span><span class="p">)</span>

<span class="k">let</span> <span class="n">print_course_order</span> <span class="n">course_order</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">course</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%s "</span> <span class="n">course</span><span class="p">)</span> <span class="n">course_order</span><span class="p">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">print_course_order</span> <span class="n">course_order</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an array <code class="language-plaintext highlighter-rouge">visited</code> of size <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the number of nodes in the graph. Initialize all elements to <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>Create an empty stack <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Define a recursive function <code class="language-plaintext highlighter-rouge">dfs</code> that takes a node <code class="language-plaintext highlighter-rouge">u</code> as input.</li>
  <li>Mark <code class="language-plaintext highlighter-rouge">u</code> as visited by setting <code class="language-plaintext highlighter-rouge">visited.(u)</code> to <code class="language-plaintext highlighter-rouge">true</code>.</li>
  <li>For each neighbor <code class="language-plaintext highlighter-rouge">v</code> of <code class="language-plaintext highlighter-rouge">u</code> in the graph, if <code class="language-plaintext highlighter-rouge">v</code> has not been visited, recursively call <code class="language-plaintext highlighter-rouge">dfs v</code>.</li>
  <li>Push <code class="language-plaintext highlighter-rouge">u</code> onto the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
  <li>Loop through all nodes in the graph. If a node has not been visited, call <code class="language-plaintext highlighter-rouge">dfs</code> on it.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">stack</code>.</li>
</ol>

<p>The algorithm works by performing a depth-first search (DFS) on the graph. When a node is finished being explored, it is pushed onto the stack. Since a DAG has no cycles, the nodes can be ordered in reverse order of their finishing times, which gives a valid topological order.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of topological sort is O(V+E), where V is the number of vertices and E is the number of edges in the graph. This is because each vertex and edge is visited once during the DFS traversal. The space complexity is also O(V+E), since the adjacency list takes up O(V+E) space and the stack can contain all vertices in the worst case.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Topological sort is a sorting algorithm used to sort a directed acyclic graph (DAG) in a specific order. It is commonly used in many applications such as task scheduling, dependency resolution, and data processing. Implementation Here is an implementation of topological sort in OCaml: let topological_sort (graph: int list array) : int list = let n = Array.length graph in let visited = Array.make n false in let stack = ref [] in let rec dfs (u: int) : unit = visited.(u) &lt;- true; List.iter (fun v -&gt; if not visited.(v) then dfs v) graph.(u); stack := u :: !stack in for i = 0 to n - 1 do if not visited.(i) then dfs i done; !stack Here, graph is a representation of the DAG in the form of an adjacency list. The function returns a list of nodes in topological order. Here is an example.]]></summary></entry><entry><title type="html">Brent’s Algorithm</title><link href="/algorithm/2023/11/21/brents-algorithm.html" rel="alternate" type="text/html" title="Brent’s Algorithm" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/brents-algorithm</id><content type="html" xml:base="/algorithm/2023/11/21/brents-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Brent’s algorithm in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">power</span> <span class="n">lam</span> <span class="n">tortoise</span> <span class="n">hare</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">hare</span> <span class="k">then</span> <span class="n">lam</span>  
    <span class="k">else</span> <span class="k">if</span> <span class="n">power</span> <span class="o">=</span> <span class="n">lam</span> <span class="k">then</span> <span class="n">loop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="mi">0</span> <span class="n">hare</span> <span class="n">hare</span>  
    <span class="k">else</span> <span class="n">loop</span> <span class="n">power</span> <span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tortoise</span> <span class="p">(</span><span class="n">f</span> <span class="n">hare</span><span class="p">)</span>  
  <span class="k">in</span> <span class="n">loop</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x0</span> <span class="p">(</span><span class="n">f</span> <span class="n">x0</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function takes two arguments: <code class="language-plaintext highlighter-rouge">f</code>, a function that takes a value and returns the next value in the sequence, and <code class="language-plaintext highlighter-rouge">x0</code>, the initial value in the sequence. The function returns the length of the cycle in the sequence.</p>

<p>Here is an example of how to use the <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">23</span>  
<span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="k">let</span> <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span>  
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">f</code> is a function that generates a sequence of values using the formula <code class="language-plaintext highlighter-rouge">x^2 + 1 (mod 23)</code>, <code class="language-plaintext highlighter-rouge">x0</code> is the initial value of the sequence, and <code class="language-plaintext highlighter-rouge">cycle_length</code> is the length of the cycle in the sequence.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before.</p>

<p>At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence.</p>

<p>The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time.</p>

<p>The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables.</p>

<p>Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/fisher-yates.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/fisher-yates</id><content type="html" xml:base="/algorithm/2023/11/21/fisher-yates.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book “The Art of Computer Programming”. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of the Fisher-Yates shuffle in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fisher_yates_shuffle</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>  
    <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span>  
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">in</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
    <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">tmp</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="n">arr</span>  
</code></pre></div></div>

<p>This function takes an array of elements and returns a shuffled version of the array. It works by iterating through the array from the last element to the first. For each element, it picks a random index between 0 and the current index, inclusive, and swaps the element at that index with the current element.</p>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">deck</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="s2">"Ace of Spades"</span><span class="p">;</span> <span class="s2">"2 of Spades"</span><span class="p">;</span> <span class="s2">"3 of Spades"</span><span class="p">;</span> <span class="s2">"King of Diamonds"</span> <span class="o">|</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">shuffled_deck</span> <span class="o">=</span> <span class="n">fisher_yates_shuffle</span> <span class="n">deck</span>  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">x</span><span class="p">)</span> <span class="n">shuffled_deck</span>  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start by initializing a variable <code class="language-plaintext highlighter-rouge">n</code> to the length of the input array.</li>
  <li>Iterate through the array from the last element to the first using a for loop. For each element at index <code class="language-plaintext highlighter-rouge">i</code>:</li>
  <li>Generate a random integer <code class="language-plaintext highlighter-rouge">j</code> between 0 and <code class="language-plaintext highlighter-rouge">i</code> inclusive using the <code class="language-plaintext highlighter-rouge">Random.int</code> function.</li>
  <li>Swap the element at index <code class="language-plaintext highlighter-rouge">j</code> with the element at index <code class="language-plaintext highlighter-rouge">i</code>.</li>
  <li>Continue iterating until all elements have been shuffled.</li>
  <li>Return the shuffled array.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Fisher-Yates shuffle is O(n), where n is the number of elements in the input array. This is because the algorithm iterates through the array once and performs a constant amount of work for each element.</p>

<p>The space complexity of the Fisher-Yates shuffle is O(1), because the algorithm shuffles the input array in place and does not require any additional memory allocation.</p>

<p>Overall, the Fisher-Yates shuffle is a simple and efficient algorithm for shuffling collections of elements.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Fisher-Yates shuffle, also known as the Knuth shuffle, is an algorithm used to randomly shuffle a collection of elements. It was first described by Ronald Fisher and Frank Yates in 1938 and later popularized by Donald Knuth in his book “The Art of Computer Programming”. The Fisher-Yates shuffle is widely used in computer science, particularly in applications such as games, music playlists, and cryptography. Implementation Here is an implementation of the Fisher-Yates shuffle in OCaml: let fisher_yates_shuffle arr = let n = Array.length arr in for i = n - 1 downto 1 do let j = Random.int (i + 1) in let tmp = arr.(j) in arr.(j) &lt;- arr.(i); arr.(i) &lt;- tmp done; arr]]></summary></entry><entry><title type="html">Breadth-First Search</title><link href="/algorithm/2023/11/21/breadth-first-search.html" rel="alternate" type="text/html" title="Breadth-First Search" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/breadth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/breadth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of BFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">bfs</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">queue</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">queue</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">visited</span>
    <span class="o">|</span> <span class="n">node</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span>
          <span class="n">explore</span> <span class="n">visited</span> <span class="n">rest</span>
        <span class="k">else</span>
          <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">new_nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">n</span> <span class="n">visited</span><span class="p">))</span> <span class="n">neighbors</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">updated_queue</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">@</span> <span class="n">new_nodes</span> <span class="k">in</span>
          <span class="n">explore</span> <span class="p">(</span><span class="n">visited</span> <span class="o">@</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="n">updated_queue</span>
  <span class="k">in</span> <span class="n">explore</span> <span class="bp">[]</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> parameter is a list of tuples, where the first element is a node and the second element is a list of its neighboring nodes. The <code class="language-plaintext highlighter-rouge">start</code> parameter is the node where the search begins. The function returns a list of nodes visited in breadth-first order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">bfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="p">[</span>
    <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
  <span class="p">]</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span> <span class="n">graph</span> <span class="s2">"A"</span> <span class="c">(* ["A"; "B"; "C"; "D"; "E"; "F"] *)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an empty <code class="language-plaintext highlighter-rouge">visited</code> list and a <code class="language-plaintext highlighter-rouge">queue</code> with the starting node in it.</li>
  <li>While the <code class="language-plaintext highlighter-rouge">queue</code> is not empty, take the first node from the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has already been visited, skip it and continue to the next node in the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has not been visited, add it to the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
  <li>Get the list of neighboring nodes for the current node from the <code class="language-plaintext highlighter-rouge">graph</code>.</li>
  <li>Filter out the nodes that have already been visited.</li>
  <li>Add the remaining nodes to the end of the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>Repeat steps 2-7 until the <code class="language-plaintext highlighter-rouge">queue</code> is empty.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices and <code class="language-plaintext highlighter-rouge">|E|</code> is the number of edges in the graph. This is because BFS visits each vertex and edge exactly once.</p>

<p>The space complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices in the graph. This is because BFS uses a queue to store the nodes to be visited, and the maximum size of the queue is the number of vertices at the maximum depth of the graph. In the worst case, this is all the vertices, so the space complexity is <code class="language-plaintext highlighter-rouge">O(|V|)</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/depth-first-search.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T01:00:00+02:00</published><updated>2023-11-21T01:00:00+02:00</updated><id>/algorithm/2023/11/21/depth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/depth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of DFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>  
  
<span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">graph</span> <span class="n">node</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">visited</span>  
  <span class="k">else</span> <span class="n">node</span> <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">explore</span> <span class="n">acc</span> <span class="n">graph</span> <span class="n">n</span><span class="p">)</span> <span class="n">visited</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span><span class="p">)</span>  
  
<span class="k">let</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="n">start</span> <span class="o">=</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="p">(</span><span class="n">explore</span> <span class="bp">[]</span> <span class="n">graph</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">explore</code> function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">visited</code> parameter keeps track of the visited nodes to avoid visiting them again. The <code class="language-plaintext highlighter-rouge">dfs</code> function calls <code class="language-plaintext highlighter-rouge">explore</code> with an empty <code class="language-plaintext highlighter-rouge">visited</code> list and the starting node and returns the visited nodes in reverse order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">dfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"E"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"F"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"G"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"G"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)]</span>  
  
<span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="s2">"A"</span>  
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">visited</span>
</code></pre></div></div>

<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
B  
E  
C  
F  
G  
D  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start at the given starting node.</li>
  <li>Mark the node as visited and add it to the visited list.</li>
  <li>For each adjacent node that is not visited, recursively call <code class="language-plaintext highlighter-rouge">explore</code> with the visited list and the adjacent node.</li>
  <li>Return the visited list in reverse order.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type 'a graph = ('a * 'a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (fun acc n -&gt; explore acc graph n) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [("A", ["B"; "C"; "D"]); ("B", ["E"]); ("C", ["F"]); ("D", []); ("E", []); ("F", ["G"]); ("G", [])] let visited = dfs graph "A" let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.]]></summary></entry><entry><title type="html">Insertion Sort</title><link href="/algorithm/2023/11/20/insertion-sort.html" rel="alternate" type="text/html" title="Insertion Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/insertion-sort</id><content type="html" xml:base="/algorithm/2023/11/20/insertion-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.]]></summary></entry><entry><title type="html">Radix Sort</title><link href="/algorithm/2023/11/20/radix-sort.html" rel="alternate" type="text/html" title="Radix Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/radix-sort</id><content type="html" xml:base="/algorithm/2023/11/20/radix-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of radix sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">arr</span> <span class="n">exp</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span> <span class="k">else</span>  
      <span class="k">let</span> <span class="n">zeroes</span><span class="o">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
      <span class="n">loop</span> <span class="n">zeroes</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">loop</span> <span class="n">ones</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
  <span class="k">in</span>  
  <span class="n">loop</span> <span class="n">arr</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">int_of_float</span> <span class="p">(</span><span class="n">log10</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))))</span> <span class="mi">0</span> <span class="n">arr</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">radix_sort</code> takes in an array of integers <code class="language-plaintext highlighter-rouge">arr</code> and returns a sorted array. The <code class="language-plaintext highlighter-rouge">loop</code> function recursively sorts the array by partitioning it into two subarrays based on the value of the <code class="language-plaintext highlighter-rouge">exp</code>-th bit (starting from the most significant bit). The <code class="language-plaintext highlighter-rouge">exp</code> parameter is initially set to the maximum number of digits in any element of the array. The function <code class="language-plaintext highlighter-rouge">log10</code> is used to calculate the number of digits in each element.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum number of digits in any element of the array.</li>
  <li>For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit.</li>
  <li>Recursively sort each subarray by repeating step 2 with the next bit position.</li>
  <li>Concatenate the sorted subarrays to get the final sorted array.</li>
</ol>

<p>For example, let’s say we have the following array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 45, 75, 90, 802, 24, 2, 66]  
</code></pre></div></div>

<p>The maximum number of digits is 3, so we start by partitioning the array based on the third bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 90, 802, 2, 24, 45, 75, 66]  
</code></pre></div></div>

<p>We then recursively sort each subarray by partitioning based on the second bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[802, 2, 24, 45, 66, 170, 75, 90]  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<p>Finally, we concatenate the sorted subarrays to get the final sorted array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k).</p>

<p>In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.]]></summary></entry><entry><title type="html">Merge Sort</title><link href="/algorithm/2023/11/20/mergesort.html" rel="alternate" type="text/html" title="Merge Sort" /><published>2023-11-20T23:01:00+02:00</published><updated>2023-11-20T23:01:00+02:00</updated><id>/algorithm/2023/11/20/mergesort</id><content type="html" xml:base="/algorithm/2023/11/20/mergesort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).]]></summary></entry></feed>