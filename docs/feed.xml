<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-28T22:27:42+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Dijkstra Algorithm</title><link href="/algorithm/2023/11/23/dijkstra-algorithm.html" rel="alternate" type="text/html" title="Dijkstra Algorithm" /><published>2023-11-23T00:00:00+02:00</published><updated>2023-11-23T00:00:00+02:00</updated><id>/algorithm/2023/11/23/dijkstra-algorithm</id><content type="html" xml:base="/algorithm/2023/11/23/dijkstra-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Dijkstra algorithm is a shortest path algorithm that is used to find the shortest path between two nodes in a graph. It was conceived by Edsger W. Dijkstra in 1956 and published three years later. The algorithm is used in various applications such as transportation networks, computer networks, and social networks.</p>

<h2 id="implementation">Implementation</h2>
<p>The Dijkstra algorithm is implemented in OCaml as follows:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">list_vertices</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="p">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="p">)</span><span class="o">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">b</span> <span class="n">acc</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">b</span><span class="o">::</span><span class="n">acc</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">a</span> <span class="n">acc</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">a</span><span class="o">::</span><span class="n">acc</span> <span class="k">in</span>
    <span class="n">acc</span>
  <span class="p">)</span> <span class="bp">[]</span> <span class="n">graph</span>

<span class="k">let</span> <span class="n">neighbors</span> <span class="n">v</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="p">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="p">)</span><span class="o">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v</span> <span class="k">then</span> <span class="p">(</span><span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="p">)</span><span class="o">::</span><span class="n">acc</span> <span class="k">else</span> <span class="n">acc</span>
  <span class="p">)</span> <span class="bp">[]</span>

<span class="k">let</span> <span class="n">remove_from</span> <span class="n">v</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">function</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"remove_from"</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span> <span class="k">then</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev_append</span> <span class="n">acc</span> <span class="n">xs</span> <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span> <span class="n">xs</span>
  <span class="k">in</span> <span class="n">aux</span> <span class="bp">[]</span> <span class="n">lst</span>

<span class="k">let</span> <span class="n">with_smallest_distance</span> <span class="n">q</span> <span class="n">dist</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">q</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">distance</span> <span class="n">v</span> <span class="o">=</span> <span class="k">function</span>
      <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span>
          <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">dist</span> <span class="n">x</span> <span class="k">in</span>
          <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">distance</span>
          <span class="k">then</span> <span class="n">aux</span> <span class="n">d</span> <span class="n">x</span> <span class="n">xs</span>
          <span class="k">else</span> <span class="n">aux</span> <span class="n">distance</span> <span class="n">v</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span> <span class="n">distance</span><span class="p">)</span>
      <span class="k">in</span>
      <span class="n">aux</span> <span class="p">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">dist</span> <span class="n">x</span><span class="p">)</span> <span class="n">x</span> <span class="n">xs</span>

<span class="k">let</span> <span class="n">dijkstra</span> <span class="n">max_val</span> <span class="n">zero</span> <span class="n">add</span> <span class="n">graph</span> <span class="n">source</span> <span class="n">target</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">vertices</span> <span class="o">=</span> <span class="n">list_vertices</span> <span class="n">graph</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dist_between</span> <span class="n">u</span> <span class="n">v</span> <span class="o">=</span>
    <span class="k">try</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="p">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="p">)</span> <span class="n">graph</span>
    <span class="k">with</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">zero</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">dist</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">previous</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span>                  <span class="c">(* initializations *)</span>
    <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">dist</span> <span class="n">v</span> <span class="n">max_val</span>         <span class="c">(* unknown distance function from source to v *)</span>
  <span class="p">)</span> <span class="n">vertices</span><span class="p">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">replace</span> <span class="n">dist</span> <span class="n">source</span> <span class="n">zero</span><span class="p">;</span>    <span class="c">(* distance from source to source *)</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">function</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="o">|</span> <span class="n">q</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">u</span><span class="o">,</span> <span class="n">dist_u</span> <span class="o">=</span>
        <span class="n">with_smallest_distance</span> <span class="n">q</span> <span class="n">dist</span> <span class="k">in</span>   <span class="c">(* vertex in q with smallest distance in dist *)</span>
      <span class="k">if</span> <span class="n">dist_u</span> <span class="o">=</span> <span class="n">max_val</span> <span class="k">then</span>
        <span class="n">failwith</span> <span class="s2">"vertices inaccessible"</span><span class="p">;</span>  <span class="c">(* all remaining vertices are inaccessible from source *)</span>
      <span class="k">if</span> <span class="n">u</span> <span class="o">=</span> <span class="n">target</span> <span class="k">then</span> <span class="bp">()</span> <span class="k">else</span> <span class="k">begin</span>
        <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">remove_from</span> <span class="n">u</span> <span class="n">q</span> <span class="k">in</span>
        <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">v</span> <span class="n">q</span> <span class="k">then</span> <span class="k">begin</span>
            <span class="k">let</span> <span class="n">alt</span> <span class="o">=</span> <span class="n">add</span> <span class="n">dist_u</span> <span class="p">(</span><span class="n">dist_between</span> <span class="n">u</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">dist_v</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">dist</span> <span class="n">v</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">alt</span> <span class="o">&lt;</span> <span class="n">dist_v</span> <span class="k">then</span> <span class="k">begin</span>       <span class="c">(* relax (u,v,a) *)</span>
              <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">replace</span> <span class="n">dist</span> <span class="n">v</span> <span class="n">alt</span><span class="p">;</span>
              <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">replace</span> <span class="n">previous</span> <span class="n">v</span> <span class="n">u</span><span class="p">;</span>  <span class="c">(* previous node in optimal path from source *)</span>
            <span class="k">end</span>
          <span class="k">end</span>
        <span class="p">)</span> <span class="p">(</span><span class="n">neighbors</span> <span class="n">u</span> <span class="n">graph</span><span class="p">);</span>
        <span class="n">loop</span> <span class="n">q</span>
      <span class="k">end</span>
  <span class="k">in</span>
  <span class="n">loop</span> <span class="n">vertices</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">target</span> <span class="k">in</span>
  <span class="k">while</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">mem</span> <span class="n">previous</span> <span class="o">!</span><span class="n">u</span> <span class="k">do</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">!</span><span class="n">u</span> <span class="o">::</span> <span class="o">!</span><span class="n">s</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">:=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">previous</span> <span class="o">!</span><span class="n">u</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="p">(</span><span class="n">source</span> <span class="o">::</span> <span class="o">!</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">dijkstra</code> takes in a graph represented as a list of edges and their weights, a maximum value, a zero value, an addition function, a source node, and a target node. It returns a list of nodes representing the shortest path from the source to the target.</p>

<p>Here is how to call the function.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
    <span class="p">[</span> <span class="p">(</span><span class="s2">"a"</span><span class="o">,</span> <span class="s2">"b"</span><span class="p">)</span><span class="o">,</span> <span class="mi">7</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"a"</span><span class="o">,</span> <span class="s2">"c"</span><span class="p">)</span><span class="o">,</span> <span class="mi">9</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"a"</span><span class="o">,</span> <span class="s2">"f"</span><span class="p">)</span><span class="o">,</span> <span class="mi">14</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"b"</span><span class="o">,</span> <span class="s2">"c"</span><span class="p">)</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"b"</span><span class="o">,</span> <span class="s2">"d"</span><span class="p">)</span><span class="o">,</span> <span class="mi">15</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"c"</span><span class="o">,</span> <span class="s2">"d"</span><span class="p">)</span><span class="o">,</span> <span class="mi">11</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"c"</span><span class="o">,</span> <span class="s2">"f"</span><span class="p">)</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"d"</span><span class="o">,</span> <span class="s2">"e"</span><span class="p">)</span><span class="o">,</span> <span class="mi">6</span><span class="p">;</span>
      <span class="p">(</span><span class="s2">"e"</span><span class="o">,</span> <span class="s2">"f"</span><span class="p">)</span><span class="o">,</span> <span class="mi">9</span><span class="p">;</span> <span class="p">]</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dijkstra</span> <span class="n">max_int</span> <span class="mi">0</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">graph</span> <span class="s2">"a"</span> <span class="s2">"e"</span> <span class="k">in</span>
  <span class="n">print_endline</span> <span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">" -&gt; "</span> <span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">list_vertices</code> takes in the graph and returns a list of all the vertices in the graph. It does this by iterating over each edge in the graph and adding its endpoints to the list of vertices if they are not already in it.</p>
  </li>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">neighbors</code> takes in a vertex <code class="language-plaintext highlighter-rouge">v</code> and returns a list of its neighbors and their distances. It does this by iterating over each edge in the graph and adding the neighbor of <code class="language-plaintext highlighter-rouge">v</code> and its distance to the list if <code class="language-plaintext highlighter-rouge">v</code> is the start point of the edge.</p>
  </li>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">remove_from</code> takes in a vertex <code class="language-plaintext highlighter-rouge">v</code> and a list <code class="language-plaintext highlighter-rouge">lst</code> and returns a new list with <code class="language-plaintext highlighter-rouge">v</code> removed from it. It does this by recursively iterating over the list and adding each element to a new list except for <code class="language-plaintext highlighter-rouge">v</code>.</p>
  </li>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">with_smallest_distance</code> takes in a list of vertices <code class="language-plaintext highlighter-rouge">q</code> and a hash table of distances <code class="language-plaintext highlighter-rouge">dist</code> and returns the vertex in <code class="language-plaintext highlighter-rouge">q</code> with the smallest distance in <code class="language-plaintext highlighter-rouge">dist</code>. It does this by recursively iterating over the list and comparing the distance of each vertex to the current smallest distance.</p>
  </li>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">dijkstra</code> initializes the hash table of distances <code class="language-plaintext highlighter-rouge">dist</code> and the hash table of previous vertices <code class="language-plaintext highlighter-rouge">previous</code>. It then iterates over each vertex in the graph and adds it to <code class="language-plaintext highlighter-rouge">dist</code> with a distance of <code class="language-plaintext highlighter-rouge">max_val</code> except for the source node, which is added with a distance of <code class="language-plaintext highlighter-rouge">zero</code>. It then enters a loop where it selects the vertex in <code class="language-plaintext highlighter-rouge">q</code> with the smallest distance in <code class="language-plaintext highlighter-rouge">dist</code> using <code class="language-plaintext highlighter-rouge">with_smallest_distance</code>. If the distance is <code class="language-plaintext highlighter-rouge">max_val</code>, it means all remaining vertices are inaccessible from the source, so it throws an error. If the selected vertex is the target node, it exits the loop. Otherwise, it removes the selected vertex from <code class="language-plaintext highlighter-rouge">q</code> and iterates over its neighbors. For each neighbor, it computes a new distance <code class="language-plaintext highlighter-rouge">alt</code> from the source to the neighbor through the selected vertex and updates <code class="language-plaintext highlighter-rouge">dist</code> and <code class="language-plaintext highlighter-rouge">previous</code> if <code class="language-plaintext highlighter-rouge">alt</code> is smaller than the current distance in <code class="language-plaintext highlighter-rouge">dist</code>. It then continues the loop with the updated <code class="language-plaintext highlighter-rouge">q</code>.</p>
  </li>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">dijkstra</code> ends by constructing the shortest path from the source to the target using the hash table of previous vertices <code class="language-plaintext highlighter-rouge">previous</code>. It starts at the target and iteratively adds the previous vertex to the path until it reaches the source.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Dijkstra’s algorithm is O((E+V)logV), where E is the number of edges and V is the number of vertices in the graph. This is because the algorithm iterates over each vertex once and each edge once, and it uses a priority queue to select the vertex with the smallest distance in each iteration, which takes logV time. The space complexity is O(V+E) because it stores the hash tables of distances and previous vertices, which have a size proportional to the number of vertices and edges in the graph.</p>

<p>In terms of the input parameters, the time complexity of <code class="language-plaintext highlighter-rouge">list_vertices</code> is O(E), where E is the number of edges in the graph, because it iterates over each edge once. The time complexity of <code class="language-plaintext highlighter-rouge">neighbors</code> is also O(E), because it iterates over each edge once. The time complexity of <code class="language-plaintext highlighter-rouge">remove_from</code> is O(n), where n is the length of the input list, because it iterates over each element once. The time complexity of <code class="language-plaintext highlighter-rouge">with_smallest_distance</code> is O(V), where V is the number of vertices in the input list, because it iterates over each vertex once. Therefore, the overall time complexity of the Dijkstra algorithm is dominated by the time complexity of the main loop, which is O((E+V)logV).</p>

<p>In terms of the space complexity, the hash tables used in the algorithm have a size proportional to the number of vertices in the graph, which is O(V). The priority queue used in <code class="language-plaintext highlighter-rouge">with_smallest_distance</code> also has a size proportional to the number of vertices, which is O(V). Therefore, the overall space complexity of the algorithm is O(V+E).</p>

<p>Overall, the Dijkstra algorithm is an efficient algorithm for finding the shortest path between two nodes in a graph. Its time complexity is proportional to the number of edges and vertices in the graph, and its space complexity is proportional to the number of vertices.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Dijkstra algorithm is a shortest path algorithm that is used to find the shortest path between two nodes in a graph. It was conceived by Edsger W. Dijkstra in 1956 and published three years later. The algorithm is used in various applications such as transportation networks, computer networks, and social networks. Implementation The Dijkstra algorithm is implemented in OCaml as follows: ```ocaml let list_vertices graph = List.fold_left (fun acc ((a, b), _) -&gt; let acc = if List.mem b acc then acc else b::acc in let acc = if List.mem a acc then acc else a::acc in acc ) [] graph]]></summary></entry><entry><title type="html">Caesar Cipher</title><link href="/algorithm/2023/11/22/caesar-cipher.html" rel="alternate" type="text/html" title="Caesar Cipher" /><published>2023-11-22T14:00:00+02:00</published><updated>2023-11-22T14:00:00+02:00</updated><id>/algorithm/2023/11/22/caesar-cipher</id><content type="html" xml:base="/algorithm/2023/11/22/caesar-cipher.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Caesar cipher is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is shifted a certain number of places down the alphabet. For example, with a shift of 1, A would be replaced by B, B would become C, and so on. The method is apparently named after Julius Caesar, who used it to communicate with his officials.</p>

<h2 id="implementation">Implementation</h2>
<p>The Caesar cipher is implemented in OCaml as follows:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">islower</span> <span class="n">c</span> <span class="o">=</span>
  <span class="n">c</span> <span class="o">&gt;=</span> <span class="k">'</span><span class="n">a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="k">'</span><span class="n">z'</span>

<span class="k">let</span> <span class="n">isupper</span> <span class="n">c</span> <span class="o">=</span>
  <span class="n">c</span> <span class="o">&gt;=</span> <span class="k">'</span><span class="nc">A'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="k">'</span><span class="nc">Z'</span>

<span class="k">let</span> <span class="n">rot</span> <span class="n">x</span> <span class="n">str</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">upchars</span> <span class="o">=</span> <span class="s2">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>
  <span class="ow">and</span> <span class="n">lowchars</span> <span class="o">=</span> <span class="s2">"abcdefghijklmnopqrstuvwxyz"</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">decal</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">decal</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">26</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">decal</span> <span class="n">x</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">26</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">decal_up</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">int_of_char</span> <span class="k">'</span><span class="nc">A'</span><span class="p">)</span>
  <span class="ow">and</span> <span class="n">decal_low</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">int_of_char</span> <span class="k">'</span><span class="n">a'</span><span class="p">)</span> <span class="k">in</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">islower</span> <span class="n">c</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="p">((</span><span class="n">int_of_char</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">decal_low</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">26</span> <span class="k">in</span>
      <span class="n">lowchars</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">isupper</span> <span class="n">c</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="p">((</span><span class="n">int_of_char</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">decal_up</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">26</span> <span class="k">in</span>
      <span class="n">upchars</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">c</span>
  <span class="p">)</span> <span class="n">str</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">rot</code> function takes an integer <code class="language-plaintext highlighter-rouge">x</code> and a string <code class="language-plaintext highlighter-rouge">str</code> as arguments. The integer <code class="language-plaintext highlighter-rouge">x</code> represents the number of positions to shift each letter in the string <code class="language-plaintext highlighter-rouge">str</code>. The function returns a new string that is the result of applying the Caesar cipher with the given shift.</p>

<p>Here is how to use the function.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">orig</span> <span class="o">=</span> <span class="s2">"The five boxing wizards jump quickly"</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">enciphered</span> <span class="o">=</span> <span class="n">rot</span> <span class="n">key</span> <span class="n">orig</span> <span class="k">in</span>
  <span class="n">print_endline</span> <span class="n">enciphered</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">deciphered</span> <span class="o">=</span> <span class="n">rot</span> <span class="p">(</span><span class="o">-</span> <span class="n">key</span><span class="p">)</span> <span class="n">enciphered</span> <span class="k">in</span>
  <span class="n">print_endline</span> <span class="n">deciphered</span><span class="p">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"equal: %b</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="n">orig</span> <span class="o">=</span> <span class="n">deciphered</span><span class="p">)</span>
<span class="p">;;</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-Step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">islower</code> function checks if a given character is a lowercase letter.</li>
  <li>The <code class="language-plaintext highlighter-rouge">isupper</code> function checks if a given character is an uppercase letter.</li>
  <li>The <code class="language-plaintext highlighter-rouge">rot</code> function initializes two strings: <code class="language-plaintext highlighter-rouge">upchars</code> containing all uppercase letters and <code class="language-plaintext highlighter-rouge">lowchars</code> containing all lowercase letters.</li>
  <li>The <code class="language-plaintext highlighter-rouge">decal</code> function takes an integer <code class="language-plaintext highlighter-rouge">x</code> and returns the result of decrementing <code class="language-plaintext highlighter-rouge">x</code> by 26 until it is non-negative.</li>
  <li>The <code class="language-plaintext highlighter-rouge">x</code> variable is assigned the result of applying <code class="language-plaintext highlighter-rouge">decal</code> to <code class="language-plaintext highlighter-rouge">x</code> and then taking the modulus of 26.</li>
  <li>The <code class="language-plaintext highlighter-rouge">decal_up</code> variable is assigned the value of <code class="language-plaintext highlighter-rouge">x</code> minus the integer value of the character ‘A’.</li>
  <li>The <code class="language-plaintext highlighter-rouge">decal_low</code> variable is assigned the value of <code class="language-plaintext highlighter-rouge">x</code> minus the integer value of the character ‘a’.</li>
  <li>The <code class="language-plaintext highlighter-rouge">String.map</code> function applies a function to each character in the string <code class="language-plaintext highlighter-rouge">str</code>.</li>
  <li>For each character <code class="language-plaintext highlighter-rouge">c</code> in the string <code class="language-plaintext highlighter-rouge">str</code>, the function checks if it is a lowercase letter using the <code class="language-plaintext highlighter-rouge">islower</code> function.</li>
  <li>If <code class="language-plaintext highlighter-rouge">c</code> is a lowercase letter, the function calculates a new index <code class="language-plaintext highlighter-rouge">j</code> by adding the integer value of <code class="language-plaintext highlighter-rouge">c</code> to <code class="language-plaintext highlighter-rouge">decal_low</code> and taking the modulus of 26. The new character is then obtained by taking the <code class="language-plaintext highlighter-rouge">j</code>-th character of the <code class="language-plaintext highlighter-rouge">lowchars</code> string.</li>
  <li>If <code class="language-plaintext highlighter-rouge">c</code> is an uppercase letter, the function calculates a new index <code class="language-plaintext highlighter-rouge">j</code> by adding the integer value of <code class="language-plaintext highlighter-rouge">c</code> to <code class="language-plaintext highlighter-rouge">decal_up</code> and taking the modulus of 26. The new character is then obtained by taking the <code class="language-plaintext highlighter-rouge">j</code>-th character of the <code class="language-plaintext highlighter-rouge">upchars</code> string.</li>
  <li>If <code class="language-plaintext highlighter-rouge">c</code> is not a letter, the function returns <code class="language-plaintext highlighter-rouge">c</code> unchanged.</li>
  <li>The function returns the resulting string.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Caesar cipher algorithm is O(n), where <code class="language-plaintext highlighter-rouge">n</code> is the length of the input string <code class="language-plaintext highlighter-rouge">str</code>. This is because the <code class="language-plaintext highlighter-rouge">String.map</code> function applies a function to each character in the string <code class="language-plaintext highlighter-rouge">str</code>, and this operation takes O(1) time per character. Therefore, the overall time complexity is O(n).</p>

<p>The space complexity of the algorithm is also O(n), since the resulting string has the same length as the input string.</p>

<p>In terms of security, the Caesar cipher is very weak and easy to break, since there are only 26 possible shifts and an attacker can easily try all of them. Therefore, it is not suitable for use in modern cryptography, but it can still be used for simple purposes such as obfuscation or educational purposes.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Caesar cipher is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is shifted a certain number of places down the alphabet. For example, with a shift of 1, A would be replaced by B, B would become C, and so on. The method is apparently named after Julius Caesar, who used it to communicate with his officials. Implementation The Caesar cipher is implemented in OCaml as follows: ```ocaml let islower c = c &gt;= ‘a’ &amp;&amp; c &lt;= ‘z’]]></summary></entry><entry><title type="html">Best Shuffle Algorithm</title><link href="/algorithm/2023/11/22/best-shuffle.html" rel="alternate" type="text/html" title="Best Shuffle Algorithm" /><published>2023-11-22T13:00:00+02:00</published><updated>2023-11-22T13:00:00+02:00</updated><id>/algorithm/2023/11/22/best-shuffle</id><content type="html" xml:base="/algorithm/2023/11/22/best-shuffle.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Best Shuffle algorithm is used to shuffle a string such that no two consecutive characters remain the same. It is a simple algorithm that can be used in various applications such as cryptography, data encryption, and data compression.</p>

<h2 id="implementation">Implementation</h2>
<p>The implementation of the Best Shuffle algorithm is provided below in OCaml. The algorithm takes a string as input and returns the shuffled string.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">best_shuffle</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">copy</span> <span class="n">s</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">pred</span> <span class="n">len</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">pred</span> <span class="n">len</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;&gt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&gt;</span> <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">then</span>
        <span class="k">begin</span>
          <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">in</span>
          <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
          <span class="n">r</span><span class="o">.</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="k">end</span>
    <span class="k">done</span><span class="p">;</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="p">(</span><span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">count_same</span> <span class="n">s1</span> <span class="n">s2</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">len1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s1</span>
  <span class="ow">and</span> <span class="n">len2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">pred</span> <span class="p">(</span><span class="n">min</span> <span class="n">len1</span> <span class="n">len2</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">then</span> <span class="n">incr</span> <span class="n">n</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">n</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">test</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">best_shuffle</span> <span class="n">s</span> <span class="k">in</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" '%s', '%s' -&gt; %d</span><span class="se">\n</span><span class="s2">"</span> <span class="n">s</span> <span class="n">s2</span> <span class="p">(</span><span class="n">count_same</span> <span class="n">s</span> <span class="n">s2</span><span class="p">);</span>
  <span class="k">in</span>
  <span class="n">test</span> <span class="s2">"tree"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"abracadabra"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"seesaw"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"elk"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"grrrrrr"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"up"</span><span class="p">;</span>
  <span class="n">test</span> <span class="s2">"a"</span><span class="p">;</span>
<span class="p">;;</span> 
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The length of the input string is calculated and stored in the variable <code class="language-plaintext highlighter-rouge">len</code>.</li>
  <li>A copy of the input string is made and stored in the variable <code class="language-plaintext highlighter-rouge">r</code>.</li>
  <li>The algorithm iterates over each character in the input string using a nested loop.</li>
  <li>For each pair of characters, the algorithm checks if they are not equal, and if swapping them will not create two consecutive characters that are the same.</li>
  <li>If the conditions in step 4 are met, the characters are swapped.</li>
  <li>The shuffled string is returned.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Best Shuffle algorithm is O(n^2), where n is the length of the input string. This is because the algorithm uses a nested loop to iterate over each pair of characters in the input string. The space complexity of the algorithm is O(n), where n is the length of the input string. This is because the algorithm creates a copy of the input string to store the shuffled string. Overall, the Best Shuffle algorithm is a simple and efficient algorithm for shuffling strings.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Best Shuffle algorithm is used to shuffle a string such that no two consecutive characters remain the same. It is a simple algorithm that can be used in various applications such as cryptography, data encryption, and data compression. Implementation The implementation of the Best Shuffle algorithm is provided below in OCaml. The algorithm takes a string as input and returns the shuffled string. let best_shuffle s = let len = String.length s in let r = String.copy s in for i = 0 to pred len do for j = 0 to pred len do if i &lt;&gt; j &amp;&amp; s.[i] &lt;&gt; r.[j] &amp;&amp; s.[j] &lt;&gt; r.[i] then begin let tmp = r.[i] in r.[i] &lt;- r.[j]; r.[j] &lt;- tmp; end done; done; (r)]]></summary></entry><entry><title type="html">Balanced Brackets Problem</title><link href="/algorithm/2023/11/22/balanced-bracket.html" rel="alternate" type="text/html" title="Balanced Brackets Problem" /><published>2023-11-22T12:00:00+02:00</published><updated>2023-11-22T12:00:00+02:00</updated><id>/algorithm/2023/11/22/balanced-bracket</id><content type="html" xml:base="/algorithm/2023/11/22/balanced-bracket.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Balanced brackets is a problem that requires checking if a given string of brackets is balanced or not. A balanced string of brackets is one that has the same number of opening and closing brackets, and the brackets are properly nested. This problem has many applications, such as in compilers, text editors, and syntax checkers.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">generate_brackets</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">i</span> <span class="n">acc</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span>
      <span class="n">aux</span> <span class="p">(</span><span class="n">pred</span> <span class="n">i</span><span class="p">)</span> <span class="p">(</span><span class="k">'</span><span class="p">[</span><span class="k">'</span><span class="o">::</span><span class="k">'</span><span class="p">]</span><span class="k">'</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">brk</span> <span class="o">=</span> <span class="n">aux</span> <span class="n">n</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">brk</span> 

<span class="k">let</span> <span class="n">is_balanced</span> <span class="n">brk</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="k">'</span><span class="p">[</span><span class="k">'</span><span class="o">::</span><span class="n">brk</span><span class="o">,</span> <span class="n">level</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="p">(</span><span class="n">brk</span><span class="o">,</span> <span class="n">succ</span> <span class="n">level</span><span class="p">)</span>
    <span class="o">|</span> <span class="k">'</span><span class="p">]</span><span class="k">'</span><span class="o">::</span><span class="n">brk</span><span class="o">,</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="bp">false</span>
    <span class="o">|</span> <span class="k">'</span><span class="p">]</span><span class="k">'</span><span class="o">::</span><span class="n">brk</span><span class="o">,</span> <span class="n">level</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="p">(</span><span class="n">brk</span><span class="o">,</span> <span class="n">pred</span> <span class="n">level</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="p">(</span><span class="n">brk</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">int_of_string</span> <span class="nn">Sys</span><span class="p">.</span><span class="n">argv</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="nn">Random</span><span class="p">.</span><span class="n">self_init</span><span class="bp">()</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">brk</span> <span class="o">=</span> <span class="n">generate_brackets</span> <span class="n">n</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_char</span> <span class="n">brk</span><span class="p">;</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" %B</span><span class="se">\n</span><span class="s2">"</span> <span class="p">(</span><span class="n">is_balanced</span> <span class="n">brk</span><span class="p">);</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>The algorithm implemented here generates a random string of n brackets, either <code class="language-plaintext highlighter-rouge">[</code> or <code class="language-plaintext highlighter-rouge">]</code>, and then checks if it is balanced. The <code class="language-plaintext highlighter-rouge">generate_brackets</code> function generates a list of n brackets, alternating between <code class="language-plaintext highlighter-rouge">[</code> and <code class="language-plaintext highlighter-rouge">]</code>, and then shuffles the list randomly. The <code class="language-plaintext highlighter-rouge">is_balanced</code> function checks if the brackets are balanced by using a stack to keep track of the number of opening brackets seen so far. If a closing bracket is encountered while the stack is empty, or if the closing bracket does not match the most recent opening bracket, the string is not balanced.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">generate_brackets</code> function takes an integer <code class="language-plaintext highlighter-rouge">n</code> as input and returns a list of <code class="language-plaintext highlighter-rouge">n</code> brackets.</li>
  <li>It uses a helper function <code class="language-plaintext highlighter-rouge">aux</code> that takes an integer <code class="language-plaintext highlighter-rouge">i</code> and a list <code class="language-plaintext highlighter-rouge">acc</code> as input, where <code class="language-plaintext highlighter-rouge">i</code> is the number of brackets left to generate and <code class="language-plaintext highlighter-rouge">acc</code> is the accumulator list that holds the generated brackets so far.</li>
  <li>If <code class="language-plaintext highlighter-rouge">i</code> is less than or equal to 0, the function returns the accumulator list.</li>
  <li>Otherwise, it calls <code class="language-plaintext highlighter-rouge">aux</code> recursively with <code class="language-plaintext highlighter-rouge">i-1</code> and <code class="language-plaintext highlighter-rouge">['['; ']'] @ acc</code>, which adds an opening and closing bracket to the accumulator list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">generate_brackets</code> function then shuffles the list randomly using <code class="language-plaintext highlighter-rouge">List.sort</code> and a comparison function that randomly returns -1, 0, or 1.</li>
  <li>The <code class="language-plaintext highlighter-rouge">is_balanced</code> function takes a list of brackets <code class="language-plaintext highlighter-rouge">brk</code> as input and returns a boolean indicating if the brackets are balanced or not.</li>
  <li>It uses a helper function <code class="language-plaintext highlighter-rouge">aux</code> that takes a tuple <code class="language-plaintext highlighter-rouge">(brk, level)</code> as input, where <code class="language-plaintext highlighter-rouge">brk</code> is the remaining list of brackets and <code class="language-plaintext highlighter-rouge">level</code> is the number of opening brackets seen so far.</li>
  <li>If <code class="language-plaintext highlighter-rouge">brk</code> is empty and <code class="language-plaintext highlighter-rouge">level</code> is 0, the function returns true, indicating that the brackets are balanced.</li>
  <li>If the first character of <code class="language-plaintext highlighter-rouge">brk</code> is <code class="language-plaintext highlighter-rouge">[</code>, the function calls <code class="language-plaintext highlighter-rouge">aux</code> recursively with the tail of <code class="language-plaintext highlighter-rouge">brk</code> and <code class="language-plaintext highlighter-rouge">level+1</code>.</li>
  <li>If the first character of <code class="language-plaintext highlighter-rouge">brk</code> is <code class="language-plaintext highlighter-rouge">]</code>, the function checks if <code class="language-plaintext highlighter-rouge">level</code> is 0, indicating that there is no opening bracket to match the closing bracket. If <code class="language-plaintext highlighter-rouge">level</code> is not 0, the function calls <code class="language-plaintext highlighter-rouge">aux</code> recursively with the tail of <code class="language-plaintext highlighter-rouge">brk</code> and <code class="language-plaintext highlighter-rouge">level-1</code>.</li>
  <li>If the first character of <code class="language-plaintext highlighter-rouge">brk</code> is neither <code class="language-plaintext highlighter-rouge">[</code> nor <code class="language-plaintext highlighter-rouge">]</code>, the function raises an assertion error, since this should never happen.</li>
  <li>The <code class="language-plaintext highlighter-rouge">is_balanced</code> function calls <code class="language-plaintext highlighter-rouge">aux</code> with <code class="language-plaintext highlighter-rouge">(brk, 0)</code> as the initial tuple, since there are no opening brackets seen so far.</li>
  <li>The main function reads an integer <code class="language-plaintext highlighter-rouge">n</code> from the command line arguments, generates a random list of <code class="language-plaintext highlighter-rouge">n</code> brackets using <code class="language-plaintext highlighter-rouge">generate_brackets</code>, prints the brackets to the console, and then checks if they are balanced using <code class="language-plaintext highlighter-rouge">is_balanced</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of generating the list of brackets is O(n), since it calls the <code class="language-plaintext highlighter-rouge">aux</code> function recursively n times, and each call takes constant time to append two brackets to the accumulator list. The time complexity of shuffling the list is O(n log n), since it uses <code class="language-plaintext highlighter-rouge">List.sort</code> with a comparison function that takes constant time. The time complexity of checking if the brackets are balanced is O(n), since it scans the list once and uses a stack to keep track of the opening brackets seen so far. The space complexity of generating the list of brackets is O(n), since it creates a list of size n. The space complexity of checking if the brackets are balanced is also O(n), since it uses a stack that can hold up to n opening brackets.</p>

<p>In summary, the overall time complexity of the algorithm is O(n log n), due to the sorting step, and the overall space complexity is O(n), due to the list and stack used.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Balanced brackets is a problem that requires checking if a given string of brackets is balanced or not. A balanced string of brackets is one that has the same number of opening and closing brackets, and the brackets are properly nested. This problem has many applications, such as in compilers, text editors, and syntax checkers. Implementation]]></summary></entry><entry><title type="html">A* (A-Star) Algorithm</title><link href="/algorithm/2023/11/22/a-star.html" rel="alternate" type="text/html" title="A* (A-Star) Algorithm" /><published>2023-11-22T09:00:00+02:00</published><updated>2023-11-22T09:00:00+02:00</updated><id>/algorithm/2023/11/22/a-star</id><content type="html" xml:base="/algorithm/2023/11/22/a-star.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step.</p>

<h2 id="implementation">Implementation</h2>

<p>The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function <code class="language-plaintext highlighter-rouge">find_path</code> takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">IntPairs</span> <span class="o">=</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
    <span class="k">let</span> <span class="n">compare</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span><span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
      <span class="k">match</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">x0</span> <span class="n">x1</span> <span class="k">with</span>
      <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">y0</span> <span class="n">y1</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="k">end</span>

<span class="k">module</span> <span class="nc">PairsMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>
<span class="k">module</span> <span class="nc">PairsSet</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>


<span class="k">let</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">get_neighbors</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">moves</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
                 <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">_x</span><span class="o">,</span> <span class="n">_y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+_</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+_</span><span class="n">y</span><span class="p">)</span> <span class="n">moves</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">max_x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">max_y</span>
        <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="n">ms</span> <span class="k">in</span>
    <span class="p">(</span><span class="n">ms</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">h</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span> <span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">abs</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span> <span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="p">(</span><span class="n">h</span> <span class="n">goal</span> <span class="n">start</span><span class="p">)</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="mi">0</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">current</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">from</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">from</span> <span class="o">=</span> <span class="n">start</span> <span class="k">then</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span> <span class="n">from</span>
    <span class="k">in</span>
    <span class="n">aux</span> <span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="n">current</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="k">in</span>
    <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="n">gScore</span> <span class="n">cell</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">cell</span> <span class="n">gScore</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">max_int</span>
  <span class="k">in</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">is_empty</span> <span class="n">openSet</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span>
      <span class="nn">PairsSet</span><span class="p">.</span><span class="n">fold</span> <span class="p">(</span><span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span>
          <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p1</span> <span class="n">fScore</span>
          <span class="ow">and</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p2</span> <span class="n">fScore</span> <span class="k">in</span>
          <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span> <span class="n">p2</span>
      <span class="p">)</span> <span class="n">openSet</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="k">if</span> <span class="n">current</span> <span class="o">=</span> <span class="n">goal</span> <span class="k">then</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span><span class="p">)</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">remove</span> <span class="n">current</span> <span class="n">openSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">current</span> <span class="n">closedSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span> <span class="n">current</span> <span class="k">in</span>
    <span class="n">neighbors</span> <span class="o">|&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span>
        <span class="p">(</span><span class="k">fun</span> <span class="p">((</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="k">as</span> <span class="n">v</span><span class="p">)</span> <span class="n">neighbor</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">closedSet</span> <span class="k">then</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">else</span>
            <span class="k">let</span> <span class="n">tentative_gScore</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">tentative_gScore</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">then</span>
              <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">tentative_gScore</span> <span class="n">gScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="n">neighbor</span> <span class="n">goal</span><span class="p">)</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">f</span> <span class="n">fScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span>
                <span class="k">if</span> <span class="n">not</span> <span class="p">(</span><span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">openSet</span><span class="p">)</span>
                <span class="k">then</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">openSet</span> <span class="k">else</span> <span class="n">openSet</span>
              <span class="k">in</span>
              <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">)</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">_find_path</span>
  <span class="k">in</span>
  <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>

</code></pre></div></div>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
  <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">dim_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dim_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"path not found"</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" (%d, %d)</span><span class="se">\n</span><span class="s2">"</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">_board</span> <span class="o">=</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_y</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span>
          <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_x</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">'</span><span class="o">#</span><span class="k">'</span> <span class="k">else</span> <span class="sc">'.'</span><span class="p">))</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="k">'</span><span class="o">*</span><span class="k">'</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>

      <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
          <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" %c"</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">)</span> <span class="n">line</span><span class="p">;</span>
        <span class="n">print_newline</span> <span class="bp">()</span>
      <span class="p">)</span> <span class="n">_board</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The maximum x and y coordinates of the board are obtained using the <code class="language-plaintext highlighter-rouge">Array.length</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">get_neighbors</code> function takes a position (x,y) and returns a list of neighboring positions that are not obstacles.</li>
  <li>The <code class="language-plaintext highlighter-rouge">h</code> function takes two positions and returns the Manhattan distance between them.</li>
  <li>The openSet is initialized with the starting position, and the closedSet is empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">fScore</code> and <code class="language-plaintext highlighter-rouge">gScore</code> maps are initialized with the starting position, where <code class="language-plaintext highlighter-rouge">fScore</code> is the sum of <code class="language-plaintext highlighter-rouge">gScore</code> and the heuristic function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">cameFrom</code> map is initialized as empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">reconstruct_path</code> function takes the <code class="language-plaintext highlighter-rouge">cameFrom</code> map and the current position and returns the path from the starting position to the current position.</li>
  <li>The <code class="language-plaintext highlighter-rouge">d</code> function takes two positions and returns the cost of moving from the first position to the second.</li>
  <li>The <code class="language-plaintext highlighter-rouge">g</code> function takes the <code class="language-plaintext highlighter-rouge">gScore</code> map and a position and returns its <code class="language-plaintext highlighter-rouge">gScore</code> value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">_find_path</code> function takes the current state of the search and performs the following steps:
    <ul>
      <li>If the openSet is empty, return None.</li>
      <li>Select the node with the lowest <code class="language-plaintext highlighter-rouge">fScore</code> value from the openSet.</li>
      <li>If the selected node is the goal, return the reconstructed path from the starting position to the goal.</li>
      <li>Remove the selected node from the openSet and add it to the closedSet.</li>
      <li>Generate a list of neighboring nodes.</li>
      <li>For each neighboring node:</li>
    </ul>
    <ul>
      <li>If it is in the closedSet, skip it.</li>
      <li>Calculate the tentative <code class="language-plaintext highlighter-rouge">gScore</code> value for the node.</li>
      <li>If the <code class="language-plaintext highlighter-rouge">gScore</code> value is better than the current value, update the <code class="language-plaintext highlighter-rouge">gScore</code>, <code class="language-plaintext highlighter-rouge">fScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps.</li>
      <li>If the node is not in the openSet, add it to the openSet.<br />
        - Recursively call <code class="language-plaintext highlighter-rouge">_find_path</code> with the updated state.</li>
    </ul>
  </li>
  <li>Call <code class="language-plaintext highlighter-rouge">_find_path</code> with the initial state.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of the A* algorithm depends on the heuristic function used and the size of the board. In the worst case, where the heuristic function overestimates the true distance, the algorithm can explore all nodes in the board, resulting in a time complexity of O(b^d), where b is the branching factor (number of neighbors per node) and d is the depth of the goal node. However, in practice, the algorithm often explores fewer nodes than this worst-case bound.</p>

<p>The space complexity of the algorithm is also dependent on the size of the board, as it stores the openSet, closedSet, <code class="language-plaintext highlighter-rouge">fScore</code>, <code class="language-plaintext highlighter-rouge">gScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps. However, the space complexity can be reduced by using a more memory-efficient data structure for the</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step. Implementation The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function find_path takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path. ```ocaml module IntPairs = struct type t = int * int let compare (x0,y0) (x1,y1) = match Stdlib.compare x0 x1 with | 0 -&gt; Stdlib.compare y0 y1 | c -&gt; c end]]></summary></entry><entry><title type="html">Additive Prime Algorithm</title><link href="/algorithm/2023/11/22/additive-prime.html" rel="alternate" type="text/html" title="Additive Prime Algorithm" /><published>2023-11-22T08:00:00+02:00</published><updated>2023-11-22T08:00:00+02:00</updated><id>/algorithm/2023/11/22/additive-prime</id><content type="html" xml:base="/algorithm/2023/11/22/additive-prime.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Additive prime is a prime number whose digits add up to another prime number. For example, 23 is an additive prime because 2 + 3 = 5, and both 23 and 5 are prime numbers. This algorithm checks whether a given number is an additive prime.</p>

<h2 id="implementation">Implementation</h2>
<p>The algorithm is implemented in OCaml. The function <code class="language-plaintext highlighter-rouge">digit_sum</code> calculates the sum of digits of a given number. The function <code class="language-plaintext highlighter-rouge">is_prime</code> checks whether a given number is prime. The function <code class="language-plaintext highlighter-rouge">is_additive_prime</code> checks whether a given number is an additive prime by checking if the number and its digit sum are both prime.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">digit_sum</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="k">then</span> <span class="n">n</span> <span class="k">else</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">digit_sum</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">let</span> <span class="n">is_prime</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">test</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">x</span> <span class="k">in</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="o">||</span> <span class="n">x</span> <span class="o">*</span> <span class="n">q</span> <span class="o">&lt;&gt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="ow">mod</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>
  <span class="k">in</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="k">then</span> <span class="n">n</span> <span class="ow">lor</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">n</span> <span class="ow">land</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="ow">mod</span> <span class="mi">3</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test</span> <span class="mi">5</span>

<span class="k">let</span> <span class="n">is_additive_prime</span> <span class="n">n</span> <span class="o">=</span>
  <span class="n">is_prime</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">is_prime</span> <span class="p">(</span><span class="n">digit_sum</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="nn">Seq</span><span class="p">.</span><span class="n">ints</span> <span class="mi">0</span> <span class="o">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">take_while</span> <span class="p">((</span><span class="o">&gt;</span><span class="p">)</span> <span class="mi">500</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span> <span class="n">is_additive_prime</span>
  <span class="o">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" %u"</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">print_newline</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The function <code class="language-plaintext highlighter-rouge">digit_sum</code> takes a positive integer <code class="language-plaintext highlighter-rouge">n</code> as input.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is less than 10, then <code class="language-plaintext highlighter-rouge">n</code> is returned as the sum of digits of a single-digit number is the number itself.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is greater than or equal to 10, then the last digit of <code class="language-plaintext highlighter-rouge">n</code> is added to the sum of digits of the remaining digits of <code class="language-plaintext highlighter-rouge">n</code> by recursively calling the <code class="language-plaintext highlighter-rouge">digit_sum</code> function.</li>
  <li>The function <code class="language-plaintext highlighter-rouge">is_prime</code> takes a positive integer <code class="language-plaintext highlighter-rouge">n</code> as input.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is less than 5, then <code class="language-plaintext highlighter-rouge">n</code> is prime if and only if it is equal to 2 or 3.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is greater than or equal to 5, then the function <code class="language-plaintext highlighter-rouge">test</code> is called with an initial value of 5.</li>
  <li>The function <code class="language-plaintext highlighter-rouge">test</code> takes a positive integer <code class="language-plaintext highlighter-rouge">x</code> as input and checks if <code class="language-plaintext highlighter-rouge">n</code> is divisible by <code class="language-plaintext highlighter-rouge">x</code> or <code class="language-plaintext highlighter-rouge">x + 2</code>, or if <code class="language-plaintext highlighter-rouge">n</code> is divisible by any number of the form <code class="language-plaintext highlighter-rouge">x + 6k</code> where <code class="language-plaintext highlighter-rouge">k</code> is a non-negative integer less than or equal to <code class="language-plaintext highlighter-rouge">(n / x - x) / 6</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is greater than <code class="language-plaintext highlighter-rouge">(n / x - x) / 6</code>, then <code class="language-plaintext highlighter-rouge">n</code> is prime.</li>
  <li>The function <code class="language-plaintext highlighter-rouge">is_additive_prime</code> takes a positive integer <code class="language-plaintext highlighter-rouge">n</code> as input.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is not prime, then <code class="language-plaintext highlighter-rouge">is_additive_prime</code> returns <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">n</code> is prime, then the function <code class="language-plaintext highlighter-rouge">digit_sum</code> is called with <code class="language-plaintext highlighter-rouge">n</code> as input.</li>
  <li>If the digit sum of <code class="language-plaintext highlighter-rouge">n</code> is not prime, then <code class="language-plaintext highlighter-rouge">is_additive_prime</code> returns <code class="language-plaintext highlighter-rouge">false</code>.</li>
  <li>If both <code class="language-plaintext highlighter-rouge">n</code> and its digit sum are prime, then <code class="language-plaintext highlighter-rouge">is_additive_prime</code> returns <code class="language-plaintext highlighter-rouge">true</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the <code class="language-plaintext highlighter-rouge">digit_sum</code> function is O(log n) as the number of digits in <code class="language-plaintext highlighter-rouge">n</code> is proportional to log n. The time complexity of the <code class="language-plaintext highlighter-rouge">is_prime</code> function is O(sqrt n) as it checks divisibility up to the square root of <code class="language-plaintext highlighter-rouge">n</code>. The worst-case time complexity of the <code class="language-plaintext highlighter-rouge">is_additive_prime</code> function is O(sqrt n log n) as it checks the primality of <code class="language-plaintext highlighter-rouge">n</code> and its digit sum, which each have a worst-case time complexity of O(sqrt n). The space complexity of all</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Additive prime is a prime number whose digits add up to another prime number. For example, 23 is an additive prime because 2 + 3 = 5, and both 23 and 5 are prime numbers. This algorithm checks whether a given number is an additive prime. Implementation The algorithm is implemented in OCaml. The function digit_sum calculates the sum of digits of a given number. The function is_prime checks whether a given number is prime. The function is_additive_prime checks whether a given number is an additive prime by checking if the number and its digit sum are both prime. ```ocaml let rec digit_sum n = if n &lt; 10 then n else n mod 10 + digit_sum (n / 10)]]></summary></entry><entry><title type="html">Best-First Search</title><link href="/algorithm/2023/11/22/best-first-search.html" rel="alternate" type="text/html" title="Best-First Search" /><published>2023-11-22T08:00:00+02:00</published><updated>2023-11-22T08:00:00+02:00</updated><id>/algorithm/2023/11/22/best-first-search</id><content type="html" xml:base="/algorithm/2023/11/22/best-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Best-first search is a graph search algorithm that aims to find the optimal path between two nodes in a graph. It is commonly used in artificial intelligence and computer science, particularly in the field of pathfinding. The algorithm works by exploring the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. Best-first search can be used in a variety of applications, such as route planning, game AI, and logistics.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Best-first search in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="o">=</span> <span class="p">{</span>  
  <span class="n">state</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">;</span>  
  <span class="n">parent</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span><span class="p">;</span>  
  <span class="n">cost</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span>  
  <span class="n">heuristic</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span>  
<span class="p">}</span>  
   
<span class="k">let</span> <span class="n">best_first_search</span> <span class="n">initial_state</span> <span class="n">goal_state</span> <span class="n">successors</span> <span class="n">heuristic</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">is_goal</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">goal_state</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">search</span> <span class="n">frontier</span> <span class="n">visited</span> <span class="o">=</span>  
    <span class="k">match</span> <span class="n">frontier</span> <span class="k">with</span>  
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>  
    <span class="o">|</span> <span class="n">n</span> <span class="o">::</span> <span class="n">_</span> <span class="k">when</span> <span class="n">is_goal</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">n</span>  
    <span class="o">|</span> <span class="n">n</span> <span class="o">::</span> <span class="n">ns</span> <span class="o">-&gt;</span>  
        <span class="k">let</span> <span class="n">successors</span> <span class="o">=</span> <span class="n">successors</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">add_node</span> <span class="n">frontier</span> <span class="n">node</span> <span class="o">=</span>  
          <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">)</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">frontier</span>  
          <span class="k">else</span> <span class="nn">List</span><span class="p">.</span><span class="n">merge</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">-&gt;</span> <span class="n">compare</span> <span class="n">n1</span><span class="o">.</span><span class="n">cost</span> <span class="n">n2</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>  
                 <span class="n">frontier</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">state</span><span class="o">,</span> <span class="n">cost</span><span class="p">)</span> <span class="o">-&gt;</span>  
            <span class="k">let</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="n">heuristic</span> <span class="n">state</span> <span class="k">in</span>  
            <span class="p">{</span><span class="n">state</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">n</span><span class="p">;</span> <span class="n">cost</span><span class="p">;</span> <span class="n">heuristic</span><span class="p">})</span> <span class="n">successors</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">frontier'</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">add_node</span> <span class="n">ns</span> <span class="n">nodes</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">visited'</span> <span class="o">=</span> <span class="n">n</span> <span class="o">::</span> <span class="n">visited</span> <span class="k">in</span>  
        <span class="n">search</span> <span class="n">frontier'</span> <span class="n">visited'</span>  
  <span class="k">in</span>  
  <span class="k">let</span> <span class="n">initial_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="nc">None</span><span class="p">;</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.;</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="n">heuristic</span> <span class="n">initial_state</span><span class="p">}</span> <span class="k">in</span>  
  <span class="n">search</span> <span class="p">[</span><span class="n">initial_node</span><span class="p">]</span> <span class="bp">[]</span>  
   
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">type 'a node</code> represents a node in the search tree. Each node has a state, a parent node, a cost (i.e., the cumulative cost from the initial state), and a heuristic value (i.e., the estimated distance to the goal state). The <code class="language-plaintext highlighter-rouge">best_first_search</code> function takes as input the initial state, the goal state, a function that generates the successors of a given state, and a heuristic function that estimates the distance to the goal state. The function returns an optional node that represents the goal state, or <code class="language-plaintext highlighter-rouge">None</code> if no path was found.</p>

<h2 id="example">Example</h2>

<p>Here’s an example of using Best-first search to find the shortest path between two cities in a graph:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[</span>  
  <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">7</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="mi">7</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="p">)])</span>  
<span class="p">]</span>  
   
<span class="k">let</span> <span class="n">successors</span> <span class="n">state</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_node</span> <span class="n">state</span> <span class="o">=</span> <span class="k">function</span>  
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Node not found"</span>  
    <span class="o">|</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">::</span> <span class="n">_</span> <span class="k">when</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
    <span class="o">|</span> <span class="n">_</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span> <span class="n">find_node</span> <span class="n">state</span> <span class="n">rest</span>  
  <span class="k">in</span>  
  <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="o">,</span> <span class="n">edges</span><span class="p">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="n">graph</span> <span class="k">in</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">c</span><span class="p">))</span> <span class="n">edges</span> <span class="o">@</span> <span class="n">find_node</span> <span class="n">state</span> <span class="n">graph</span>  
   
<span class="k">let</span> <span class="n">heuristic</span> <span class="n">state</span> <span class="o">=</span>  
  <span class="k">match</span> <span class="n">state</span> <span class="k">with</span>  
  <span class="o">|</span> <span class="s2">"A"</span> <span class="o">-&gt;</span> <span class="mi">6</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"B"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"C"</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"D"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"E"</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span>  
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Invalid state"</span>  
   
<span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">best_first_search</span> <span class="s2">"A"</span> <span class="s2">"E"</span> <span class="n">successors</span> <span class="n">heuristic</span>  
   
<span class="k">let</span> <span class="n">print_path</span> <span class="n">path</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">print_node</span> <span class="n">node</span> <span class="o">=</span>  
    <span class="k">match</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="k">with</span>  
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span>  
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">parent</span> <span class="o">-&gt;</span>  
        <span class="n">print_node</span> <span class="n">parent</span><span class="p">;</span>  
        <span class="n">print_endline</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span>  
  <span class="k">in</span>  
  <span class="k">match</span> <span class="n">path</span> <span class="k">with</span>  
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="s2">"No path found"</span>  
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">print_node</span> <span class="n">node</span>  
   
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">print_path</span> <span class="n">path</span>  
</code></pre></div></div>

<p>This code defines a graph as a list of nodes, where each node is a tuple of a state and a list of edges to other nodes, each with a cost. The <code class="language-plaintext highlighter-rouge">successors</code> function generates the successors of a given state by looking up the corresponding node in the graph and returning its edges. The <code class="language-plaintext highlighter-rouge">heuristic</code> function estimates the distance to the goal state based on a predefined heuristic value for each state.</p>

<p>The <code class="language-plaintext highlighter-rouge">path</code> variable contains the result of running Best-first search on the graph, starting from state “A” and ending at state “E”. Finally, the <code class="language-plaintext highlighter-rouge">print_path</code> function prints out the path from the initial state to the goal state.</p>

<p>When we run this code, we should see the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
C  
D  
E  
</code></pre></div></div>

<p>This indicates that the shortest path from “A” to “E” is “A” -&gt; “C” -&gt; “D” -&gt; “E”, with a total cost of 9.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create a node that represents the initial state, with a cost of 0 and a heuristic value based on the initial state.</li>
  <li>Create an empty list of visited nodes and a list that contains only the initial node as the frontier.</li>
  <li>If the frontier is empty, return <code class="language-plaintext highlighter-rouge">None</code> (i.e., no path was found).</li>
  <li>Otherwise, take the node at the front of the frontier and check if it is the goal node. If so, return it.</li>
  <li>Otherwise, generate the successors of the current node, create nodes for each of them, and add them to the frontier.</li>
  <li>Sort the frontier based on the cost of each node (i.e., the cumulative cost from the initial state).</li>
  <li>Add the current node to the list of visited nodes.</li>
  <li>Repeat from step 3.</li>
</ol>

<p>The key idea behind Best-first search is to explore the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. This allows the algorithm to quickly converge to the optimal path, while avoiding exploring unpromising paths.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Best-first search depends on the quality of the heuristic function. In the worst case, where the heuristic function is not informative (i.e., it always returns 0), the algorithm degenerates to a breadth-first search, with a time complexity of O(b^d), where b is the branching factor of the graph and d is the depth of the goal node. In the</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Best-first search is a graph search algorithm that aims to find the optimal path between two nodes in a graph. It is commonly used in artificial intelligence and computer science, particularly in the field of pathfinding. The algorithm works by exploring the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. Best-first search can be used in a variety of applications, such as route planning, game AI, and logistics. Implementation Here is an implementation of Best-first search in OCaml: type 'a node = { state: 'a; parent: 'a node option; cost: float; heuristic: float; } let best_first_search initial_state goal_state successors heuristic = let is_goal n = n.state = goal_state in let rec search frontier visited = match frontier with | [] -&gt; None | n :: _ when is_goal n -&gt; Some n | n :: ns -&gt; let successors = successors n.state in let add_node frontier node = if List.exists (fun n -&gt; n.state = node.state) visited then frontier else List.merge (fun n1 n2 -&gt; compare n1.cost n2.cost) frontier [node] in let nodes = List.map (fun (state, cost) -&gt; let heuristic = heuristic state in {state; parent = Some n; cost; heuristic}) successors in let frontier' = List.fold_left add_node ns nodes in let visited' = n :: visited in search frontier' visited' in let initial_node = {state = initial_state; parent = None; cost = 0.; heuristic = heuristic initial_state} in search [initial_node] [] Here, type 'a node represents a node in the search tree. Each node has a state, a parent node, a cost (i.e., the cumulative cost from the initial state), and a heuristic value (i.e., the estimated distance to the goal state). The best_first_search function takes as input the initial state, the goal state, a function that generates the successors of a given state, and a heuristic function that estimates the distance to the goal state. The function returns an optional node that represents the goal state, or None if no path was found.]]></summary></entry><entry><title type="html">Matrix Inverse</title><link href="/algorithm/2023/11/22/matrix-inverse.html" rel="alternate" type="text/html" title="Matrix Inverse" /><published>2023-11-22T06:00:00+02:00</published><updated>2023-11-22T06:00:00+02:00</updated><id>/algorithm/2023/11/22/matrix-inverse</id><content type="html" xml:base="/algorithm/2023/11/22/matrix-inverse.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The inverse of a matrix is a matrix that, when multiplied by the original matrix, results in the identity matrix. The inverse of a matrix is useful in solving systems of linear equations, computing determinants, and in other areas of mathematics. The algorithm we will be discussing is used to find the inverse of a square matrix.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">inv</span> <span class="n">varr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">_k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">varr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_add</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_add_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_neg</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_neg_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_one</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">one</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dims</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">varr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_check_is_matrix</span> <span class="n">dims</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">unsafe_get</span> <span class="n">dims</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">if</span> <span class="nn">Array</span><span class="p">.</span><span class="n">unsafe_get</span> <span class="n">dims</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">n</span>
  <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"no inverse - the matrix is not square"</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">pivot_row</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="n">_zero</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">result_varr</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">varr</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">pivot_elem</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="o">=</span> <span class="n">_zero</span>
      <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"the matrix does not have an inverse"</span><span class="p">;</span>
      <span class="c">(* update elements of the pivot row, save old vals *)</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">p</span> <span class="k">then</span> <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="n">pivot_elem</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update elements of the pivot col *)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span>
        <span class="k">then</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span>
            <span class="n">result_varr</span>
            <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span>
            <span class="p">(</span><span class="n">_div</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="n">_neg</span> <span class="n">pivot_elem</span><span class="p">))</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update the rest of the matrix *)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">pivot_col_elem</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">p</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="k">let</span> <span class="n">pivot_row_elem</span> <span class="o">=</span> <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">in</span>
            <span class="c">(* use old value *)</span>
            <span class="k">let</span> <span class="n">old_val</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">_add</span> <span class="n">old_val</span> <span class="p">(</span><span class="n">_mul</span> <span class="n">pivot_row_elem</span> <span class="n">pivot_col_elem</span><span class="p">)</span> <span class="k">in</span>
            <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="n">new_val</span><span class="p">)</span>
        <span class="k">done</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update the pivot element *)</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="n">_one</span> <span class="n">pivot_elem</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">result_varr</span><span class="p">)</span>
</code></pre></div></div>

<p>The algorithm is implemented in the OCaml programming language. It takes as input a matrix represented as an Owl ndarray and returns the inverse of the matrix as an ndarray. Here is an example of how to use the <code class="language-plaintext highlighter-rouge">inv</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Owl</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">of_array</span> <span class="p">[</span><span class="o">|</span> <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.</span> <span class="o">|</span><span class="p">];</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.;</span> <span class="mi">6</span><span class="o">.</span> <span class="o">|</span><span class="p">];</span> <span class="p">[</span><span class="o">|</span> <span class="mi">7</span><span class="o">.;</span> <span class="mi">8</span><span class="o">.;</span> <span class="mi">10</span><span class="o">.</span> <span class="o">|</span><span class="p">]</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="k">let</span> <span class="n">m_inv</span> <span class="o">=</span> <span class="n">inv</span> <span class="n">m</span> <span class="k">in</span>  
<span class="nn">Owl</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">print</span> <span class="n">m_inv</span>  
</code></pre></div></div>
<p>This will print the inverse of the matrix <code class="language-plaintext highlighter-rouge">m</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The algorithm works by performing a series of operations on the input matrix until it is transformed into the identity matrix. These operations are performed on both the input matrix and an identity matrix, which is used to keep track of the transformations. Here are the steps of the algorithm:</p>

<ol>
  <li>Check that the input matrix is square. If it is not, the function will return an error.</li>
  <li>Create a pivot row array that will be used to store the values of the row that is being transformed.</li>
  <li>Create a copy of the input matrix that will be transformed into the identity matrix.</li>
  <li>Iterate over the diagonal elements of the matrix (i.e., the pivot elements).</li>
  <li>If the pivot element is zero, the matrix does not have an inverse, so the function will return an error.</li>
  <li>Update the pivot row by dividing each element by the pivot element. Save the old values of the row in the pivot row array.</li>
  <li>Update the pivot column by dividing each element (except for the pivot element) by the negative of the pivot element.</li>
  <li>Update the rest of the matrix by subtracting the product of the pivot row and pivot column from each element (except for the pivot element).</li>
  <li>Update the pivot element by taking the reciprocal of the original pivot element.</li>
  <li>Return the transformed matrix, which is the inverse of the input matrix.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the algorithm is O(n^3), where n is the size of the input matrix. This is because the algorithm performs O(n) operations for each of the n diagonal elements, resulting in a total of O(n^3) operations. The space complexity of the algorithm is also O(n^3), since it creates a copy of the input matrix and a pivot row array of size n. Therefore, the algorithm is not suitable for very large matrices, as it may take a long time and use a lot of memory to compute the inverse.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The inverse of a matrix is a matrix that, when multiplied by the original matrix, results in the identity matrix. The inverse of a matrix is useful in solving systems of linear equations, computing determinants, and in other areas of mathematics. The algorithm we will be discussing is used to find the inverse of a square matrix. Implementation]]></summary></entry><entry><title type="html">Tridiagonal Matrix Algorithm</title><link href="/algorithm/2023/11/22/tridiagonal-algorithm.html" rel="alternate" type="text/html" title="Tridiagonal Matrix Algorithm" /><published>2023-11-22T05:00:00+02:00</published><updated>2023-11-22T05:00:00+02:00</updated><id>/algorithm/2023/11/22/tridiagonal-algorithm</id><content type="html" xml:base="/algorithm/2023/11/22/tridiagonal-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The tridiagonal matrix algorithm is a numerical method used to solve a system of linear equations where the matrix is tridiagonal. A tridiagonal matrix is a matrix where all the elements are zero except for those on the main diagonal, the diagonal above it, and the diagonal below it. The algorithm is used in various fields such as physics, engineering, and finance.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Solver for tridiagonal matrix
 * Input: a[n], b[n], c[n], which together consist the tridiagonal matrix A, and the right side vector r[n]. Return: x[n].
 *)</span>

<span class="k">let</span> <span class="n">tridiag_solve_vec</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">r</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n1</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">c</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n2</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"tridiag_solve_vec: 0 at the beginning of diagonal vector"</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">bet</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">gam</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span><span class="p">;</span>
    <span class="n">bet</span> <span class="o">:=</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*.</span> <span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">bet</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"tridiag_solve_vec: algorithm fails"</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*.</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*.</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span>
</code></pre></div></div>

<p>The implementation of the tridiagonal matrix algorithm is provided in OCaml. The function <code class="language-plaintext highlighter-rouge">tridiag_solve_vec</code> takes four input arrays <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">r</code>, where <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code> are the arrays representing the tridiagonal matrix and <code class="language-plaintext highlighter-rouge">r</code> is the right-hand side vector. The function returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The tridiagonal matrix algorithm works by eliminating the coefficients below and above the main diagonal. The algorithm can be divided into three steps:</p>

<ol>
  <li>
    <p>Decomposition: In this step, the algorithm decomposes the matrix into two matrices, L and U, where L is a lower triangular matrix and U is an upper triangular matrix. The decomposition is done in such a way that the product of L and U is equal to the original matrix.</p>
  </li>
  <li>
    <p>Forward substitution: In this step, the algorithm solves the equation Ly = r, where L is the lower triangular matrix obtained in the previous step, y is an intermediate vector, and r is the right-hand side vector. This step is called forward substitution because it starts from the first equation and solves for y in terms of the previous y values.</p>
  </li>
  <li>
    <p>Backward substitution: In this step, the algorithm solves the equation Ux = y, where U is the upper triangular matrix obtained in the first step, x is the solution vector, and y is the intermediate vector obtained in the previous step. This step is called backward substitution because it starts from the last equation and solves for x in terms of the previous x values.</p>
  </li>
</ol>

<p>The implementation of the tridiagonal matrix algorithm provided in OCaml is based on the Thomas algorithm, which is a simplified version of the tridiagonal matrix algorithm. The algorithm starts by checking that the diagonal element of the matrix is not zero. If it is zero, the algorithm raises an exception.</p>

<p>The algorithm then proceeds to calculate the intermediate values <code class="language-plaintext highlighter-rouge">gam</code> and <code class="language-plaintext highlighter-rouge">bet</code>, which are used in the forward substitution step. The intermediate value <code class="language-plaintext highlighter-rouge">bet</code> is updated at each iteration, and if it becomes zero, the algorithm raises an exception. The solution vector <code class="language-plaintext highlighter-rouge">x</code> is also updated at each iteration.</p>

<p>Finally, the algorithm performs the backward substitution step to obtain the final solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the tridiagonal matrix algorithm is O(n), where n is the size of the matrix. The algorithm performs two loops, one for the forward substitution step and one for the backward substitution step, each of which takes O(n) time. The intermediate calculations take constant time, so the overall time complexity is O(n).</p>

<p>The space complexity of the algorithm is also O(n), as it requires arrays of size n to store the intermediate values and the solution vector.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The tridiagonal matrix algorithm is a numerical method used to solve a system of linear equations where the matrix is tridiagonal. A tridiagonal matrix is a matrix where all the elements are zero except for those on the main diagonal, the diagonal above it, and the diagonal below it. The algorithm is used in various fields such as physics, engineering, and finance. Implementation]]></summary></entry><entry><title type="html">LU Decomposition</title><link href="/algorithm/2023/11/22/lu-decomposition.html" rel="alternate" type="text/html" title="LU Decomposition" /><published>2023-11-22T04:00:00+02:00</published><updated>2023-11-22T04:00:00+02:00</updated><id>/algorithm/2023/11/22/lu-decomposition</id><content type="html" xml:base="/algorithm/2023/11/22/lu-decomposition.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>LU decomposition is a numerical method for solving systems of linear equations. It decomposes a square matrix into two triangular matrices, one lower triangular matrix (L) and one upper triangular matrix (U). This decomposition can be used to solve linear equations in the form Ax = b, where A is the matrix, x is the vector of unknowns, and b is the vector of constants.</p>

<h2 id="implementation">Implementation</h2>
<p>The following implementation of LU decomposition is written in OCaml. It takes a matrix <code class="language-plaintext highlighter-rouge">a</code> as input and returns the L and U matrices, as well as a row permutation vector. The <code class="language-plaintext highlighter-rouge">_lu_base</code> function performs the decomposition and returns the L and U matrices and the permutation vector. The <code class="language-plaintext highlighter-rouge">lu</code> function calls <code class="language-plaintext highlighter-rouge">_lu_base</code> and then formats the output into the L and U matrices. The <code class="language-plaintext highlighter-rouge">_lu_solve_vec</code> function uses the output of <code class="language-plaintext highlighter-rouge">_lu_base</code> to solve a system of linear equations.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* LU decomposition.
 * Input matrix: a[n][n]; return L/U in one matrix, and the row permutation vector.
 * Test: https://github.com/scipy/scipy/blob/master/scipy/linalg/tests/test_decomp.py
 *)</span>
<span class="k">let</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_abs</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_abs_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_sub</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_sub_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_flt</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_float_typ_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_one</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">one</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">indx</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* implicit scaling of each row *)</span>
  <span class="k">let</span> <span class="n">vv</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tiny</span> <span class="o">=</span> <span class="n">_flt</span> <span class="mf">1.0e-40</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">big</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="c">(* flag of row exchange *)</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">imax</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* loop over rows to get the implicit scaling information *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">big</span> <span class="o">:=</span> <span class="n">_zero</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">_abs</span><span class="p">;</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">big</span> <span class="k">then</span> <span class="n">big</span> <span class="o">:=</span> <span class="o">!</span><span class="n">temp</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">big</span> <span class="o">=</span> <span class="n">_zero</span> <span class="k">then</span> <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">SINGULAR</span><span class="p">;</span>
    <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">_div</span> <span class="n">_one</span> <span class="o">!</span><span class="n">big</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">big</span> <span class="o">:=</span> <span class="n">_zero</span><span class="p">;</span>
    <span class="c">(* choose suitable pivot *)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">_abs</span><span class="p">)</span> <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">big</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">big</span> <span class="o">:=</span> <span class="o">!</span><span class="n">temp</span><span class="p">;</span>
        <span class="n">imax</span> <span class="o">:=</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="c">(* interchange rows *)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">imax</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">temp</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">temp</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span> <span class="o">*.</span> <span class="o">-</span><span class="mi">1</span><span class="o">.;</span>
      <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">imax</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
    <span class="n">indx</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">=</span> <span class="n">_zero</span> <span class="k">then</span> <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="n">tiny</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">tmp0</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="n">_div</span> <span class="n">tmp0</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">temp</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_sub</span> <span class="n">prev</span> <span class="p">(</span><span class="n">_mul</span> <span class="o">!</span><span class="n">temp</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])))</span>
      <span class="k">done</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="o">!</span><span class="n">d</span>


<span class="c">(* LU decomposition, return L, U, and permutation vector *)</span>
<span class="k">let</span> <span class="n">lu</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">lu</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">lu</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">eye</span> <span class="n">k</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">l</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span><span class="p">;</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="n">_zero</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">l</span><span class="o">,</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span>


<span class="k">let</span> <span class="n">_lu_solve_vec</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">_k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_sub</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_sub_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">if</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"LUdcmp::solve bad sizes"</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">indx</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">ip</span> <span class="o">|</span><span class="p">];</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">ip</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]);</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">ii</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
    <span class="k">then</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="o">!</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">sum</span> <span class="o">:=</span> <span class="n">_sub</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span> <span class="o">|</span><span class="p">]))</span>
      <span class="k">done</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">!</span><span class="n">sum</span> <span class="o">&lt;&gt;</span> <span class="n">_zero</span>
    <span class="k">then</span> <span class="n">ii</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">sum</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">sum</span> <span class="o">:=</span> <span class="n">_sub</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span> <span class="o">|</span><span class="p">]))</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">|</span><span class="p">]))</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_lu_base</code> function takes a square matrix <code class="language-plaintext highlighter-rouge">a</code> as input and returns the L and U matrices, as well as a row permutation vector.</p>
  </li>
  <li>
    <p>The function first makes a copy of the input matrix <code class="language-plaintext highlighter-rouge">a</code> into a new matrix <code class="language-plaintext highlighter-rouge">lu</code>.</p>
  </li>
  <li>
    <p>It initializes some variables, including the row permutation vector <code class="language-plaintext highlighter-rouge">indx</code>, the scaling vector <code class="language-plaintext highlighter-rouge">vv</code>, a small value <code class="language-plaintext highlighter-rouge">tiny</code>, and a flag <code class="language-plaintext highlighter-rouge">d</code>.</p>
  </li>
  <li>
    <p>The function then calculates the implicit scaling of each row by finding the maximum absolute value in each row and storing the reciprocal of that value in the <code class="language-plaintext highlighter-rouge">vv</code> vector.</p>
  </li>
  <li>
    <p>It then performs the LU decomposition using Gaussian elimination with partial pivoting. The function loops over each column <code class="language-plaintext highlighter-rouge">k</code> and selects the pivot element as the one with the largest scaled value in the column. If necessary, it exchanges rows to bring the pivot element to the diagonal. It stores the row index of each pivot element in the <code class="language-plaintext highlighter-rouge">indx</code> vector.</p>
  </li>
  <li>
    <p>During the elimination process, the function stores the multipliers used to eliminate the elements below the pivot element in the <code class="language-plaintext highlighter-rouge">lu</code> matrix.</p>
  </li>
  <li>
    <p>The function also keeps track of the sign of the row exchanges in the <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>After the elimination process is complete, the function returns the <code class="language-plaintext highlighter-rouge">lu</code> matrix, the <code class="language-plaintext highlighter-rouge">indx</code> vector, and the <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">lu</code> function calls <code class="language-plaintext highlighter-rouge">_lu_base</code> and then formats the output into the L and U matrices. It first calls <code class="language-plaintext highlighter-rouge">_lu_base</code> to get the <code class="language-plaintext highlighter-rouge">lu</code> matrix, <code class="language-plaintext highlighter-rouge">indx</code> vector, and <code class="language-plaintext highlighter-rouge">d</code> flag. It then creates an identity matrix <code class="language-plaintext highlighter-rouge">l</code> with the same size as <code class="language-plaintext highlighter-rouge">lu</code>.</p>
  </li>
  <li>
    <p>The function sets the elements of <code class="language-plaintext highlighter-rouge">l</code> to the corresponding elements of <code class="language-plaintext highlighter-rouge">lu</code> below the diagonal.</p>
  </li>
  <li>
    <p>The function returns the <code class="language-plaintext highlighter-rouge">l</code> and <code class="language-plaintext highlighter-rouge">lu</code> matrices, as well as the <code class="language-plaintext highlighter-rouge">indx</code> vector.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_lu_solve_vec</code> function uses the output of <code class="language-plaintext highlighter-rouge">_lu_base</code> to solve a system of linear equations. It takes a matrix <code class="language-plaintext highlighter-rouge">a</code> and a vector <code class="language-plaintext highlighter-rouge">b</code> as input and returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The function first checks that the dimensions of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are compatible.</p>
  </li>
  <li>
    <p>It then calls <code class="language-plaintext highlighter-rouge">_lu_base</code> to get the <code class="language-plaintext highlighter-rouge">lu</code> matrix, <code class="language-plaintext highlighter-rouge">indx</code> vector, and <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>The function initializes some variables and loops over each row of the <code class="language-plaintext highlighter-rouge">lu</code> matrix to solve for the intermediate solution vector <code class="language-plaintext highlighter-rouge">y</code>.</p>
  </li>
  <li>
    <p>The function then loops over each row of the <code class="language-plaintext highlighter-rouge">lu</code> matrix again to solve for the final solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The function returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of LU decomposition is O(n^3), where n is the size of the input matrix. This is because the algorithm involves performing Gaussian elimination on the matrix, which requires O(n^3) operations. The space complexity of the algorithm is also O(n^2), since it requires storing the L and U matrices, as well as the row permutation vector. However, the algorithm is numerically stable and is widely used in practice for solving systems of linear equations.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction LU decomposition is a numerical method for solving systems of linear equations. It decomposes a square matrix into two triangular matrices, one lower triangular matrix (L) and one upper triangular matrix (U). This decomposition can be used to solve linear equations in the form Ax = b, where A is the matrix, x is the vector of unknowns, and b is the vector of constants. Implementation The following implementation of LU decomposition is written in OCaml. It takes a matrix a as input and returns the L and U matrices, as well as a row permutation vector. The _lu_base function performs the decomposition and returns the L and U matrices and the permutation vector. The lu function calls _lu_base and then formats the output into the L and U matrices. The _lu_solve_vec function uses the output of _lu_base to solve a system of linear equations. ```ocaml (* LU decomposition. Input matrix: a[n][n]; return L/U in one matrix, and the row permutation vector. Test: https://github.com/scipy/scipy/blob/master/scipy/linalg/tests/test_decomp.py ) let _lu_base a = let k = M.kind a in let _abs = Owl_base_dense_common._abs_elt k in let _mul = Owl_base_dense_common._mul_elt k in let _div = Owl_base_dense_common._div_elt k in let _sub = Owl_base_dense_common._sub_elt k in let _flt = Owl_base_dense_common._float_typ_elt k in let _zero = Owl_const.zero k in let _one = Owl_const.one k in let lu = M.copy a in let n = (M.shape a).(0) in let m = (M.shape a).(1) in assert (n = m); let indx = Array.make n 0 in ( implicit scaling of each row ) let vv = Array.make n _zero in let tiny = _flt 1.0e-40 in let big = ref _zero in let temp = ref _zero in ( flag of row exchange ) let d = ref 1.0 in let imax = ref 0 in ( loop over rows to get the implicit scaling information ) for i = 0 to n - 1 do big := _zero; for j = 0 to n - 1 do temp := M.get lu [| i; j |] |&gt; _abs; if !temp &gt; !big then big := !temp done; if !big = _zero then raise Owl_exception.SINGULAR; vv.(i) &lt;- _div _one !big done; for k = 0 to n - 1 do big := _zero; ( choose suitable pivot ) for i = k to n - 1 do temp := _mul (M.get lu [| i; k |] |&gt; _abs) vv.(i); if !temp &gt; !big then ( big := !temp; imax := i) done; ( interchange rows *) if k &lt;&gt; !imax then ( for j = 0 to n - 1 do temp := M.get lu [| !imax; j |]; let tmp = M.get lu [| k; j |] in M.set lu [| !imax; j |] tmp; M.set lu [| k; j |] !temp done; d := !d *. -1.; vv.(!imax) &lt;- vv.(k)); indx.(k) &lt;- !imax; if M.get lu [| k; k |] = _zero then M.set lu [| k; k |] tiny; for i = k + 1 to n - 1 do let tmp0 = M.get lu [| i; k |] in let tmp1 = M.get lu [| k; k |] in temp := _div tmp0 tmp1; M.set lu [| i; k |] !temp; for j = k + 1 to n - 1 do let prev = M.get lu [| i; j |] in M.set lu [| i; j |] (_sub prev (_mul !temp (M.get lu [| k; j |]))) done done done; lu, indx, !d]]></summary></entry></feed>