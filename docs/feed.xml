<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-24T22:02:13+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">Brent’s Algorithm</title><link href="/algorithm/2023/11/21/brents-algorithm.html" rel="alternate" type="text/html" title="Brent’s Algorithm" /><published>2023-11-21T03:00:00+02:00</published><updated>2023-11-21T03:00:00+02:00</updated><id>/algorithm/2023/11/21/brents-algorithm</id><content type="html" xml:base="/algorithm/2023/11/21/brents-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Brent’s algorithm in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">power</span> <span class="n">lam</span> <span class="n">tortoise</span> <span class="n">hare</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">tortoise</span> <span class="o">=</span> <span class="n">hare</span> <span class="k">then</span> <span class="n">lam</span>  
    <span class="k">else</span> <span class="k">if</span> <span class="n">power</span> <span class="o">=</span> <span class="n">lam</span> <span class="k">then</span> <span class="n">loop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">power</span><span class="p">)</span> <span class="mi">0</span> <span class="n">hare</span> <span class="n">hare</span>  
    <span class="k">else</span> <span class="n">loop</span> <span class="n">power</span> <span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">tortoise</span> <span class="p">(</span><span class="n">f</span> <span class="n">hare</span><span class="p">)</span>  
  <span class="k">in</span> <span class="n">loop</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">x0</span> <span class="p">(</span><span class="n">f</span> <span class="n">x0</span><span class="p">)</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function takes two arguments: <code class="language-plaintext highlighter-rouge">f</code>, a function that takes a value and returns the next value in the sequence, and <code class="language-plaintext highlighter-rouge">x0</code>, the initial value in the sequence. The function returns the length of the cycle in the sequence.</p>

<p>Here is an example of how to use the <code class="language-plaintext highlighter-rouge">brent_algorithm</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">mod</span> <span class="mi">23</span>  
<span class="k">let</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">1</span>  
<span class="k">let</span> <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">brent_algorithm</span> <span class="n">f</span> <span class="n">x0</span>  
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">f</code> is a function that generates a sequence of values using the formula <code class="language-plaintext highlighter-rouge">x^2 + 1 (mod 23)</code>, <code class="language-plaintext highlighter-rouge">x0</code> is the initial value of the sequence, and <code class="language-plaintext highlighter-rouge">cycle_length</code> is the length of the cycle in the sequence.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before.</p>

<p>At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence.</p>

<p>The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time.</p>

<p>The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables.</p>

<p>Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Brent’s algorithm is a cycle detection algorithm that is used to find a cycle in a sequence. It was introduced in 1976 by Richard Brent, an Australian mathematician and computer scientist. The algorithm is particularly useful in finding cycles in linked lists, but it can be applied to any sequence of values. Implementation Here is an implementation of Brent’s algorithm in OCaml: let brent_algorithm f x0 = let rec loop power lam tortoise hare = if tortoise = hare then lam else if power = lam then loop (2 * power) 0 hare hare else loop power (lam + 1) tortoise (f hare) in loop 1 0 x0 (f x0) The brent_algorithm function takes two arguments: f, a function that takes a value and returns the next value in the sequence, and x0, the initial value in the sequence. The function returns the length of the cycle in the sequence. Here is an example of how to use the brent_algorithm function: let f x = (x * x + 1) mod 23 let x0 = 1 let cycle_length = brent_algorithm f x0 In this example, f is a function that generates a sequence of values using the formula x^2 + 1 (mod 23), x0 is the initial value of the sequence, and cycle_length is the length of the cycle in the sequence. Step-by-step Explanation Brent’s algorithm uses two pointers to traverse the sequence: a slow pointer (tortoise) and a fast pointer (hare). The algorithm starts by setting the slow pointer to the initial value in the sequence and the fast pointer to the next value in the sequence. It then repeatedly moves the slow pointer one step at a time and the fast pointer two steps at a time, until they meet at a value that has been visited before. At this point, the algorithm starts a second phase. It sets the fast pointer to the value of the slow pointer and starts moving the slow pointer one step at a time again. It also keeps track of the distance the fast pointer has moved since it was last equal to the slow pointer. When the fast pointer catches up to the slow pointer again, the distance it has moved is the length of the cycle in the sequence. The algorithm also includes a mechanism for periodically increasing the distance the fast pointer moves, to avoid getting stuck in a loop that is not part of the cycle. Complexity Analysis The time complexity of Brent’s algorithm is O(μ + λ), where μ is the distance between the start of the sequence and the start of the cycle, and λ is the length of the cycle. This is because the algorithm performs at most 2(μ + λ) iterations of the loop, and each iteration takes O(1) time. The space complexity of the algorithm is O(1), since it only uses a constant amount of memory to store the two pointers and a few other variables. Brent’s algorithm is generally faster than Floyd’s algorithm, another cycle detection algorithm, because it uses a combination of the tortoise and hare pointers and periodic distance increases to avoid getting stuck in a loop that is not part of the cycle.]]></summary></entry><entry><title type="html">Breadth-First Search</title><link href="/algorithm/2023/11/21/breadth-first-search.html" rel="alternate" type="text/html" title="Breadth-First Search" /><published>2023-11-21T02:00:00+02:00</published><updated>2023-11-21T02:00:00+02:00</updated><id>/algorithm/2023/11/21/breadth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/breadth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of BFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">bfs</span> <span class="p">(</span><span class="n">graph</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span><span class="p">)</span> <span class="p">(</span><span class="n">start</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">queue</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">queue</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">visited</span>
    <span class="o">|</span> <span class="n">node</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span>
          <span class="n">explore</span> <span class="n">visited</span> <span class="n">rest</span>
        <span class="k">else</span>
          <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">new_nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">n</span> <span class="n">visited</span><span class="p">))</span> <span class="n">neighbors</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">updated_queue</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">@</span> <span class="n">new_nodes</span> <span class="k">in</span>
          <span class="n">explore</span> <span class="p">(</span><span class="n">visited</span> <span class="o">@</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="n">updated_queue</span>
  <span class="k">in</span> <span class="n">explore</span> <span class="bp">[]</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> parameter is a list of tuples, where the first element is a node and the second element is a list of its neighboring nodes. The <code class="language-plaintext highlighter-rouge">start</code> parameter is the node where the search begins. The function returns a list of nodes visited in breadth-first order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">bfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span>
  <span class="p">[</span>
    <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"A"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"F"</span><span class="p">]);</span>
    <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"C"</span><span class="p">;</span> <span class="s2">"E"</span><span class="p">]);</span>
  <span class="p">]</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span> <span class="n">graph</span> <span class="s2">"A"</span> <span class="c">(* ["A"; "B"; "C"; "D"; "E"; "F"] *)</span>

<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create an empty <code class="language-plaintext highlighter-rouge">visited</code> list and a <code class="language-plaintext highlighter-rouge">queue</code> with the starting node in it.</li>
  <li>While the <code class="language-plaintext highlighter-rouge">queue</code> is not empty, take the first node from the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has already been visited, skip it and continue to the next node in the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>If the node has not been visited, add it to the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
  <li>Get the list of neighboring nodes for the current node from the <code class="language-plaintext highlighter-rouge">graph</code>.</li>
  <li>Filter out the nodes that have already been visited.</li>
  <li>Add the remaining nodes to the end of the <code class="language-plaintext highlighter-rouge">queue</code>.</li>
  <li>Repeat steps 2-7 until the <code class="language-plaintext highlighter-rouge">queue</code> is empty.</li>
  <li>Return the <code class="language-plaintext highlighter-rouge">visited</code> list.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V| + |E|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices and <code class="language-plaintext highlighter-rouge">|E|</code> is the number of edges in the graph. This is because BFS visits each vertex and edge exactly once.</p>

<p>The space complexity of BFS is <code class="language-plaintext highlighter-rouge">O(|V|)</code>, where <code class="language-plaintext highlighter-rouge">|V|</code> is the number of vertices in the graph. This is because BFS uses a queue to store the nodes to be visited, and the maximum size of the queue is the number of vertices at the maximum depth of the graph. In the worst case, this is all the vertices, so the space complexity is <code class="language-plaintext highlighter-rouge">O(|V|)</code>.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Breadth First Search (BFS) is a graph traversal algorithm that explores all the vertices of a graph in breadth-first order. It starts at the tree root (or some arbitrary node of a graph) and explores all the neighboring nodes at the present depth before moving on to the nodes at the next depth level. BFS is often used to find the shortest path between two nodes in an unweighted graph. Implementation Here is an implementation of BFS in OCaml: ```ocaml type ‘a graph = (‘a * ‘a list) list]]></summary></entry><entry><title type="html">Depth-First Search</title><link href="/algorithm/2023/11/21/depth-first-search.html" rel="alternate" type="text/html" title="Depth-First Search" /><published>2023-11-21T01:00:00+02:00</published><updated>2023-11-21T01:00:00+02:00</updated><id>/algorithm/2023/11/21/depth-first-search</id><content type="html" xml:base="/algorithm/2023/11/21/depth-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of DFS in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="kt">list</span><span class="p">)</span> <span class="kt">list</span>  
  
<span class="k">let</span> <span class="k">rec</span> <span class="n">explore</span> <span class="n">visited</span> <span class="n">graph</span> <span class="n">node</span> <span class="o">=</span>  
  <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">node</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">visited</span>  
  <span class="k">else</span> <span class="n">node</span> <span class="o">::</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">explore</span> <span class="n">acc</span> <span class="n">graph</span> <span class="n">n</span><span class="p">)</span> <span class="n">visited</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">assoc</span> <span class="n">node</span> <span class="n">graph</span><span class="p">)</span>  
  
<span class="k">let</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="n">start</span> <span class="o">=</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="p">(</span><span class="n">explore</span> <span class="bp">[]</span> <span class="n">graph</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">graph</code> is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">explore</code> function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The <code class="language-plaintext highlighter-rouge">visited</code> parameter keeps track of the visited nodes to avoid visiting them again. The <code class="language-plaintext highlighter-rouge">dfs</code> function calls <code class="language-plaintext highlighter-rouge">explore</code> with an empty <code class="language-plaintext highlighter-rouge">visited</code> list and the starting node and returns the visited nodes in reverse order.</p>

<p>Here is an example of using the <code class="language-plaintext highlighter-rouge">dfs</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"B"</span><span class="p">;</span> <span class="s2">"C"</span><span class="p">;</span> <span class="s2">"D"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"E"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"F"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">);</span>  
             <span class="p">(</span><span class="s2">"F"</span><span class="o">,</span> <span class="p">[</span><span class="s2">"G"</span><span class="p">]);</span>  
             <span class="p">(</span><span class="s2">"G"</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)]</span>  
  
<span class="k">let</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">dfs</span> <span class="n">graph</span> <span class="s2">"A"</span>  
  
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="n">print_endline</span> <span class="n">visited</span>
</code></pre></div></div>

<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
B  
E  
C  
F  
G  
D  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start at the given starting node.</li>
  <li>Mark the node as visited and add it to the visited list.</li>
  <li>For each adjacent node that is not visited, recursively call <code class="language-plaintext highlighter-rouge">explore</code> with the visited list and the adjacent node.</li>
  <li>Return the visited list in reverse order.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Depth First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It is a fundamental algorithm in computer science and has many applications such as finding connected components, topological sorting, and solving puzzles like the maze. Implementation Here is an implementation of DFS in OCaml: type 'a graph = ('a * 'a list) list let rec explore visited graph node = if List.mem node visited then visited else node :: List.fold_left (fun acc n -&gt; explore acc graph n) visited (List.assoc node graph) let dfs graph start = List.rev (explore [] graph start) The graph is represented as a list of pairs, where each pair consists of a node and its adjacent nodes. The explore function recursively explores the graph by visiting each unvisited node and its adjacent nodes. The visited parameter keeps track of the visited nodes to avoid visiting them again. The dfs function calls explore with an empty visited list and the starting node and returns the visited nodes in reverse order. Here is an example of using the dfs function: let graph = [("A", ["B"; "C"; "D"]); ("B", ["E"]); ("C", ["F"]); ("D", []); ("E", []); ("F", ["G"]); ("G", [])] let visited = dfs graph "A" let () = List.iter print_endline visited The output should be: A B E C F G D Step-by-step Explanation Start at the given starting node. Mark the node as visited and add it to the visited list. For each adjacent node that is not visited, recursively call explore with the visited list and the adjacent node. Return the visited list in reverse order. Complexity Analysis The time complexity of DFS is O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges in the graph. This is because DFS visits each vertex and each edge once. The space complexity is O(|V|), where |V| is the maximum number of vertices in the recursion stack. This is because DFS stores the visited nodes in a list and uses recursion to explore the graph, which creates a stack of function calls.]]></summary></entry><entry><title type="html">Insertion Sort</title><link href="/algorithm/2023/11/20/insertion-sort.html" rel="alternate" type="text/html" title="Insertion Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/insertion-sort</id><content type="html" xml:base="/algorithm/2023/11/20/insertion-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of insertion sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">insertion_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">insertion_sort</span> <span class="n">xs</span><span class="p">)</span>  
<span class="ow">and</span> <span class="n">insert</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>  
</code></pre></div></div>

<p>This implementation uses a recursive function to sort the list. The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function takes a list as input and returns a sorted list. The <code class="language-plaintext highlighter-rouge">insert</code> function takes an element <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input and returns a new sorted list with <code class="language-plaintext highlighter-rouge">x</code> inserted in the correct position.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>The <code class="language-plaintext highlighter-rouge">insertion_sort</code> function is called with a list as input.</li>
  <li>If the list is empty, an empty list is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">x</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called with <code class="language-plaintext highlighter-rouge">x</code> and the sorted list returned by a recursive call to <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">insert</code> function takes <code class="language-plaintext highlighter-rouge">x</code> and a sorted list as input.</li>
  <li>If the list is empty, a list with <code class="language-plaintext highlighter-rouge">x</code> as the only element is returned.</li>
  <li>Otherwise, the first element <code class="language-plaintext highlighter-rouge">y</code> is removed from the list and the <code class="language-plaintext highlighter-rouge">insert</code> function is called recursively with <code class="language-plaintext highlighter-rouge">x</code> and the remaining list <code class="language-plaintext highlighter-rouge">ys</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">x</code> is less than <code class="language-plaintext highlighter-rouge">y</code>, a new list with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> followed by <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>Otherwise, a new list with <code class="language-plaintext highlighter-rouge">y</code> followed by the result of calling <code class="language-plaintext highlighter-rouge">insert</code> with <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">ys</code> is returned.</li>
  <li>The sorted list returned by <code class="language-plaintext highlighter-rouge">insert</code> is returned by <code class="language-plaintext highlighter-rouge">insertion_sort</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Insertion sort is a simple sorting algorithm that is widely used in computer science. It works by taking one element from the unsorted list and inserting it into the correct position in the sorted list. The algorithm is efficient for small data sets but becomes inefficient for larger ones. Insertion sort can be used in situations where the data is already partially sorted or where the cost of swapping elements is high. Implementation Here is an implementation of insertion sort in OCaml: let rec insertion_sort = function | [] -&gt; [] | x :: xs -&gt; insert x (insertion_sort xs) and insert x = function | [] -&gt; [x] | y :: ys -&gt; if x &lt; y then x :: y :: ys else y :: insert x ys This implementation uses a recursive function to sort the list. The insertion_sort function takes a list as input and returns a sorted list. The insert function takes an element x and a sorted list as input and returns a new sorted list with x inserted in the correct position. Step-by-step Explanation The insertion_sort function is called with a list as input. If the list is empty, an empty list is returned. Otherwise, the first element x is removed from the list and the insert function is called with x and the sorted list returned by a recursive call to insertion_sort. The insert function takes x and a sorted list as input. If the list is empty, a list with x as the only element is returned. Otherwise, the first element y is removed from the list and the insert function is called recursively with x and the remaining list ys. If x is less than y, a new list with x and y followed by ys is returned. Otherwise, a new list with y followed by the result of calling insert with x and ys is returned. The sorted list returned by insert is returned by insertion_sort. Complexity Analysis The time complexity of insertion sort is O(n^2) in the worst case, where n is the number of elements in the list. This is because each element must be compared to every other element in the list, resulting in n^2 comparisons. However, in the best case (when the list is already sorted), the time complexity is O(n) because each element only needs to be compared to the previous element. The space complexity of insertion sort is O(1) because the algorithm sorts the list in place without using any additional memory.]]></summary></entry><entry><title type="html">Radix Sort</title><link href="/algorithm/2023/11/20/radix-sort.html" rel="alternate" type="text/html" title="Radix Sort" /><published>2023-11-20T23:15:00+02:00</published><updated>2023-11-20T23:15:00+02:00</updated><id>/algorithm/2023/11/20/radix-sort</id><content type="html" xml:base="/algorithm/2023/11/20/radix-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of radix sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">arr</span> <span class="n">exp</span> <span class="o">=</span>  
    <span class="k">if</span> <span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span> <span class="k">else</span>  
      <span class="k">let</span> <span class="n">zeroes</span><span class="o">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>  
      <span class="n">loop</span> <span class="n">zeroes</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">loop</span> <span class="n">ones</span> <span class="p">(</span><span class="n">exp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  
  <span class="k">in</span>  
  <span class="n">loop</span> <span class="n">arr</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">m</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">m</span> <span class="p">(</span><span class="n">int_of_float</span> <span class="p">(</span><span class="n">log10</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))))</span> <span class="mi">0</span> <span class="n">arr</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">radix_sort</code> takes in an array of integers <code class="language-plaintext highlighter-rouge">arr</code> and returns a sorted array. The <code class="language-plaintext highlighter-rouge">loop</code> function recursively sorts the array by partitioning it into two subarrays based on the value of the <code class="language-plaintext highlighter-rouge">exp</code>-th bit (starting from the most significant bit). The <code class="language-plaintext highlighter-rouge">exp</code> parameter is initially set to the maximum number of digits in any element of the array. The function <code class="language-plaintext highlighter-rouge">log10</code> is used to calculate the number of digits in each element.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum number of digits in any element of the array.</li>
  <li>For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit.</li>
  <li>Recursively sort each subarray by repeating step 2 with the next bit position.</li>
  <li>Concatenate the sorted subarrays to get the final sorted array.</li>
</ol>

<p>For example, let’s say we have the following array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 45, 75, 90, 802, 24, 2, 66]  
</code></pre></div></div>

<p>The maximum number of digits is 3, so we start by partitioning the array based on the third bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[170, 90, 802, 2, 24, 45, 75, 66]  
</code></pre></div></div>

<p>We then recursively sort each subarray by partitioning based on the second bit:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[802, 2, 24, 45, 66, 170, 75, 90]  
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<p>Finally, we concatenate the sorted subarrays to get the final sorted array:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[2, 24, 45, 66, 75, 90, 170, 802]  
</code></pre></div></div>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k).</p>

<p>In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Radix sort is a sorting algorithm that sorts elements by grouping them based on their digits or bits. It is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by individual digits that share the same significant position and value. Radix sort is often used for sorting large numbers of records, such as in big data applications. Implementation Here is an implementation of radix sort in OCaml: let radix_sort arr = let rec loop arr exp = if exp &lt; 0 then arr else let zeroes, ones = List.partition (fun x -&gt; x land (1 lsl exp) = 0) arr in loop zeroes (exp - 1) @ loop ones (exp - 1) in loop arr (List.fold_left (fun m x -&gt; max m (int_of_float (log10 (float_of_int x)))) 0 arr) Here, radix_sort takes in an array of integers arr and returns a sorted array. The loop function recursively sorts the array by partitioning it into two subarrays based on the value of the exp-th bit (starting from the most significant bit). The exp parameter is initially set to the maximum number of digits in any element of the array. The function log10 is used to calculate the number of digits in each element. Step-by-step Explanation Find the maximum number of digits in any element of the array. For each bit position starting from the most significant bit, partition the array into two subarrays based on the value of that bit. Recursively sort each subarray by repeating step 2 with the next bit position. Concatenate the sorted subarrays to get the final sorted array. For example, let’s say we have the following array: [170, 45, 75, 90, 802, 24, 2, 66] The maximum number of digits is 3, so we start by partitioning the array based on the third bit: [170, 90, 802, 2, 24, 45, 75, 66] We then recursively sort each subarray by partitioning based on the second bit: [802, 2, 24, 45, 66, 170, 75, 90] [2, 24, 45, 66, 75, 90, 170, 802] Finally, we concatenate the sorted subarrays to get the final sorted array: [2, 24, 45, 66, 75, 90, 170, 802] Complexity Analysis The time complexity of radix sort is O(d * (n + k)), where d is the maximum number of digits in any element of the array, n is the number of elements in the array, and k is the range of values (i.e., the maximum value minus the minimum value). The space complexity is O(n + k). In the worst case, when d is very large, radix sort can be slower than comparison-based sorting algorithms like quicksort or mergesort. However, radix sort has the advantage of being able to sort large integers and other non-comparable data types that cannot be easily sorted using comparison-based algorithms.]]></summary></entry><entry><title type="html">Merge Sort</title><link href="/algorithm/2023/11/20/mergesort.html" rel="alternate" type="text/html" title="Merge Sort" /><published>2023-11-20T23:01:00+02:00</published><updated>2023-11-20T23:01:00+02:00</updated><id>/algorithm/2023/11/20/mergesort</id><content type="html" xml:base="/algorithm/2023/11/20/mergesort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing.</p>

<h2 id="implementation">Implementation</h2>

<p>Here is an implementation of merge sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">merge_sort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>  
  <span class="o">|</span> <span class="n">xs</span> <span class="o">-&gt;</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">split</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">function</span>  
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">split</span> <span class="n">right</span> <span class="p">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">left</span><span class="p">)</span> <span class="n">xs</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="k">with</span>  
        <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">right</span>  
        <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">left</span>  
        <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="o">-&gt;</span>  
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">xs</span> <span class="n">right</span>  
            <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span> <span class="n">left</span> <span class="n">ys</span>  
      <span class="k">in</span>  
      <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">split</span> <span class="bp">[]</span> <span class="bp">[]</span> <span class="n">xs</span> <span class="k">in</span>  
      <span class="n">merge</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">merge_sort</span> <span class="n">right</span><span class="p">)</span>  
</code></pre></div></div>

<p>Here is an example of using this implementation to sort a list of integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">merge_sort</span> <span class="p">[</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">5</span><span class="p">];;</span>  
</code></pre></div></div>

<p>The resulting <code class="language-plaintext highlighter-rouge">sorted_list</code> will be <code class="language-plaintext highlighter-rouge">[1; 2; 3; 4; 5; 6; 7]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">merge_sort</code> function takes a list of elements as input.</li>
  <li>If the list is empty or contains only one element, it is already sorted, so the function returns the list as is.</li>
  <li>Otherwise, the function recursively divides the list into two halves using the <code class="language-plaintext highlighter-rouge">split</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">split</code> function takes two empty lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and the original list as input.</li>
  <li>If the original list is empty, the function returns the two half lists.</li>
  <li>Otherwise, the function takes the first element of the original list and adds it to the <code class="language-plaintext highlighter-rouge">right</code> list, while the rest of the list is recursively split with the <code class="language-plaintext highlighter-rouge">right</code> list becoming the new <code class="language-plaintext highlighter-rouge">left</code> list.</li>
  <li>The <code class="language-plaintext highlighter-rouge">merge</code> function takes two sorted lists (<code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) as input and returns a single sorted list.</li>
  <li>If one of the input lists is empty, the function returns the other list as is.</li>
  <li>Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list.</li>
  <li>The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty.</li>
  <li>Finally, the <code class="language-plaintext highlighter-rouge">merge_sort</code> function merges the two sorted halves of the original list using the <code class="language-plaintext highlighter-rouge">merge</code> function.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n).</p>

<p>The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Merge sort is a divide-and-conquer algorithm that sorts an array or list of elements by recursively dividing it into two halves, sorting each half, and then merging the sorted halves back together. It is a highly efficient sorting algorithm with a time complexity of O(n log n), making it suitable for large datasets. Merge sort is widely used in various applications, including sorting large databases, numerical analysis, and parallel computing. Implementation Here is an implementation of merge sort in OCaml: let rec merge_sort = function | [] -&gt; [] | [x] -&gt; [x] | xs -&gt; let rec split left right = function | [] -&gt; (left, right) | x :: xs -&gt; split right (x :: left) xs in let rec merge left right = match left, right with | [], _ -&gt; right | _, [] -&gt; left | x :: xs, y :: ys -&gt; if x &lt; y then x :: merge xs right else y :: merge left ys in let left, right = split [] [] xs in merge (merge_sort left) (merge_sort right) Here is an example of using this implementation to sort a list of integers: let sorted_list = merge_sort [4; 2; 7; 1; 3; 6; 5];; The resulting sorted_list will be [1; 2; 3; 4; 5; 6; 7]. Step-by-step Explanation The merge_sort function takes a list of elements as input. If the list is empty or contains only one element, it is already sorted, so the function returns the list as is. Otherwise, the function recursively divides the list into two halves using the split function. The split function takes two empty lists (left and right) and the original list as input. If the original list is empty, the function returns the two half lists. Otherwise, the function takes the first element of the original list and adds it to the right list, while the rest of the list is recursively split with the right list becoming the new left list. The merge function takes two sorted lists (left and right) as input and returns a single sorted list. If one of the input lists is empty, the function returns the other list as is. Otherwise, the function compares the first elements of the two lists and adds the smaller one to the output list. The function then recursively calls itself with the remaining elements of the input lists until both input lists are empty. Finally, the merge_sort function merges the two sorted halves of the original list using the merge function. Complexity Analysis The time complexity of merge sort is O(n log n), where n is the number of elements in the input list. This is because the algorithm recursively divides the input list into halves until each half contains only one element, which takes O(log n) time. Then, the algorithm merges the sorted halves back together, which takes O(n) time. Therefore, the total time complexity is O(n log n). The space complexity of merge sort is O(n), where n is the number of elements in the input list. This is because the algorithm creates temporary lists to store the halves of the input list during the merge process. However, these temporary lists are deallocated after each recursive call, so the overall space complexity is O(n).]]></summary></entry><entry><title type="html">Heapsort</title><link href="/algorithm/2023/11/20/heapsort.html" rel="alternate" type="text/html" title="Heapsort" /><published>2023-11-20T22:04:00+02:00</published><updated>2023-11-20T22:04:00+02:00</updated><id>/algorithm/2023/11/20/heapsort</id><content type="html" xml:base="/algorithm/2023/11/20/heapsort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of heapsort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
  <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">left</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">largest</span><span class="p">)</span> <span class="k">then</span>
    <span class="n">largest</span> <span class="o">:=</span> <span class="n">right</span><span class="p">;</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">largest</span> <span class="o">&lt;&gt;</span> <span class="n">i</span> <span class="k">then</span> <span class="p">(</span>
    <span class="n">swap</span> <span class="n">arr</span> <span class="n">i</span> <span class="o">!</span><span class="n">largest</span><span class="p">;</span>
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="o">!</span><span class="n">largest</span>
  <span class="p">)</span>

<span class="k">let</span> <span class="n">heapsort</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">n</span> <span class="n">i</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">swap</span> <span class="n">arr</span> <span class="mi">0</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">heapify</span> <span class="n">arr</span> <span class="n">i</span> <span class="mi">0</span>
  <span class="k">done</span>
</code></pre></div></div>

<p>Here is an example of how to use the heapsort function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">4</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">3</span><span class="o">|</span><span class="p">]</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">heapsort</span> <span class="n">arr</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">arr</span> 
</code></pre></div></div>

<p>Output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 3 4 7  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Build a max heap from the input data. A binary heap is a complete binary tree where each node is greater than or equal to its children. The largest element is stored at the root of the heap.</li>
  <li>Swap the root node with the last element in the array. Decrease the heap size by 1.</li>
  <li>Call heapify on the root node to restore the heap property.</li>
  <li>Repeat steps 2-3 until the heap size is 1.</li>
</ol>

<p>The heapify function takes three arguments: the array to be sorted, the size of the heap, and the index of the current node. It compares the current node with its left and right children and swaps it with the largest child if necessary. It then recursively calls heapify on the largest child to ensure that the subtree rooted at the current node is also a heap.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of heapsort is O(n log n) in the worst case. Building the heap takes O(n) time, and each call to heapify takes O(log n) time. We call heapify n-1 times in the second loop, so the total time complexity is O(n log n).</p>

<p>Heapsort is an in-place sorting algorithm, so it requires no additional memory beyond the array to be sorted. However, it is not a stable sorting algorithm, meaning that it does not preserve the relative order of equal elements in the input array.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Heapsort is a comparison-based sorting algorithm that uses a binary heap data structure. It was first proposed by J. W. J. Williams in 1964. Heapsort is an in-place algorithm, meaning that it sorts the array in place, without needing any additional memory. It has a time complexity of O(n log n), which makes it efficient for large data sets. Implementation Here is an implementation of heapsort in OCaml: ```ocaml let swap arr i j = let temp = arr.(i) in arr.(i) &lt;- arr.(j); arr.(j) &lt;- temp]]></summary></entry><entry><title type="html">Quicksort</title><link href="/algorithm/2023/11/20/quicksort.html" rel="alternate" type="text/html" title="Quicksort" /><published>2023-11-20T20:46:37+02:00</published><updated>2023-11-20T20:46:37+02:00</updated><id>/algorithm/2023/11/20/quicksort</id><content type="html" xml:base="/algorithm/2023/11/20/quicksort.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Quicksort was developed by British computer scientist Tony Hoare in 1959. It is one of the most widely used sorting algorithms and is commonly used in computer science and engineering applications.</p>

<p>Quicksort is particularly useful when sorting large datasets because it has an average time complexity of O(n log n), which is faster than many other sorting algorithms. It is also an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input array.</p>

<p>Quicksort is used in a variety of applications, including sorting large databases, sorting elements in computer graphics and image processing, and in network routing algorithms. It is also used in many programming languages as a built-in sorting function, such as Python’s <code class="language-plaintext highlighter-rouge">sorted()</code> function and C++’s <code class="language-plaintext highlighter-rouge">std::sort()</code> function.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">quicksort</span> <span class="o">=</span> <span class="k">function</span>  
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
  <span class="o">|</span> <span class="n">pivot</span><span class="o">::</span><span class="n">tail</span> <span class="o">-&gt;</span>  
    <span class="k">let</span> <span class="n">lesser</span><span class="o">,</span> <span class="n">greater</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">partition</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="n">tail</span> <span class="k">in</span>  
    <span class="n">quicksort</span> <span class="n">lesser</span> <span class="o">@</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">@</span> <span class="n">quicksort</span> <span class="n">greater</span>  
</code></pre></div></div>

<p>This implementation uses a functional programming style and takes advantage of pattern matching to handle the two cases of the input list: the empty list, which is already sorted, and a non-empty list, which is partitioned into two sub-lists based on a pivot element (in this case, the first element of the list).</p>

<p>The <code class="language-plaintext highlighter-rouge">List.partition</code> function is used to split the tail of the input list into two sub-lists: <code class="language-plaintext highlighter-rouge">lesser</code>, which contains all elements that are strictly less than the pivot, and <code class="language-plaintext highlighter-rouge">greater</code>, which contains all elements that are greater than or equal to the pivot. The <code class="language-plaintext highlighter-rouge">@</code> operator is used to concatenate the sorted <code class="language-plaintext highlighter-rouge">lesser</code> sub-list, the pivot element, and the sorted <code class="language-plaintext highlighter-rouge">greater</code> sub-list into a single sorted list.</p>

<p>Here’s an example usage of the <code class="language-plaintext highlighter-rouge">quicksort</code> function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let unsorted = [5; 1; 3; 9; 2]  
let sorted = quicksort unsorted 
let () = List.iter print_int sorted 
</code></pre></div></div>

<p>After running this code, the <code class="language-plaintext highlighter-rouge">sorted</code> variable should contain the list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>, which is the sorted version of the <code class="language-plaintext highlighter-rouge">unsorted</code> list.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<p>Here’s a step-by-step explanation of how the quicksort algorithm works:</p>

<ol>
  <li>
    <p>Choose a pivot element from the list. This can be any element, but a common choice is the first or last element in the list.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists, with one sub-list containing elements less than the pivot and the other sub-list containing elements greater than or equal to the pivot. This can be done by iterating through the list and swapping elements as necessary to ensure that all elements less than the pivot are on one side of the pivot and all elements greater than or equal to the pivot are on the other side.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists until the entire list is sorted. This can be done by calling the quicksort function on each sub-list.</p>
  </li>
</ol>

<p>Here’s an example of how this algorithm would sort the list <code class="language-plaintext highlighter-rouge">[5; 1; 3; 9; 2]</code>:</p>

<ol>
  <li>
    <p>Choose the first element, <code class="language-plaintext highlighter-rouge">5</code>, as the pivot.</p>
  </li>
  <li>
    <p>Partition the list into two sub-lists: <code class="language-plaintext highlighter-rouge">[1; 3; 2]</code> and <code class="language-plaintext highlighter-rouge">[9]</code>. All elements less than <code class="language-plaintext highlighter-rouge">5</code> are on the left and all elements greater than or equal to <code class="language-plaintext highlighter-rouge">5</code> are on the right.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to each sub-list. For the left sub-list, choose <code class="language-plaintext highlighter-rouge">1</code> as the pivot and partition it into <code class="language-plaintext highlighter-rouge">[ ]</code>, <code class="language-plaintext highlighter-rouge">[1]</code>, and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. For the right sub-list, it is already sorted.</p>
  </li>
  <li>
    <p>Recursively apply steps 1 and 2 to the sub-lists <code class="language-plaintext highlighter-rouge">[1]</code> and <code class="language-plaintext highlighter-rouge">[3; 2]</code>. Both sub-lists are already sorted, so no further partitioning is necessary.</p>
  </li>
  <li>
    <p>Concatenate the sorted sub-lists in the order <code class="language-plaintext highlighter-rouge">[1]</code>, <code class="language-plaintext highlighter-rouge">[2; 3]</code>, <code class="language-plaintext highlighter-rouge">[5]</code>, and <code class="language-plaintext highlighter-rouge">[9]</code> to obtain the sorted list <code class="language-plaintext highlighter-rouge">[1; 2; 3; 5; 9]</code>.</p>
  </li>
</ol>

<p>This example shows how the quicksort algorithm works by recursively dividing the input list into smaller sub-lists, sorting them, and then combining them to obtain the final sorted list.</p>

<h2 id="complexity">Complexity</h2>

<p>The time complexity of quicksort is O(n log n) on average, where n is the number of elements in the input list.</p>

<p>The average case occurs when the pivot element is chosen randomly and is close to the median value of the list. In this case, the list is divided roughly in half with each partition, and the algorithm will make log n recursive calls to sort the entire list. The partitioning step takes linear time, so the total time complexity is O(n log n).</p>

<p>However, in the worst case, quicksort can have a time complexity of O(n^2) if the pivot element is consistently chosen poorly. For example, if the pivot is always chosen as the smallest or largest element in the list, then each partition will only remove one element from the list, and the algorithm will make n recursive calls to sort the entire list. This worst-case scenario is rare in practice, but it can occur in certain edge cases.</p>

<p>In terms of space complexity, quicksort is an in-place sorting algorithm, meaning that it does not require any additional memory beyond the input list. However, the recursive nature of the algorithm means that it has a space complexity of O(log n) due to the call stack used for the recursive calls.</p>

<p>Overall, quicksort is a highly efficient sorting algorithm with a time complexity of O(n log n) on average, making it a popular choice for sorting large datasets.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Selection Sort</title><link href="/algorithm/2023/11/10/shell-sort.html" rel="alternate" type="text/html" title="Selection Sort" /><published>2023-11-10T23:00:00+02:00</published><updated>2023-11-10T23:00:00+02:00</updated><id>/algorithm/2023/11/10/shell-sort</id><content type="html" xml:base="/algorithm/2023/11/10/shell-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Shell sort is an efficient sorting algorithm that is a variation of insertion sort. It was invented by Donald Shell in 1959. The algorithm works by sorting elements that are far apart from each other and then gradually reducing the gap between them. This makes the algorithm faster than insertion sort for larger lists.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Shell sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">shell_sort</span> <span class="n">arr</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">in</span>  
  <span class="k">while</span> <span class="o">!</span><span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">do</span>  
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="o">!</span><span class="n">gap</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>  
      <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>  
      <span class="k">let</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">i</span> <span class="k">in</span>  
      <span class="k">while</span> <span class="o">!</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="o">!</span><span class="n">gap</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="k">do</span>  
        <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span><span class="p">);</span>  
        <span class="n">j</span> <span class="o">:=</span> <span class="o">!</span><span class="n">j</span> <span class="o">-</span> <span class="o">!</span><span class="n">gap</span>  
      <span class="k">done</span><span class="p">;</span>  
      <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">temp</span>  
    <span class="k">done</span><span class="p">;</span>  
    <span class="n">gap</span> <span class="o">:=</span> <span class="o">!</span><span class="n">gap</span> <span class="o">/</span> <span class="mi">2</span>  
  <span class="k">done</span><span class="p">;</span>  
  <span class="n">arr</span>  
</code></pre></div></div>

<p>To use this function, simply pass in an array of elements to sort:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">8</span><span class="p">;</span> <span class="mi">4</span><span class="p">;</span> <span class="mi">2</span> <span class="o">|</span><span class="p">]</span>  
<span class="k">let</span> <span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">shell_sort</span> <span class="n">arr</span>  
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">sorted_arr</code> variable will contain the sorted array.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Start by dividing the list into sublists of equal intervals. The interval is called the gap.</li>
  <li>Sort each sublist using insertion sort.</li>
  <li>Reduce the gap by half and repeat step 2 until the gap is 1.</li>
</ol>

<p>For example, let’s say we have the following list of integers: <code class="language-plaintext highlighter-rouge">[5, 3, 8, 4, 2]</code>. We’ll use a gap of 2 for the first pass.</p>

<ol>
  <li>Divide the list into sublists with a gap of 2: <code class="language-plaintext highlighter-rouge">[5, 8, 2]</code> and <code class="language-plaintext highlighter-rouge">[3, 4]</code>.</li>
  <li>Sort each sublist using insertion sort. The first sublist becomes <code class="language-plaintext highlighter-rouge">[2, 5, 8]</code> and the second sublist stays the same: <code class="language-plaintext highlighter-rouge">[3, 4]</code>.</li>
  <li>Reduce the gap to 1 and sort the entire list using insertion sort. The sorted list is <code class="language-plaintext highlighter-rouge">[2, 3, 4, 5, 8]</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Shell sort depends on the gap sequence used. The worst-case time complexity is O(n^2), which occurs when the gap sequence is 1, making the algorithm equivalent to insertion sort. However, the average-case time complexity is O(n log n), which is faster than insertion sort for larger lists.</p>

<p>The space complexity of Shell sort is O(1) because it sorts the list in place.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Shell sort is an efficient sorting algorithm that is a variation of insertion sort. It was invented by Donald Shell in 1959. The algorithm works by sorting elements that are far apart from each other and then gradually reducing the gap between them. This makes the algorithm faster than insertion sort for larger lists. Implementation Here is an implementation of Shell sort in OCaml: let shell_sort arr = let n = Array.length arr in let gap = ref (n / 2) in while !gap &gt; 0 do for i = !gap to n - 1 do let temp = arr.(i) in let j = ref i in while !j &gt;= !gap &amp;&amp; arr.(!j - !gap) &gt; temp do arr.(!j) &lt;- arr.(!j - !gap); j := !j - !gap done; arr.(!j) &lt;- temp done; gap := !gap / 2 done; arr To use this function, simply pass in an array of elements to sort: let arr = [| 5; 3; 8; 4; 2 |] let sorted_arr = shell_sort arr The sorted_arr variable will contain the sorted array. Step-by-step Explanation Start by dividing the list into sublists of equal intervals. The interval is called the gap. Sort each sublist using insertion sort. Reduce the gap by half and repeat step 2 until the gap is 1. For example, let’s say we have the following list of integers: [5, 3, 8, 4, 2]. We’ll use a gap of 2 for the first pass. Divide the list into sublists with a gap of 2: [5, 8, 2] and [3, 4]. Sort each sublist using insertion sort. The first sublist becomes [2, 5, 8] and the second sublist stays the same: [3, 4]. Reduce the gap to 1 and sort the entire list using insertion sort. The sorted list is [2, 3, 4, 5, 8]. Complexity Analysis The time complexity of Shell sort depends on the gap sequence used. The worst-case time complexity is O(n^2), which occurs when the gap sequence is 1, making the algorithm equivalent to insertion sort. However, the average-case time complexity is O(n log n), which is faster than insertion sort for larger lists. The space complexity of Shell sort is O(1) because it sorts the list in place.]]></summary></entry><entry><title type="html">Counting Sort</title><link href="/algorithm/2023/11/10/counting-sort.html" rel="alternate" type="text/html" title="Counting Sort" /><published>2023-11-10T20:00:00+02:00</published><updated>2023-11-10T20:00:00+02:00</updated><id>/algorithm/2023/11/10/counting-sort</id><content type="html" xml:base="/algorithm/2023/11/10/counting-sort.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Counting sort is an efficient sorting algorithm that can be used to sort elements in a range of integers. It is a non-comparison based sorting algorithm that works by counting the number of occurrences of each element in the array and then using this information to determine the position of each element in the sorted output array.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of counting sort in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">counting_sort</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max_val</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">max</span> <span class="n">acc</span> <span class="n">x</span><span class="p">)</span> <span class="n">arr</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">count_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">index_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">fill_index_arr</span> <span class="n">i</span> <span class="n">j</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_val</span> <span class="k">then</span>
      <span class="k">begin</span>
        <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">fill_index_arr</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">count_arr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
      <span class="k">end</span>
  <span class="k">in</span>
  <span class="n">fill_index_arr</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">sorted_arr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span><span class="p">)</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iteri</span> <span class="p">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">sorted_arr</span><span class="o">.</span><span class="p">(</span><span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="p">;</span> <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">index_arr</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">arr</span><span class="p">;</span>
  <span class="n">sorted_arr</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">arr</code> is the input array to be sorted. The function <code class="language-plaintext highlighter-rouge">counting_sort</code> first finds the maximum value in the input array and creates a new array <code class="language-plaintext highlighter-rouge">count_arr</code> to count the number of occurrences of each element in the input array. It then creates another array <code class="language-plaintext highlighter-rouge">index_arr</code> to store the index of each element in the sorted output array. The function <code class="language-plaintext highlighter-rouge">fill_index_arr</code> is a helper function that fills in the <code class="language-plaintext highlighter-rouge">index_arr</code> array based on the counts in <code class="language-plaintext highlighter-rouge">count_arr</code>. Finally, the function creates a new array <code class="language-plaintext highlighter-rouge">sorted_arr</code> and fills it in by iterating over the input array and using the <code class="language-plaintext highlighter-rouge">index_arr</code> array to determine the position of each element in the sorted output array.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span><span class="mi">5</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">6</span><span class="o">|</span><span class="p">]</span>
<span class="k">let</span> <span class="n">sorted_arr</span> <span class="o">=</span> <span class="n">counting_sort</span> <span class="n">arr</span>
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"%d "</span><span class="p">)</span> <span class="n">sorted_arr</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Find the maximum value in the input array.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">count_arr</code> of length <code class="language-plaintext highlighter-rouge">max_val + 1</code> and initialize all elements to 0.</li>
  <li>Iterate over the input array and increment the count of each element in <code class="language-plaintext highlighter-rouge">count_arr</code>.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">index_arr</code> of length <code class="language-plaintext highlighter-rouge">max_val + 1</code> and initialize all elements to 0.</li>
  <li>Define a helper function <code class="language-plaintext highlighter-rouge">fill_index_arr</code> that fills in the <code class="language-plaintext highlighter-rouge">index_arr</code> array based on the counts in <code class="language-plaintext highlighter-rouge">count_arr</code>. The function takes two arguments: <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>, where <code class="language-plaintext highlighter-rouge">i</code> is the current index in <code class="language-plaintext highlighter-rouge">count_arr</code> and <code class="language-plaintext highlighter-rouge">j</code> is the current index in <code class="language-plaintext highlighter-rouge">index_arr</code>.</li>
  <li>Call the <code class="language-plaintext highlighter-rouge">fill_index_arr</code> function with initial arguments <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">0</code>.</li>
  <li>Create a new array <code class="language-plaintext highlighter-rouge">sorted_arr</code> of length <code class="language-plaintext highlighter-rouge">n</code>, where <code class="language-plaintext highlighter-rouge">n</code> is the length of the input array.</li>
  <li>Iterate over the input array and use the <code class="language-plaintext highlighter-rouge">index_arr</code> array to determine the position of each element in the sorted output array. Store each element in the corresponding position in <code class="language-plaintext highlighter-rouge">sorted_arr</code>.</li>
  <li>Return <code class="language-plaintext highlighter-rouge">sorted_arr</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of counting sort is O(n + k), where n is the length of the input array and k is the range of the input integers. The space complexity is also O(n + k).</p>

<p>The algorithm iterates over the input array twice: once to count the occurrences of each element and once to fill in the sorted output array. The time complexity of these two iterations is O(n). The algorithm also creates two additional arrays: <code class="language-plaintext highlighter-rouge">count_arr</code> and <code class="language-plaintext highlighter-rouge">index_arr</code>, each of length k. Therefore, the space complexity of the algorithm is O(n + k).</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Counting sort is an efficient sorting algorithm that can be used to sort elements in a range of integers. It is a non-comparison based sorting algorithm that works by counting the number of occurrences of each element in the array and then using this information to determine the position of each element in the sorted output array. Implementation Here is an implementation of counting sort in OCaml: let counting_sort arr = let max_val = Array.fold_left (fun acc x -&gt; max acc x) arr.(0) arr in let count_arr = Array.make (max_val + 1) 0 in Array.iter (fun x -&gt; count_arr.(x) &lt;- count_arr.(x) + 1) arr; let index_arr = Array.make (max_val + 1) 0 in let rec fill_index_arr i j = if i &lt;= max_val then begin index_arr.(i) &lt;- j; fill_index_arr (i + 1) (j + count_arr.(i)) end in fill_index_arr 0 0; let sorted_arr = Array.make (Array.length arr) 0 in Array.iteri (fun i x -&gt; sorted_arr.(index_arr.(x)) &lt;- x; index_arr.(x) &lt;- index_arr.(x) + 1) arr; sorted_arr Here, arr is the input array to be sorted. The function counting_sort first finds the maximum value in the input array and creates a new array count_arr to count the number of occurrences of each element in the input array. It then creates another array index_arr to store the index of each element in the sorted output array. The function fill_index_arr is a helper function that fills in the index_arr array based on the counts in count_arr. Finally, the function creates a new array sorted_arr and fills it in by iterating over the input array and using the index_arr array to determine the position of each element in the sorted output array.]]></summary></entry></feed>