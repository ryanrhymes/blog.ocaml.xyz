<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-11-27T23:23:09+02:00</updated><id>/feed.xml</id><title type="html">Algorithm Blog</title><subtitle>Explore the elegance of classic and numerical algorithms through practical OCaml implementations, unraveling their inner workings and unveiling the art and science of algorithmic programming.</subtitle><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><entry><title type="html">A* (A-Star) Algorithm</title><link href="/algorithm/2023/11/22/a-star.html" rel="alternate" type="text/html" title="A* (A-Star) Algorithm" /><published>2023-11-22T09:00:00+02:00</published><updated>2023-11-22T09:00:00+02:00</updated><id>/algorithm/2023/11/22/a-star</id><content type="html" xml:base="/algorithm/2023/11/22/a-star.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step.</p>

<h2 id="implementation">Implementation</h2>

<p>The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function <code class="language-plaintext highlighter-rouge">find_path</code> takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">IntPairs</span> <span class="o">=</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span>
    <span class="k">let</span> <span class="n">compare</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span><span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span><span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
      <span class="k">match</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">x0</span> <span class="n">x1</span> <span class="k">with</span>
      <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">y0</span> <span class="n">y1</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="k">end</span>

<span class="k">module</span> <span class="nc">PairsMap</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>
<span class="k">module</span> <span class="nc">PairsSet</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">IntPairs</span><span class="p">)</span>


<span class="k">let</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">max_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">get_neighbors</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">moves</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
                 <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">_x</span><span class="o">,</span> <span class="n">_y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+_</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+_</span><span class="n">y</span><span class="p">)</span> <span class="n">moves</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ms</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">max_x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">max_y</span>
        <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
      <span class="p">)</span> <span class="n">ms</span> <span class="k">in</span>
    <span class="p">(</span><span class="n">ms</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">h</span> <span class="p">(</span><span class="n">x0</span><span class="o">,</span> <span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">abs</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span> <span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="p">(</span><span class="n">h</span> <span class="n">goal</span> <span class="n">start</span><span class="p">)</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">start</span> <span class="mi">0</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">empty</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">current</span> <span class="o">=</span>
      <span class="k">let</span> <span class="n">from</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
      <span class="k">if</span> <span class="n">from</span> <span class="o">=</span> <span class="n">start</span> <span class="k">then</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">from</span><span class="o">::</span><span class="n">acc</span><span class="p">)</span> <span class="n">from</span>
    <span class="k">in</span>
    <span class="n">aux</span> <span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="n">current</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">neighbor</span> <span class="k">in</span>
    <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="n">gScore</span> <span class="n">cell</span> <span class="o">=</span>
    <span class="k">match</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">cell</span> <span class="n">gScore</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">max_int</span>
  <span class="k">in</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">is_empty</span> <span class="n">openSet</span> <span class="k">then</span> <span class="nc">None</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">current</span> <span class="o">=</span>
      <span class="nn">PairsSet</span><span class="p">.</span><span class="n">fold</span> <span class="p">(</span><span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span>
          <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p1</span> <span class="n">fScore</span>
          <span class="ow">and</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">find</span> <span class="n">p2</span> <span class="n">fScore</span> <span class="k">in</span>
          <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="k">then</span> <span class="n">p1</span> <span class="k">else</span> <span class="n">p2</span>
      <span class="p">)</span> <span class="n">openSet</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">in</span>
    <span class="k">if</span> <span class="n">current</span> <span class="o">=</span> <span class="n">goal</span> <span class="k">then</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">reconstruct_path</span> <span class="n">cameFrom</span> <span class="n">current</span><span class="p">)</span> <span class="k">else</span>
    <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">remove</span> <span class="n">current</span> <span class="n">openSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">closedSet</span> <span class="o">=</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">current</span> <span class="n">closedSet</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span> <span class="n">current</span> <span class="k">in</span>
    <span class="n">neighbors</span> <span class="o">|&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span>
        <span class="p">(</span><span class="k">fun</span> <span class="p">((</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span> <span class="k">as</span> <span class="n">v</span><span class="p">)</span> <span class="n">neighbor</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">closedSet</span> <span class="k">then</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">else</span>
            <span class="k">let</span> <span class="n">tentative_gScore</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span> <span class="n">current</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">tentative_gScore</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">then</span>
              <span class="k">let</span> <span class="n">cameFrom</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">current</span> <span class="n">cameFrom</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">gScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">tentative_gScore</span> <span class="n">gScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="n">gScore</span> <span class="n">neighbor</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="n">neighbor</span> <span class="n">goal</span><span class="p">)</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">fScore</span> <span class="o">=</span> <span class="nn">PairsMap</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">f</span> <span class="n">fScore</span> <span class="k">in</span>
              <span class="k">let</span> <span class="n">openSet</span> <span class="o">=</span>
                <span class="k">if</span> <span class="n">not</span> <span class="p">(</span><span class="nn">PairsSet</span><span class="p">.</span><span class="n">mem</span> <span class="n">neighbor</span> <span class="n">openSet</span><span class="p">)</span>
                <span class="k">then</span> <span class="nn">PairsSet</span><span class="p">.</span><span class="n">add</span> <span class="n">neighbor</span> <span class="n">openSet</span> <span class="k">else</span> <span class="n">openSet</span>
              <span class="k">in</span>
              <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">)</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="n">_find_path</span>
  <span class="k">in</span>
  <span class="n">_find_path</span> <span class="p">(</span><span class="n">openSet</span><span class="o">,</span> <span class="n">closedSet</span><span class="o">,</span> <span class="n">fScore</span><span class="o">,</span> <span class="n">gScore</span><span class="o">,</span> <span class="n">cameFrom</span><span class="p">)</span>

</code></pre></div></div>

<p>Here is an example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="o">|</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
    <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">|</span><span class="p">];</span>
  <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="p">)</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">dim_x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dim_y</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">find_path</span> <span class="n">start</span> <span class="n">goal</span> <span class="n">board</span> <span class="k">in</span>

  <span class="k">match</span> <span class="n">r</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"path not found"</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" (%d, %d)</span><span class="se">\n</span><span class="s2">"</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span><span class="p">;</span>
      <span class="k">let</span> <span class="n">_board</span> <span class="o">=</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_y</span> <span class="p">(</span><span class="k">fun</span> <span class="n">y</span> <span class="o">-&gt;</span>
          <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="n">dim_x</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span>
            <span class="k">if</span> <span class="n">board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="k">'</span><span class="o">#</span><span class="k">'</span> <span class="k">else</span> <span class="sc">'.'</span><span class="p">))</span>
      <span class="k">in</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_board</span><span class="o">.</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="k">'</span><span class="o">*</span><span class="k">'</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>

      <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span>
        <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span>
          <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">" %c"</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">)</span> <span class="n">line</span><span class="p">;</span>
        <span class="n">print_newline</span> <span class="bp">()</span>
      <span class="p">)</span> <span class="n">_board</span><span class="p">;</span>
      <span class="n">print_newline</span> <span class="bp">()</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>

<ol>
  <li>The maximum x and y coordinates of the board are obtained using the <code class="language-plaintext highlighter-rouge">Array.length</code> function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">get_neighbors</code> function takes a position (x,y) and returns a list of neighboring positions that are not obstacles.</li>
  <li>The <code class="language-plaintext highlighter-rouge">h</code> function takes two positions and returns the Manhattan distance between them.</li>
  <li>The openSet is initialized with the starting position, and the closedSet is empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">fScore</code> and <code class="language-plaintext highlighter-rouge">gScore</code> maps are initialized with the starting position, where <code class="language-plaintext highlighter-rouge">fScore</code> is the sum of <code class="language-plaintext highlighter-rouge">gScore</code> and the heuristic function.</li>
  <li>The <code class="language-plaintext highlighter-rouge">cameFrom</code> map is initialized as empty.</li>
  <li>The <code class="language-plaintext highlighter-rouge">reconstruct_path</code> function takes the <code class="language-plaintext highlighter-rouge">cameFrom</code> map and the current position and returns the path from the starting position to the current position.</li>
  <li>The <code class="language-plaintext highlighter-rouge">d</code> function takes two positions and returns the cost of moving from the first position to the second.</li>
  <li>The <code class="language-plaintext highlighter-rouge">g</code> function takes the <code class="language-plaintext highlighter-rouge">gScore</code> map and a position and returns its <code class="language-plaintext highlighter-rouge">gScore</code> value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">_find_path</code> function takes the current state of the search and performs the following steps:
    <ul>
      <li>If the openSet is empty, return None.</li>
      <li>Select the node with the lowest <code class="language-plaintext highlighter-rouge">fScore</code> value from the openSet.</li>
      <li>If the selected node is the goal, return the reconstructed path from the starting position to the goal.</li>
      <li>Remove the selected node from the openSet and add it to the closedSet.</li>
      <li>Generate a list of neighboring nodes.</li>
      <li>For each neighboring node:</li>
    </ul>
    <ul>
      <li>If it is in the closedSet, skip it.</li>
      <li>Calculate the tentative <code class="language-plaintext highlighter-rouge">gScore</code> value for the node.</li>
      <li>If the <code class="language-plaintext highlighter-rouge">gScore</code> value is better than the current value, update the <code class="language-plaintext highlighter-rouge">gScore</code>, <code class="language-plaintext highlighter-rouge">fScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps.</li>
      <li>If the node is not in the openSet, add it to the openSet.<br />
        - Recursively call <code class="language-plaintext highlighter-rouge">_find_path</code> with the updated state.</li>
    </ul>
  </li>
  <li>Call <code class="language-plaintext highlighter-rouge">_find_path</code> with the initial state.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of the A* algorithm depends on the heuristic function used and the size of the board. In the worst case, where the heuristic function overestimates the true distance, the algorithm can explore all nodes in the board, resulting in a time complexity of O(b^d), where b is the branching factor (number of neighbors per node) and d is the depth of the goal node. However, in practice, the algorithm often explores fewer nodes than this worst-case bound.</p>

<p>The space complexity of the algorithm is also dependent on the size of the board, as it stores the openSet, closedSet, <code class="language-plaintext highlighter-rouge">fScore</code>, <code class="language-plaintext highlighter-rouge">gScore</code>, and <code class="language-plaintext highlighter-rouge">cameFrom</code> maps. However, the space complexity can be reduced by using a more memory-efficient data structure for the</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The A* algorithm is a pathfinding algorithm used in artificial intelligence and robotics to find the shortest path between two points. It is widely used in video games, GPS systems, and other applications that require finding optimal paths. The algorithm uses a heuristic function to estimate the distance between the current node and the goal node, and combines it with the cost of the path from the start node to the current node to determine the best next step. Implementation The A* algorithm is implemented in OCaml using a priority queue to store the open set of nodes to be explored. The algorithm also uses two sets, closedSet and openSet, to keep track of visited and unvisited nodes, respectively. The function find_path takes the starting and goal positions, as well as a board representing the environment in which the path is to be found. The board is represented as a two-dimensional array of integers, where 0 represents an obstacle and any positive integer represents a clear path. ```ocaml module IntPairs = struct type t = int * int let compare (x0,y0) (x1,y1) = match Stdlib.compare x0 x1 with | 0 -&gt; Stdlib.compare y0 y1 | c -&gt; c end]]></summary></entry><entry><title type="html">Best-First Search</title><link href="/algorithm/2023/11/22/best-first-search.html" rel="alternate" type="text/html" title="Best-First Search" /><published>2023-11-22T08:00:00+02:00</published><updated>2023-11-22T08:00:00+02:00</updated><id>/algorithm/2023/11/22/best-first-search</id><content type="html" xml:base="/algorithm/2023/11/22/best-first-search.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Best-first search is a graph search algorithm that aims to find the optimal path between two nodes in a graph. It is commonly used in artificial intelligence and computer science, particularly in the field of pathfinding. The algorithm works by exploring the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. Best-first search can be used in a variety of applications, such as route planning, game AI, and logistics.</p>

<h2 id="implementation">Implementation</h2>
<p>Here is an implementation of Best-first search in OCaml:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="o">=</span> <span class="p">{</span>  
  <span class="n">state</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span><span class="p">;</span>  
  <span class="n">parent</span><span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">node</span> <span class="n">option</span><span class="p">;</span>  
  <span class="n">cost</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span>  
  <span class="n">heuristic</span><span class="o">:</span> <span class="kt">float</span><span class="p">;</span>  
<span class="p">}</span>  
   
<span class="k">let</span> <span class="n">best_first_search</span> <span class="n">initial_state</span> <span class="n">goal_state</span> <span class="n">successors</span> <span class="n">heuristic</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="n">is_goal</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">goal_state</span> <span class="k">in</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">search</span> <span class="n">frontier</span> <span class="n">visited</span> <span class="o">=</span>  
    <span class="k">match</span> <span class="n">frontier</span> <span class="k">with</span>  
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">None</span>  
    <span class="o">|</span> <span class="n">n</span> <span class="o">::</span> <span class="n">_</span> <span class="k">when</span> <span class="n">is_goal</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">n</span>  
    <span class="o">|</span> <span class="n">n</span> <span class="o">::</span> <span class="n">ns</span> <span class="o">-&gt;</span>  
        <span class="k">let</span> <span class="n">successors</span> <span class="o">=</span> <span class="n">successors</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">add_node</span> <span class="n">frontier</span> <span class="n">node</span> <span class="o">=</span>  
          <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span><span class="p">)</span> <span class="n">visited</span> <span class="k">then</span> <span class="n">frontier</span>  
          <span class="k">else</span> <span class="nn">List</span><span class="p">.</span><span class="n">merge</span> <span class="p">(</span><span class="k">fun</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">-&gt;</span> <span class="n">compare</span> <span class="n">n1</span><span class="o">.</span><span class="n">cost</span> <span class="n">n2</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>  
                 <span class="n">frontier</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">state</span><span class="o">,</span> <span class="n">cost</span><span class="p">)</span> <span class="o">-&gt;</span>  
            <span class="k">let</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="n">heuristic</span> <span class="n">state</span> <span class="k">in</span>  
            <span class="p">{</span><span class="n">state</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">n</span><span class="p">;</span> <span class="n">cost</span><span class="p">;</span> <span class="n">heuristic</span><span class="p">})</span> <span class="n">successors</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">frontier'</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">add_node</span> <span class="n">ns</span> <span class="n">nodes</span> <span class="k">in</span>  
        <span class="k">let</span> <span class="n">visited'</span> <span class="o">=</span> <span class="n">n</span> <span class="o">::</span> <span class="n">visited</span> <span class="k">in</span>  
        <span class="n">search</span> <span class="n">frontier'</span> <span class="n">visited'</span>  
  <span class="k">in</span>  
  <span class="k">let</span> <span class="n">initial_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="nc">None</span><span class="p">;</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.;</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="n">heuristic</span> <span class="n">initial_state</span><span class="p">}</span> <span class="k">in</span>  
  <span class="n">search</span> <span class="p">[</span><span class="n">initial_node</span><span class="p">]</span> <span class="bp">[]</span>  
   
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">type 'a node</code> represents a node in the search tree. Each node has a state, a parent node, a cost (i.e., the cumulative cost from the initial state), and a heuristic value (i.e., the estimated distance to the goal state). The <code class="language-plaintext highlighter-rouge">best_first_search</code> function takes as input the initial state, the goal state, a function that generates the successors of a given state, and a heuristic function that estimates the distance to the goal state. The function returns an optional node that represents the goal state, or <code class="language-plaintext highlighter-rouge">None</code> if no path was found.</p>

<h2 id="example">Example</h2>

<p>Hereâ€™s an example of using Best-first search to find the shortest path between two cities in a graph:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">[</span>  
  <span class="p">(</span><span class="s2">"A"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">7</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="mi">7</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"A"</span><span class="o">,</span> <span class="mi">3</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"D"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"B"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"C"</span><span class="o">,</span> <span class="mi">2</span><span class="o">.</span><span class="p">);</span> <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="p">)]);</span>  
  <span class="p">(</span><span class="s2">"E"</span><span class="o">,</span> <span class="p">[(</span><span class="s2">"D"</span><span class="o">,</span> <span class="mi">4</span><span class="o">.</span><span class="p">)])</span>  
<span class="p">]</span>  
   
<span class="k">let</span> <span class="n">successors</span> <span class="n">state</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_node</span> <span class="n">state</span> <span class="o">=</span> <span class="k">function</span>  
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Node not found"</span>  
    <span class="o">|</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">::</span> <span class="n">_</span> <span class="k">when</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="bp">[]</span>  
    <span class="o">|</span> <span class="n">_</span> <span class="o">::</span> <span class="n">rest</span> <span class="o">-&gt;</span> <span class="n">find_node</span> <span class="n">state</span> <span class="n">rest</span>  
  <span class="k">in</span>  
  <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="o">,</span> <span class="n">edges</span><span class="p">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="n">graph</span> <span class="k">in</span>  
  <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="o">,</span> <span class="n">c</span><span class="p">))</span> <span class="n">edges</span> <span class="o">@</span> <span class="n">find_node</span> <span class="n">state</span> <span class="n">graph</span>  
   
<span class="k">let</span> <span class="n">heuristic</span> <span class="n">state</span> <span class="o">=</span>  
  <span class="k">match</span> <span class="n">state</span> <span class="k">with</span>  
  <span class="o">|</span> <span class="s2">"A"</span> <span class="o">-&gt;</span> <span class="mi">6</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"B"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"C"</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"D"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">.</span>  
  <span class="o">|</span> <span class="s2">"E"</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">.</span>  
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="s2">"Invalid state"</span>  
   
<span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="n">best_first_search</span> <span class="s2">"A"</span> <span class="s2">"E"</span> <span class="n">successors</span> <span class="n">heuristic</span>  
   
<span class="k">let</span> <span class="n">print_path</span> <span class="n">path</span> <span class="o">=</span>  
  <span class="k">let</span> <span class="k">rec</span> <span class="n">print_node</span> <span class="n">node</span> <span class="o">=</span>  
    <span class="k">match</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="k">with</span>  
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span>  
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">parent</span> <span class="o">-&gt;</span>  
        <span class="n">print_node</span> <span class="n">parent</span><span class="p">;</span>  
        <span class="n">print_endline</span> <span class="n">node</span><span class="o">.</span><span class="n">state</span>  
  <span class="k">in</span>  
  <span class="k">match</span> <span class="n">path</span> <span class="k">with</span>  
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">print_endline</span> <span class="s2">"No path found"</span>  
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">print_node</span> <span class="n">node</span>  
   
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">print_path</span> <span class="n">path</span>  
</code></pre></div></div>

<p>This code defines a graph as a list of nodes, where each node is a tuple of a state and a list of edges to other nodes, each with a cost. The <code class="language-plaintext highlighter-rouge">successors</code> function generates the successors of a given state by looking up the corresponding node in the graph and returning its edges. The <code class="language-plaintext highlighter-rouge">heuristic</code> function estimates the distance to the goal state based on a predefined heuristic value for each state.</p>

<p>The <code class="language-plaintext highlighter-rouge">path</code> variable contains the result of running Best-first search on the graph, starting from state â€œAâ€ and ending at state â€œEâ€. Finally, the <code class="language-plaintext highlighter-rouge">print_path</code> function prints out the path from the initial state to the goal state.</p>

<p>When we run this code, we should see the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A  
C  
D  
E  
</code></pre></div></div>

<p>This indicates that the shortest path from â€œAâ€ to â€œEâ€ is â€œAâ€ -&gt; â€œCâ€ -&gt; â€œDâ€ -&gt; â€œEâ€, with a total cost of 9.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Create a node that represents the initial state, with a cost of 0 and a heuristic value based on the initial state.</li>
  <li>Create an empty list of visited nodes and a list that contains only the initial node as the frontier.</li>
  <li>If the frontier is empty, return <code class="language-plaintext highlighter-rouge">None</code> (i.e., no path was found).</li>
  <li>Otherwise, take the node at the front of the frontier and check if it is the goal node. If so, return it.</li>
  <li>Otherwise, generate the successors of the current node, create nodes for each of them, and add them to the frontier.</li>
  <li>Sort the frontier based on the cost of each node (i.e., the cumulative cost from the initial state).</li>
  <li>Add the current node to the list of visited nodes.</li>
  <li>Repeat from step 3.</li>
</ol>

<p>The key idea behind Best-first search is to explore the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. This allows the algorithm to quickly converge to the optimal path, while avoiding exploring unpromising paths.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Best-first search depends on the quality of the heuristic function. In the worst case, where the heuristic function is not informative (i.e., it always returns 0), the algorithm degenerates to a breadth-first search, with a time complexity of O(b^d), where b is the branching factor of the graph and d is the depth of the goal node. In the</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Best-first search is a graph search algorithm that aims to find the optimal path between two nodes in a graph. It is commonly used in artificial intelligence and computer science, particularly in the field of pathfinding. The algorithm works by exploring the most promising nodes first, based on a heuristic function that estimates the distance to the goal node. Best-first search can be used in a variety of applications, such as route planning, game AI, and logistics. Implementation Here is an implementation of Best-first search in OCaml: type 'a node = { state: 'a; parent: 'a node option; cost: float; heuristic: float; } let best_first_search initial_state goal_state successors heuristic = let is_goal n = n.state = goal_state in let rec search frontier visited = match frontier with | [] -&gt; None | n :: _ when is_goal n -&gt; Some n | n :: ns -&gt; let successors = successors n.state in let add_node frontier node = if List.exists (fun n -&gt; n.state = node.state) visited then frontier else List.merge (fun n1 n2 -&gt; compare n1.cost n2.cost) frontier [node] in let nodes = List.map (fun (state, cost) -&gt; let heuristic = heuristic state in {state; parent = Some n; cost; heuristic}) successors in let frontier' = List.fold_left add_node ns nodes in let visited' = n :: visited in search frontier' visited' in let initial_node = {state = initial_state; parent = None; cost = 0.; heuristic = heuristic initial_state} in search [initial_node] [] Here, type 'a node represents a node in the search tree. Each node has a state, a parent node, a cost (i.e., the cumulative cost from the initial state), and a heuristic value (i.e., the estimated distance to the goal state). The best_first_search function takes as input the initial state, the goal state, a function that generates the successors of a given state, and a heuristic function that estimates the distance to the goal state. The function returns an optional node that represents the goal state, or None if no path was found.]]></summary></entry><entry><title type="html">Matrix Inverse</title><link href="/algorithm/2023/11/22/matrix-inverse.html" rel="alternate" type="text/html" title="Matrix Inverse" /><published>2023-11-22T06:00:00+02:00</published><updated>2023-11-22T06:00:00+02:00</updated><id>/algorithm/2023/11/22/matrix-inverse</id><content type="html" xml:base="/algorithm/2023/11/22/matrix-inverse.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The inverse of a matrix is a matrix that, when multiplied by the original matrix, results in the identity matrix. The inverse of a matrix is useful in solving systems of linear equations, computing determinants, and in other areas of mathematics. The algorithm we will be discussing is used to find the inverse of a square matrix.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">inv</span> <span class="n">varr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">_k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">varr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_add</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_add_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_neg</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_neg_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_one</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">one</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dims</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">varr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_check_is_matrix</span> <span class="n">dims</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">unsafe_get</span> <span class="n">dims</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">if</span> <span class="nn">Array</span><span class="p">.</span><span class="n">unsafe_get</span> <span class="n">dims</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">n</span>
  <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"no inverse - the matrix is not square"</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">pivot_row</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="n">_zero</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">result_varr</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">varr</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">pivot_elem</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="o">=</span> <span class="n">_zero</span>
      <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"the matrix does not have an inverse"</span><span class="p">;</span>
      <span class="c">(* update elements of the pivot row, save old vals *)</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">];</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">p</span> <span class="k">then</span> <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="n">pivot_elem</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update elements of the pivot col *)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span>
        <span class="k">then</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span>
            <span class="n">result_varr</span>
            <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span>
            <span class="p">(</span><span class="n">_div</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="n">_neg</span> <span class="n">pivot_elem</span><span class="p">))</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update the rest of the matrix *)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">pivot_col_elem</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">p</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="k">let</span> <span class="n">pivot_row_elem</span> <span class="o">=</span> <span class="n">pivot_row</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">in</span>
            <span class="c">(* use old value *)</span>
            <span class="k">let</span> <span class="n">old_val</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
            <span class="k">let</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">_add</span> <span class="n">old_val</span> <span class="p">(</span><span class="n">_mul</span> <span class="n">pivot_row_elem</span> <span class="n">pivot_col_elem</span><span class="p">)</span> <span class="k">in</span>
            <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="n">new_val</span><span class="p">)</span>
        <span class="k">done</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="c">(* update the pivot element *)</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">result_varr</span> <span class="p">[</span><span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="n">_one</span> <span class="n">pivot_elem</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">result_varr</span><span class="p">)</span>
</code></pre></div></div>

<p>The algorithm is implemented in the OCaml programming language. It takes as input a matrix represented as an Owl ndarray and returns the inverse of the matrix as an ndarray. Here is an example of how to use the <code class="language-plaintext highlighter-rouge">inv</code> function:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Owl</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">of_array</span> <span class="p">[</span><span class="o">|</span> <span class="p">[</span><span class="o">|</span> <span class="mi">1</span><span class="o">.;</span> <span class="mi">2</span><span class="o">.;</span> <span class="mi">3</span><span class="o">.</span> <span class="o">|</span><span class="p">];</span> <span class="p">[</span><span class="o">|</span> <span class="mi">4</span><span class="o">.;</span> <span class="mi">5</span><span class="o">.;</span> <span class="mi">6</span><span class="o">.</span> <span class="o">|</span><span class="p">];</span> <span class="p">[</span><span class="o">|</span> <span class="mi">7</span><span class="o">.;</span> <span class="mi">8</span><span class="o">.;</span> <span class="mi">10</span><span class="o">.</span> <span class="o">|</span><span class="p">]</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>  
<span class="k">let</span> <span class="n">m_inv</span> <span class="o">=</span> <span class="n">inv</span> <span class="n">m</span> <span class="k">in</span>  
<span class="nn">Owl</span><span class="p">.</span><span class="nn">Mat</span><span class="p">.</span><span class="n">print</span> <span class="n">m_inv</span>  
</code></pre></div></div>
<p>This will print the inverse of the matrix <code class="language-plaintext highlighter-rouge">m</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The algorithm works by performing a series of operations on the input matrix until it is transformed into the identity matrix. These operations are performed on both the input matrix and an identity matrix, which is used to keep track of the transformations. Here are the steps of the algorithm:</p>

<ol>
  <li>Check that the input matrix is square. If it is not, the function will return an error.</li>
  <li>Create a pivot row array that will be used to store the values of the row that is being transformed.</li>
  <li>Create a copy of the input matrix that will be transformed into the identity matrix.</li>
  <li>Iterate over the diagonal elements of the matrix (i.e., the pivot elements).</li>
  <li>If the pivot element is zero, the matrix does not have an inverse, so the function will return an error.</li>
  <li>Update the pivot row by dividing each element by the pivot element. Save the old values of the row in the pivot row array.</li>
  <li>Update the pivot column by dividing each element (except for the pivot element) by the negative of the pivot element.</li>
  <li>Update the rest of the matrix by subtracting the product of the pivot row and pivot column from each element (except for the pivot element).</li>
  <li>Update the pivot element by taking the reciprocal of the original pivot element.</li>
  <li>Return the transformed matrix, which is the inverse of the input matrix.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the algorithm is O(n^3), where n is the size of the input matrix. This is because the algorithm performs O(n) operations for each of the n diagonal elements, resulting in a total of O(n^3) operations. The space complexity of the algorithm is also O(n^3), since it creates a copy of the input matrix and a pivot row array of size n. Therefore, the algorithm is not suitable for very large matrices, as it may take a long time and use a lot of memory to compute the inverse.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The inverse of a matrix is a matrix that, when multiplied by the original matrix, results in the identity matrix. The inverse of a matrix is useful in solving systems of linear equations, computing determinants, and in other areas of mathematics. The algorithm we will be discussing is used to find the inverse of a square matrix. Implementation]]></summary></entry><entry><title type="html">Tridiagonal Matrix Algorithm</title><link href="/algorithm/2023/11/22/tridiagonal-algorithm.html" rel="alternate" type="text/html" title="Tridiagonal Matrix Algorithm" /><published>2023-11-22T05:00:00+02:00</published><updated>2023-11-22T05:00:00+02:00</updated><id>/algorithm/2023/11/22/tridiagonal-algorithm</id><content type="html" xml:base="/algorithm/2023/11/22/tridiagonal-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The tridiagonal matrix algorithm is a numerical method used to solve a system of linear equations where the matrix is tridiagonal. A tridiagonal matrix is a matrix where all the elements are zero except for those on the main diagonal, the diagonal above it, and the diagonal below it. The algorithm is used in various fields such as physics, engineering, and finance.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Solver for tridiagonal matrix
 * Input: a[n], b[n], c[n], which together consist the tridiagonal matrix A, and the right side vector r[n]. Return: x[n].
 *)</span>

<span class="k">let</span> <span class="n">tridiag_solve_vec</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">r</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n1</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">c</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n2</span><span class="p">);</span>
  <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"tridiag_solve_vec: 0 at the beginning of diagonal vector"</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">bet</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">gam</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">c</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span><span class="p">;</span>
    <span class="n">bet</span> <span class="o">:=</span> <span class="n">b</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*.</span> <span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">bet</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="k">raise</span> <span class="p">(</span><span class="nc">Invalid_argument</span> <span class="s2">"tridiag_solve_vec: algorithm fails"</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*.</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">/.</span> <span class="o">!</span><span class="n">bet</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="n">gam</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*.</span> <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span>
</code></pre></div></div>

<p>The implementation of the tridiagonal matrix algorithm is provided in OCaml. The function <code class="language-plaintext highlighter-rouge">tridiag_solve_vec</code> takes four input arrays <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">c</code>, and <code class="language-plaintext highlighter-rouge">r</code>, where <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code> are the arrays representing the tridiagonal matrix and <code class="language-plaintext highlighter-rouge">r</code> is the right-hand side vector. The function returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The tridiagonal matrix algorithm works by eliminating the coefficients below and above the main diagonal. The algorithm can be divided into three steps:</p>

<ol>
  <li>
    <p>Decomposition: In this step, the algorithm decomposes the matrix into two matrices, L and U, where L is a lower triangular matrix and U is an upper triangular matrix. The decomposition is done in such a way that the product of L and U is equal to the original matrix.</p>
  </li>
  <li>
    <p>Forward substitution: In this step, the algorithm solves the equation Ly = r, where L is the lower triangular matrix obtained in the previous step, y is an intermediate vector, and r is the right-hand side vector. This step is called forward substitution because it starts from the first equation and solves for y in terms of the previous y values.</p>
  </li>
  <li>
    <p>Backward substitution: In this step, the algorithm solves the equation Ux = y, where U is the upper triangular matrix obtained in the first step, x is the solution vector, and y is the intermediate vector obtained in the previous step. This step is called backward substitution because it starts from the last equation and solves for x in terms of the previous x values.</p>
  </li>
</ol>

<p>The implementation of the tridiagonal matrix algorithm provided in OCaml is based on the Thomas algorithm, which is a simplified version of the tridiagonal matrix algorithm. The algorithm starts by checking that the diagonal element of the matrix is not zero. If it is zero, the algorithm raises an exception.</p>

<p>The algorithm then proceeds to calculate the intermediate values <code class="language-plaintext highlighter-rouge">gam</code> and <code class="language-plaintext highlighter-rouge">bet</code>, which are used in the forward substitution step. The intermediate value <code class="language-plaintext highlighter-rouge">bet</code> is updated at each iteration, and if it becomes zero, the algorithm raises an exception. The solution vector <code class="language-plaintext highlighter-rouge">x</code> is also updated at each iteration.</p>

<p>Finally, the algorithm performs the backward substitution step to obtain the final solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the tridiagonal matrix algorithm is O(n), where n is the size of the matrix. The algorithm performs two loops, one for the forward substitution step and one for the backward substitution step, each of which takes O(n) time. The intermediate calculations take constant time, so the overall time complexity is O(n).</p>

<p>The space complexity of the algorithm is also O(n), as it requires arrays of size n to store the intermediate values and the solution vector.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The tridiagonal matrix algorithm is a numerical method used to solve a system of linear equations where the matrix is tridiagonal. A tridiagonal matrix is a matrix where all the elements are zero except for those on the main diagonal, the diagonal above it, and the diagonal below it. The algorithm is used in various fields such as physics, engineering, and finance. Implementation]]></summary></entry><entry><title type="html">LU Decomposition</title><link href="/algorithm/2023/11/22/lu-decomposition.html" rel="alternate" type="text/html" title="LU Decomposition" /><published>2023-11-22T04:00:00+02:00</published><updated>2023-11-22T04:00:00+02:00</updated><id>/algorithm/2023/11/22/lu-decomposition</id><content type="html" xml:base="/algorithm/2023/11/22/lu-decomposition.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>LU decomposition is a numerical method for solving systems of linear equations. It decomposes a square matrix into two triangular matrices, one lower triangular matrix (L) and one upper triangular matrix (U). This decomposition can be used to solve linear equations in the form Ax = b, where A is the matrix, x is the vector of unknowns, and b is the vector of constants.</p>

<h2 id="implementation">Implementation</h2>
<p>The following implementation of LU decomposition is written in OCaml. It takes a matrix <code class="language-plaintext highlighter-rouge">a</code> as input and returns the L and U matrices, as well as a row permutation vector. The <code class="language-plaintext highlighter-rouge">_lu_base</code> function performs the decomposition and returns the L and U matrices and the permutation vector. The <code class="language-plaintext highlighter-rouge">lu</code> function calls <code class="language-plaintext highlighter-rouge">_lu_base</code> and then formats the output into the L and U matrices. The <code class="language-plaintext highlighter-rouge">_lu_solve_vec</code> function uses the output of <code class="language-plaintext highlighter-rouge">_lu_base</code> to solve a system of linear equations.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* LU decomposition.
 * Input matrix: a[n][n]; return L/U in one matrix, and the row permutation vector.
 * Test: https://github.com/scipy/scipy/blob/master/scipy/linalg/tests/test_decomp.py
 *)</span>
<span class="k">let</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_abs</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_abs_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_sub</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_sub_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_flt</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_float_typ_elt</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_one</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">one</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">indx</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* implicit scaling of each row *)</span>
  <span class="k">let</span> <span class="n">vv</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">tiny</span> <span class="o">=</span> <span class="n">_flt</span> <span class="mf">1.0e-40</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">big</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="c">(* flag of row exchange *)</span>
  <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">imax</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* loop over rows to get the implicit scaling information *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">big</span> <span class="o">:=</span> <span class="n">_zero</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">_abs</span><span class="p">;</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">big</span> <span class="k">then</span> <span class="n">big</span> <span class="o">:=</span> <span class="o">!</span><span class="n">temp</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">big</span> <span class="o">=</span> <span class="n">_zero</span> <span class="k">then</span> <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">SINGULAR</span><span class="p">;</span>
    <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">_div</span> <span class="n">_one</span> <span class="o">!</span><span class="n">big</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">big</span> <span class="o">:=</span> <span class="n">_zero</span><span class="p">;</span>
    <span class="c">(* choose suitable pivot *)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">_abs</span><span class="p">)</span> <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span> <span class="o">!</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">big</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">big</span> <span class="o">:=</span> <span class="o">!</span><span class="n">temp</span><span class="p">;</span>
        <span class="n">imax</span> <span class="o">:=</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="c">(* interchange rows *)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">imax</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">temp</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">temp</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span> <span class="o">*.</span> <span class="o">-</span><span class="mi">1</span><span class="o">.;</span>
      <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">imax</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">vv</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>
    <span class="n">indx</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">imax</span><span class="p">;</span>
    <span class="k">if</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">=</span> <span class="n">_zero</span> <span class="k">then</span> <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="n">tiny</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">tmp0</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="n">temp</span> <span class="o">:=</span> <span class="n">_div</span> <span class="n">tmp0</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">temp</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_sub</span> <span class="n">prev</span> <span class="p">(</span><span class="n">_mul</span> <span class="o">!</span><span class="n">temp</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])))</span>
      <span class="k">done</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="o">!</span><span class="n">d</span>


<span class="c">(* LU decomposition, return L, U, and permutation vector *)</span>
<span class="k">let</span> <span class="n">lu</span> <span class="n">a</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">lu</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">lu</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">eye</span> <span class="n">k</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">for</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">l</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span><span class="p">;</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">r</span><span class="p">;</span> <span class="n">c</span> <span class="o">|</span><span class="p">]</span> <span class="n">_zero</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">l</span><span class="o">,</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span>


<span class="k">let</span> <span class="n">_lu_solve_vec</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">_k</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">kind</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_mul</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_mul_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_div</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_div_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_sub</span> <span class="o">=</span> <span class="nn">Owl_base_dense_common</span><span class="p">.</span><span class="n">_sub_elt</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_zero</span> <span class="o">=</span> <span class="nn">Owl_const</span><span class="p">.</span><span class="n">zero</span> <span class="n">_k</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="p">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">if</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">n</span> <span class="k">then</span> <span class="n">failwith</span> <span class="s2">"LUdcmp::solve bad sizes"</span><span class="p">;</span>
  <span class="k">let</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">_zero</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lu</span><span class="o">,</span> <span class="n">indx</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_lu_base</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">indx</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">in</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">ip</span> <span class="o">|</span><span class="p">];</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">ip</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]);</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">ii</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
    <span class="k">then</span>
      <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="o">!</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="n">sum</span> <span class="o">:=</span> <span class="n">_sub</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span> <span class="o">|</span><span class="p">]))</span>
      <span class="k">done</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">!</span><span class="n">sum</span> <span class="o">&lt;&gt;</span> <span class="n">_zero</span>
    <span class="k">then</span> <span class="n">ii</span> <span class="o">:=</span> <span class="o">!</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]</span> <span class="o">!</span><span class="n">sum</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">sum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="n">sum</span> <span class="o">:=</span> <span class="n">_sub</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="n">_mul</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">|</span><span class="p">])</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span> <span class="o">|</span><span class="p">]))</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">x</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">_div</span> <span class="o">!</span><span class="n">sum</span> <span class="p">(</span><span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">lu</span> <span class="p">[</span><span class="o">|</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">|</span><span class="p">]))</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_lu_base</code> function takes a square matrix <code class="language-plaintext highlighter-rouge">a</code> as input and returns the L and U matrices, as well as a row permutation vector.</p>
  </li>
  <li>
    <p>The function first makes a copy of the input matrix <code class="language-plaintext highlighter-rouge">a</code> into a new matrix <code class="language-plaintext highlighter-rouge">lu</code>.</p>
  </li>
  <li>
    <p>It initializes some variables, including the row permutation vector <code class="language-plaintext highlighter-rouge">indx</code>, the scaling vector <code class="language-plaintext highlighter-rouge">vv</code>, a small value <code class="language-plaintext highlighter-rouge">tiny</code>, and a flag <code class="language-plaintext highlighter-rouge">d</code>.</p>
  </li>
  <li>
    <p>The function then calculates the implicit scaling of each row by finding the maximum absolute value in each row and storing the reciprocal of that value in the <code class="language-plaintext highlighter-rouge">vv</code> vector.</p>
  </li>
  <li>
    <p>It then performs the LU decomposition using Gaussian elimination with partial pivoting. The function loops over each column <code class="language-plaintext highlighter-rouge">k</code> and selects the pivot element as the one with the largest scaled value in the column. If necessary, it exchanges rows to bring the pivot element to the diagonal. It stores the row index of each pivot element in the <code class="language-plaintext highlighter-rouge">indx</code> vector.</p>
  </li>
  <li>
    <p>During the elimination process, the function stores the multipliers used to eliminate the elements below the pivot element in the <code class="language-plaintext highlighter-rouge">lu</code> matrix.</p>
  </li>
  <li>
    <p>The function also keeps track of the sign of the row exchanges in the <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>After the elimination process is complete, the function returns the <code class="language-plaintext highlighter-rouge">lu</code> matrix, the <code class="language-plaintext highlighter-rouge">indx</code> vector, and the <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">lu</code> function calls <code class="language-plaintext highlighter-rouge">_lu_base</code> and then formats the output into the L and U matrices. It first calls <code class="language-plaintext highlighter-rouge">_lu_base</code> to get the <code class="language-plaintext highlighter-rouge">lu</code> matrix, <code class="language-plaintext highlighter-rouge">indx</code> vector, and <code class="language-plaintext highlighter-rouge">d</code> flag. It then creates an identity matrix <code class="language-plaintext highlighter-rouge">l</code> with the same size as <code class="language-plaintext highlighter-rouge">lu</code>.</p>
  </li>
  <li>
    <p>The function sets the elements of <code class="language-plaintext highlighter-rouge">l</code> to the corresponding elements of <code class="language-plaintext highlighter-rouge">lu</code> below the diagonal.</p>
  </li>
  <li>
    <p>The function returns the <code class="language-plaintext highlighter-rouge">l</code> and <code class="language-plaintext highlighter-rouge">lu</code> matrices, as well as the <code class="language-plaintext highlighter-rouge">indx</code> vector.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">_lu_solve_vec</code> function uses the output of <code class="language-plaintext highlighter-rouge">_lu_base</code> to solve a system of linear equations. It takes a matrix <code class="language-plaintext highlighter-rouge">a</code> and a vector <code class="language-plaintext highlighter-rouge">b</code> as input and returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The function first checks that the dimensions of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are compatible.</p>
  </li>
  <li>
    <p>It then calls <code class="language-plaintext highlighter-rouge">_lu_base</code> to get the <code class="language-plaintext highlighter-rouge">lu</code> matrix, <code class="language-plaintext highlighter-rouge">indx</code> vector, and <code class="language-plaintext highlighter-rouge">d</code> flag.</p>
  </li>
  <li>
    <p>The function initializes some variables and loops over each row of the <code class="language-plaintext highlighter-rouge">lu</code> matrix to solve for the intermediate solution vector <code class="language-plaintext highlighter-rouge">y</code>.</p>
  </li>
  <li>
    <p>The function then loops over each row of the <code class="language-plaintext highlighter-rouge">lu</code> matrix again to solve for the final solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
  <li>
    <p>The function returns the solution vector <code class="language-plaintext highlighter-rouge">x</code>.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of LU decomposition is O(n^3), where n is the size of the input matrix. This is because the algorithm involves performing Gaussian elimination on the matrix, which requires O(n^3) operations. The space complexity of the algorithm is also O(n^2), since it requires storing the L and U matrices, as well as the row permutation vector. However, the algorithm is numerically stable and is widely used in practice for solving systems of linear equations.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction LU decomposition is a numerical method for solving systems of linear equations. It decomposes a square matrix into two triangular matrices, one lower triangular matrix (L) and one upper triangular matrix (U). This decomposition can be used to solve linear equations in the form Ax = b, where A is the matrix, x is the vector of unknowns, and b is the vector of constants. Implementation The following implementation of LU decomposition is written in OCaml. It takes a matrix a as input and returns the L and U matrices, as well as a row permutation vector. The _lu_base function performs the decomposition and returns the L and U matrices and the permutation vector. The lu function calls _lu_base and then formats the output into the L and U matrices. The _lu_solve_vec function uses the output of _lu_base to solve a system of linear equations. ```ocaml (* LU decomposition. Input matrix: a[n][n]; return L/U in one matrix, and the row permutation vector. Test: https://github.com/scipy/scipy/blob/master/scipy/linalg/tests/test_decomp.py ) let _lu_base a = let k = M.kind a in let _abs = Owl_base_dense_common._abs_elt k in let _mul = Owl_base_dense_common._mul_elt k in let _div = Owl_base_dense_common._div_elt k in let _sub = Owl_base_dense_common._sub_elt k in let _flt = Owl_base_dense_common._float_typ_elt k in let _zero = Owl_const.zero k in let _one = Owl_const.one k in let lu = M.copy a in let n = (M.shape a).(0) in let m = (M.shape a).(1) in assert (n = m); let indx = Array.make n 0 in ( implicit scaling of each row ) let vv = Array.make n _zero in let tiny = _flt 1.0e-40 in let big = ref _zero in let temp = ref _zero in ( flag of row exchange ) let d = ref 1.0 in let imax = ref 0 in ( loop over rows to get the implicit scaling information ) for i = 0 to n - 1 do big := _zero; for j = 0 to n - 1 do temp := M.get lu [| i; j |] |&gt; _abs; if !temp &gt; !big then big := !temp done; if !big = _zero then raise Owl_exception.SINGULAR; vv.(i) &lt;- _div _one !big done; for k = 0 to n - 1 do big := _zero; ( choose suitable pivot ) for i = k to n - 1 do temp := _mul (M.get lu [| i; k |] |&gt; _abs) vv.(i); if !temp &gt; !big then ( big := !temp; imax := i) done; ( interchange rows *) if k &lt;&gt; !imax then ( for j = 0 to n - 1 do temp := M.get lu [| !imax; j |]; let tmp = M.get lu [| k; j |] in M.set lu [| !imax; j |] tmp; M.set lu [| k; j |] !temp done; d := !d *. -1.; vv.(!imax) &lt;- vv.(k)); indx.(k) &lt;- !imax; if M.get lu [| k; k |] = _zero then M.set lu [| k; k |] tiny; for i = k + 1 to n - 1 do let tmp0 = M.get lu [| i; k |] in let tmp1 = M.get lu [| k; k |] in temp := _div tmp0 tmp1; M.set lu [| i; k |] !temp; for j = k + 1 to n - 1 do let prev = M.get lu [| i; j |] in M.set lu [| i; j |] (_sub prev (_mul !temp (M.get lu [| k; j |]))) done done done; lu, indx, !d]]></summary></entry><entry><title type="html">Gaussian Elimination</title><link href="/algorithm/2023/11/22/gaussian-elimination.html" rel="alternate" type="text/html" title="Gaussian Elimination" /><published>2023-11-22T03:00:00+02:00</published><updated>2023-11-22T03:00:00+02:00</updated><id>/algorithm/2023/11/22/gaussian-elimination</id><content type="html" xml:base="/algorithm/2023/11/22/gaussian-elimination.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics.</p>

<h2 id="implementation">Implementation</h2>
<p>The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix <code class="language-plaintext highlighter-rouge">a</code> representing the coefficients of the linear equations, and a matrix <code class="language-plaintext highlighter-rouge">b</code> representing the constants of the linear equations. The function returns two matrices: the transformed matrix <code class="language-plaintext highlighter-rouge">a</code> and the solution matrix <code class="language-plaintext highlighter-rouge">b</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">linsolve_gauss</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">dims_a</span><span class="o">,</span> <span class="n">dims_b</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">a</span><span class="o">,</span> <span class="nn">M</span><span class="p">.</span><span class="n">shape</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">_</span><span class="o">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_check_is_matrix</span> <span class="n">dims_a</span><span class="o">,</span> <span class="n">_check_is_matrix</span> <span class="n">dims_b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">copy</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dims_a</span><span class="o">.</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">dims_b</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">icol</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">irow</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dum</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pivinv</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">indxc</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">indxr</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ipiv</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="c">(* Main loop over the columns to be reduced. *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">big</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
    <span class="c">(* Outer loop of the search for at pivot element *)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="mi">1</span>
      <span class="k">then</span>
        <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">if</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span> <span class="o">|</span><span class="p">]</span> <span class="o">|&gt;</span> <span class="n">abs_float</span> <span class="k">in</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="o">!</span><span class="n">big</span>
            <span class="k">then</span> <span class="p">(</span>
              <span class="n">big</span> <span class="o">:=</span> <span class="n">v</span><span class="p">;</span>
              <span class="n">irow</span> <span class="o">:=</span> <span class="n">j</span><span class="p">;</span>
              <span class="n">icol</span> <span class="o">:=</span> <span class="n">k</span><span class="p">))</span>
        <span class="k">done</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">icol</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">ipiv</span><span class="o">.</span><span class="p">(</span><span class="o">!</span><span class="n">icol</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">irow</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">icol</span>
    <span class="k">then</span> <span class="p">(</span>
      <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span><span class="p">);</span>
    <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">irow</span><span class="p">;</span>
    <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">then</span> <span class="k">raise</span> <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">SINGULAR</span><span class="p">;</span>
    <span class="n">pivinv</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">/.</span> <span class="n">p</span><span class="p">;</span>
    <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pivinv</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
      <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pivinv</span><span class="p">)</span>
    <span class="k">done</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">ll</span> <span class="o">&lt;&gt;</span> <span class="o">!</span><span class="n">icol</span>
      <span class="k">then</span> <span class="p">(</span>
        <span class="n">dum</span> <span class="o">:=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">];</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="o">!</span><span class="n">icol</span> <span class="o">|</span><span class="p">]</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">-.</span> <span class="p">(</span><span class="n">p</span> <span class="o">*.</span> <span class="o">!</span><span class="n">dum</span><span class="p">))</span>
        <span class="k">done</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
          <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="o">!</span><span class="n">icol</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">prev</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
          <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">b</span> <span class="p">[</span><span class="o">|</span> <span class="n">ll</span><span class="p">;</span> <span class="n">l</span> <span class="o">|</span><span class="p">]</span> <span class="p">(</span><span class="n">prev</span> <span class="o">-.</span> <span class="p">(</span><span class="n">p</span> <span class="o">*.</span> <span class="o">!</span><span class="n">dum</span><span class="p">))</span>
        <span class="k">done</span><span class="p">)</span>
    <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">then</span>
      <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">u</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">M</span><span class="p">.</span><span class="n">get</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="k">in</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxc</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="n">u</span><span class="p">;</span>
        <span class="nn">M</span><span class="p">.</span><span class="n">set</span> <span class="n">a</span> <span class="p">[</span><span class="o">|</span> <span class="n">k</span><span class="p">;</span> <span class="n">indxr</span><span class="o">.</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">|</span><span class="p">]</span> <span class="n">v</span>
      <span class="k">done</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">a</span><span class="o">,</span> <span class="n">b</span>
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0.</p>

<p>The implementation of the algorithm in OCaml begins by checking that the input matrices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are valid matrices. The function then creates copies of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm.</p>

<p>The main loop of the algorithm iterates over the columns of the matrix <code class="language-plaintext highlighter-rouge">a</code> to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular.</p>

<p>After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix <code class="language-plaintext highlighter-rouge">a</code> is in row echelon form.</p>

<p>The algorithm then performs back substitution to transform the row echelon form of <code class="language-plaintext highlighter-rouge">a</code> into the reduced row echelon form. The algorithm iterates over the rows of <code class="language-plaintext highlighter-rouge">a</code> in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix <code class="language-plaintext highlighter-rouge">a</code> is in reduced row echelon form.</p>

<p>Finally, the algorithm returns the transformed matrix <code class="language-plaintext highlighter-rouge">a</code> and the solution matrix <code class="language-plaintext highlighter-rouge">b</code>.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3.</p>

<p>The space complexity of the algorithm is O(n^2), which is the size of the matrices <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. The algorithm creates copies of <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, so the space complexity is doubled.</p>

<p>In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Gaussian elimination is a widely used method for solving systems of linear equations. The method is named after the German mathematician Carl Friedrich Gauss. The algorithm works by transforming the augmented matrix of the system into a row echelon form, and then into a reduced row echelon form, from which the solution can be read off directly. Gaussian elimination is used in many fields, including engineering, physics, economics, and computer graphics. Implementation The OCaml implementation of the Gaussian elimination algorithm takes two matrices as input: a matrix a representing the coefficients of the linear equations, and a matrix b representing the constants of the linear equations. The function returns two matrices: the transformed matrix a and the solution matrix b. let linsolve_gauss a b = let dims_a, dims_b = M.shape a, M.shape b in let _, _ = _check_is_matrix dims_a, _check_is_matrix dims_b in let a = M.copy a in let b = M.copy b in let n = dims_a.(0) in let m = dims_b.(1) in let icol = ref 0 in let irow = ref 0 in let dum = ref 0.0 in let pivinv = ref 0.0 in let indxc = Array.make n 0 in let indxr = Array.make n 0 in let ipiv = Array.make n 0 in (* Main loop over the columns to be reduced. *) for i = 0 to n - 1 do let big = ref 0.0 in (* Outer loop of the search for at pivot element *) for j = 0 to n - 1 do if ipiv.(j) &lt;&gt; 1 then for k = 0 to n - 1 do if ipiv.(k) == 0 then ( let v = M.get a [| j; k |] |&gt; abs_float in if v &gt;= !big then ( big := v; irow := j; icol := k)) done done; ipiv.(!icol) &lt;- ipiv.(!icol) + 1; if !irow &lt;&gt; !icol then ( for l = 0 to n - 1 do let u = M.get a [| !irow; l |] in let v = M.get a [| !icol; l |] in M.set a [| !icol; l |] u; M.set a [| !irow; l |] v done; for l = 0 to m - 1 do let u = M.get b [| !irow; l |] in let v = M.get b [| !icol; l |] in M.set b [| !icol; l |] u; M.set b [| !irow; l |] v done); indxr.(i) &lt;- !irow; indxc.(i) &lt;- !icol; let p = M.get a [| !icol; !icol |] in if p = 0.0 then raise Owl_exception.SINGULAR; pivinv := 1.0 /. p; M.set a [| !icol; !icol |] 1.0; for l = 0 to n - 1 do let prev = M.get a [| !icol; l |] in M.set a [| !icol; l |] (prev *. !pivinv) done; for l = 0 to m - 1 do let prev = M.get b [| !icol; l |] in M.set b [| !icol; l |] (prev *. !pivinv) done; for ll = 0 to n - 1 do if ll &lt;&gt; !icol then ( dum := M.get a [| ll; !icol |]; M.set a [| ll; !icol |] 0.0; for l = 0 to n - 1 do let p = M.get a [| !icol; l |] in let prev = M.get a [| ll; l |] in M.set a [| ll; l |] (prev -. (p *. !dum)) done; for l = 0 to m - 1 do let p = M.get b [| !icol; l |] in let prev = M.get b [| ll; l |] in M.set b [| ll; l |] (prev -. (p *. !dum)) done) done done; for l = n - 1 downto 0 do if indxr.(l) &lt;&gt; indxc.(l) then for k = 0 to n - 1 do let u = M.get a [| k; indxr.(l) |] in let v = M.get a [| k; indxc.(l) |] in M.set a [| k; indxc.(l) |] u; M.set a [| k; indxr.(l) |] v done done; a, b Step-by-step Explanation The Gaussian elimination algorithm works by transforming the augmented matrix of the system of linear equations into a row echelon form, and then into a reduced row echelon form. The row echelon form is a matrix where the leading coefficient of each row is to the right of the leading coefficient of the row above it. The reduced row echelon form is a matrix where the leading coefficient of each row is 1, and all other entries in the column are 0. The implementation of the algorithm in OCaml begins by checking that the input matrices a and b are valid matrices. The function then creates copies of a and b to avoid modifying the input matrices. The function also initializes several variables and arrays that are used in the algorithm. The main loop of the algorithm iterates over the columns of the matrix a to be reduced. In each iteration, the algorithm searches for a pivot element in the column, which is the largest absolute value element in the column that has not already been used as a pivot. The algorithm then swaps the rows and columns of the pivot element to move it to the diagonal position. If the pivot element is 0, the algorithm raises an exception to indicate that the matrix is singular. After the pivot element is moved to the diagonal position, the algorithm scales the pivot row so that the pivot element is 1. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries below the pivot element in the same column. This process continues until the matrix a is in row echelon form. The algorithm then performs back substitution to transform the row echelon form of a into the reduced row echelon form. The algorithm iterates over the rows of a in reverse order, starting with the bottom row. For each row, the algorithm swaps the columns to put the pivot element in the correct position. The algorithm then subtracts multiples of the pivot row from the other rows to eliminate the entries above the pivot element in the same column. This process continues until the matrix a is in reduced row echelon form. Finally, the algorithm returns the transformed matrix a and the solution matrix b. Complexity Analysis The time complexity of the Gaussian elimination algorithm is O(n^3), where n is the number of unknowns in the system of linear equations. This is because the algorithm involves three nested loops, and each loop iterates n times. Therefore, the total number of operations is proportional to n^3. The space complexity of the algorithm is O(n^2), which is the size of the matrices a and b. The algorithm creates copies of a and b, so the space complexity is doubled. In practice, the Gaussian elimination algorithm is very efficient for small to medium-sized systems of linear equations, but it can become slow for very large systems. In this case, other algorithms such as iterative methods or sparse matrix methods may be more appropriate.]]></summary></entry><entry><title type="html">Ridderâ€™s Algorithm</title><link href="/algorithm/2023/11/22/ridder-algorithm.html" rel="alternate" type="text/html" title="Ridderâ€™s Algorithm" /><published>2023-11-22T02:00:00+02:00</published><updated>2023-11-22T02:00:00+02:00</updated><id>/algorithm/2023/11/22/ridder-algorithm</id><content type="html" xml:base="/algorithm/2023/11/22/ridder-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Ridderâ€™s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications.</p>

<h2 id="implementation">Implementation</h2>

<p>The algorithm is implemented in OCaml as follows:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">ridder</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">xa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">a</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">xb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fa</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">dm</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">xm</span> <span class="o">=</span> <span class="o">!</span><span class="n">xa</span> <span class="o">+.</span> <span class="n">dm</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">f</span> <span class="n">xm</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">((</span><span class="n">fm</span> <span class="o">*.</span> <span class="n">fm</span><span class="p">)</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">fa</span> <span class="o">*.</span> <span class="o">!</span><span class="n">fb</span><span class="p">))</span> <span class="k">in</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sgn</span> <span class="o">=</span> <span class="k">if</span> <span class="o">!</span><span class="n">fa</span> <span class="o">&lt;</span> <span class="o">!</span><span class="n">fb</span> <span class="k">then</span> <span class="o">-</span><span class="mi">1</span><span class="o">.</span> <span class="k">else</span> <span class="mi">1</span><span class="o">.</span> <span class="k">in</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="n">xm</span> <span class="o">+.</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">*.</span> <span class="n">dm</span> <span class="o">*.</span> <span class="n">fm</span> <span class="o">/.</span> <span class="n">s</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">f</span> <span class="o">!</span><span class="n">x</span> <span class="k">in</span>
        <span class="k">if</span> <span class="nn">Owl_base_maths</span><span class="p">.</span><span class="n">same_sign</span> <span class="n">fn</span> <span class="n">fm</span> <span class="o">=</span> <span class="bp">false</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="n">xm</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="n">fm</span><span class="p">)</span>
        <span class="k">else</span> <span class="k">if</span> <span class="nn">Owl_base_maths</span><span class="p">.</span><span class="n">same_sign</span> <span class="n">fn</span> <span class="o">!</span><span class="n">fa</span> <span class="o">=</span> <span class="bp">false</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">(</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="n">fn</span><span class="p">);</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">xtol</span> <span class="o">&amp;&amp;</span> <span class="n">fn</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">x</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The function takes three arguments: the function <code class="language-plaintext highlighter-rouge">f</code> whose root needs to be found, and the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> within which to search for the root. The function returns the estimated value of the root.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>
    <p>The function <code class="language-plaintext highlighter-rouge">ridder</code> takes three input parameters: the function <code class="language-plaintext highlighter-rouge">f</code> whose root needs to be found, and the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> within which to search for the root. It also has two optional parameters: <code class="language-plaintext highlighter-rouge">max_iter</code> (maximum number of iterations) and <code class="language-plaintext highlighter-rouge">xtol</code> (tolerance level). The function returns the estimated value of the root.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at the two endpoints <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, and stores them in the variables <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code>, respectively.</p>
  </li>
  <li>
    <p>The function checks if the product of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval <code class="language-plaintext highlighter-rouge">[a, b]</code>.</p>
  </li>
  <li>
    <p>The function checks if either <code class="language-plaintext highlighter-rouge">fa</code> or <code class="language-plaintext highlighter-rouge">fb</code> is zero. If either of them is zero, the function returns the corresponding value of <code class="language-plaintext highlighter-rouge">a</code> or <code class="language-plaintext highlighter-rouge">b</code> since the root is already found.</p>
  </li>
  <li>
    <p>The function initializes the variables <code class="language-plaintext highlighter-rouge">xa</code>, <code class="language-plaintext highlighter-rouge">xb</code>, <code class="language-plaintext highlighter-rouge">fa</code>, and <code class="language-plaintext highlighter-rouge">fb</code> with the values of <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, <code class="language-plaintext highlighter-rouge">fa</code>, and <code class="language-plaintext highlighter-rouge">fb</code>, respectively. It also initializes the variable <code class="language-plaintext highlighter-rouge">x</code> with a value of infinity.</p>
  </li>
  <li>
    <p>The function enters a loop that runs for a maximum of <code class="language-plaintext highlighter-rouge">max_iter</code> iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge.</p>
  </li>
  <li>
    <p>Within the loop, the function computes the midpoint <code class="language-plaintext highlighter-rouge">xm</code> of the interval <code class="language-plaintext highlighter-rouge">[xa, xb]</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">xm</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">fm</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">s</code>, which is the square root of <code class="language-plaintext highlighter-rouge">(fm^2 - fa*fb)</code>. This value is used to determine the new estimate for the root.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">s</code> is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error.</p>
  </li>
  <li>
    <p>The function computes the sign of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">sgn</code>. If <code class="language-plaintext highlighter-rouge">fa &lt; fb</code>, <code class="language-plaintext highlighter-rouge">sgn</code> is set to <code class="language-plaintext highlighter-rouge">-1</code>, otherwise it is set to <code class="language-plaintext highlighter-rouge">1</code>.</p>
  </li>
  <li>
    <p>The function computes the new estimate for the root using the formula <code class="language-plaintext highlighter-rouge">x = xm + (sgn * dm * fm / s)</code>, where <code class="language-plaintext highlighter-rouge">dm</code> is half the distance between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">xb</code>.</p>
  </li>
  <li>
    <p>The function computes the value of <code class="language-plaintext highlighter-rouge">f</code> at the new estimate <code class="language-plaintext highlighter-rouge">x</code> and stores it in the variable <code class="language-plaintext highlighter-rouge">fn</code>.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">fn</code> and <code class="language-plaintext highlighter-rouge">fm</code> have opposite signs. If they do, the root is between <code class="language-plaintext highlighter-rouge">xm</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[xa, x]</code> and <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> are updated accordingly. If they donâ€™t, the root is between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[x, xb]</code> and <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> are also updated accordingly.</p>
  </li>
  <li>
    <p>The function checks if <code class="language-plaintext highlighter-rouge">fn</code> and <code class="language-plaintext highlighter-rouge">fa</code> have opposite signs. If they do, the root is between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">x</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[xa, x]</code> and <code class="language-plaintext highlighter-rouge">fa</code> is updated to <code class="language-plaintext highlighter-rouge">fn</code>. If they donâ€™t, the root is between <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xb</code>, so the interval is updated to <code class="language-plaintext highlighter-rouge">[x, xb]</code> and <code class="language-plaintext highlighter-rouge">fb</code> is updated to <code class="language-plaintext highlighter-rouge">fn</code>.</p>
  </li>
  <li>
    <p>The function checks if the absolute difference between <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">xb</code> is less than <code class="language-plaintext highlighter-rouge">xtol</code>. If it is, the algorithm has converged and the function returns the estimated value of the root.</p>
  </li>
  <li>
    <p>If the loop has completed <code class="language-plaintext highlighter-rouge">max_iter</code> iterations without converging, the function raises an error.</p>
  </li>
  <li>
    <p>If an error occurs during the loop, the function returns the current estimate of the root.</p>
  </li>
</ol>

<p>Overall, the algorithm works by iteratively refining the interval <code class="language-plaintext highlighter-rouge">[xa, xb]</code> until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint <code class="language-plaintext highlighter-rouge">xm</code> of the interval and the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">xm</code>. It then uses these values to compute a new estimate for the root using the Ridderâ€™s formula. The algorithm then updates the interval and the values of <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> based on whether the new estimate is closer to <code class="language-plaintext highlighter-rouge">xa</code> or <code class="language-plaintext highlighter-rouge">xb</code>. The algorithm repeats this process until the root is found or the maximum number of iterations is reached.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>

<p>The time complexity of the Ridderâ€™s algorithm is <code class="language-plaintext highlighter-rouge">O(log2(1/Îµ))</code>, where <code class="language-plaintext highlighter-rouge">Îµ</code> is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> since it only uses a fixed number of variables regardless of the size of the input.</p>

<p>However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval <code class="language-plaintext highlighter-rouge">[a, b]</code> is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Ridderâ€™s algorithm is a root-finding algorithm that helps to find the root of a given function. This algorithm is an improvement over the bisection method and provides a faster convergence rate. The algorithm is named after Derek Ridder, who introduced it in 1978. It is widely used in scientific and engineering applications. Implementation The algorithm is implemented in OCaml as follows: let ridder ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf "f(a) *. f(b) = %g *. %g should be negative." fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let xa = ref a in let xb = ref b in let fa = ref fa in let fb = ref fb in let x = ref infinity in try for _i = 1 to max_iter do let dm = 0.5 *. (!xb -. !xa) in let xm = !xa +. dm in let fm = f xm in let s = sqrt ((fm *. fm) -. (!fa *. !fb)) in assert (s &lt;&gt; 0.); let sgn = if !fa &lt; !fb then -1. else 1. in x := xm +. (sgn *. dm *. fm /. s); let fn = f !x in if Owl_base_maths.same_sign fn fm = false then ( xa := !x; xb := xm; fa := fn; fb := fm) else if Owl_base_maths.same_sign fn !fa = false then ( xb := !x; fb := fn) else ( xa := !x; fa := fn); assert (abs_float (!xb -. !xa) &gt;= xtol &amp;&amp; fn != 0.) done; !x with | _ -&gt; !x) The function takes three arguments: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. The function returns the estimated value of the root. Step-by-step Explanation The function ridder takes three input parameters: the function f whose root needs to be found, and the interval [a, b] within which to search for the root. It also has two optional parameters: max_iter (maximum number of iterations) and xtol (tolerance level). The function returns the estimated value of the root. The function computes the value of f at the two endpoints a and b, and stores them in the variables fa and fb, respectively. The function checks if the product of fa and fb is negative. If it is not, it raises an error since the algorithm only works if the function changes sign over the interval [a, b]. The function checks if either fa or fb is zero. If either of them is zero, the function returns the corresponding value of a or b since the root is already found. The function initializes the variables xa, xb, fa, and fb with the values of a, b, fa, and fb, respectively. It also initializes the variable x with a value of infinity. The function enters a loop that runs for a maximum of max_iter iterations. This is to prevent the function from running indefinitely in case the algorithm fails to converge. Within the loop, the function computes the midpoint xm of the interval [xa, xb]. The function computes the value of f at xm and stores it in the variable fm. The function computes the value of s, which is the square root of (fm^2 - fa*fb). This value is used to determine the new estimate for the root. The function checks if s is zero. If it is, the algorithm cannot continue since it would require division by zero. In this case, the function raises an error. The function computes the sign of fa and fb and stores it in the variable sgn. If fa &lt; fb, sgn is set to -1, otherwise it is set to 1. The function computes the new estimate for the root using the formula x = xm + (sgn * dm * fm / s), where dm is half the distance between xa and xb. The function computes the value of f at the new estimate x and stores it in the variable fn. The function checks if fn and fm have opposite signs. If they do, the root is between xm and x, so the interval is updated to [xa, x] and fa and fb are updated accordingly. If they donâ€™t, the root is between xa and x, so the interval is updated to [x, xb] and fa and fb are also updated accordingly. The function checks if fn and fa have opposite signs. If they do, the root is between xa and x, so the interval is updated to [xa, x] and fa is updated to fn. If they donâ€™t, the root is between x and xb, so the interval is updated to [x, xb] and fb is updated to fn. The function checks if the absolute difference between xa and xb is less than xtol. If it is, the algorithm has converged and the function returns the estimated value of the root. If the loop has completed max_iter iterations without converging, the function raises an error. If an error occurs during the loop, the function returns the current estimate of the root. Overall, the algorithm works by iteratively refining the interval [xa, xb] until the root is found within a certain tolerance level. At each iteration, the algorithm computes the midpoint xm of the interval and the value of f at xm. It then uses these values to compute a new estimate for the root using the Ridderâ€™s formula. The algorithm then updates the interval and the values of fa and fb based on whether the new estimate is closer to xa or xb. The algorithm repeats this process until the root is found or the maximum number of iterations is reached. Complexity Analysis The time complexity of the Ridderâ€™s algorithm is O(log2(1/Îµ)), where Îµ is the tolerance level. This means that the algorithm converges exponentially fast as the tolerance level is decreased. The algorithm also has a space complexity of O(1) since it only uses a fixed number of variables regardless of the size of the input. However, it is important to note that the algorithm may not converge if the function is not well-behaved or if the interval [a, b] is not chosen properly. In such cases, the algorithm may require more iterations or fail to converge altogether. Therefore, it is important to carefully choose the interval and verify that the function changes sign over the interval before using the algorithm.]]></summary></entry><entry><title type="html">Brentâ€™ss Algorithm</title><link href="/algorithm/2023/11/22/brent-algorithm.html" rel="alternate" type="text/html" title="Brentâ€™ss Algorithm" /><published>2023-11-22T01:00:00+02:00</published><updated>2023-11-22T01:00:00+02:00</updated><id>/algorithm/2023/11/22/brent-algorithm</id><content type="html" xml:base="/algorithm/2023/11/22/brent-algorithm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Brentâ€™s algorithm, also known as Brentâ€™s method or the Brentâ€“dekker method, is a root-finding algorithm that combines the bisection method, the secant method, and inverse quadratic interpolation. It is an iterative algorithm that can find the root of a continuous function in a given interval. The algorithm is widely used in numerical analysis, optimization, and computer science.</p>

<h2 id="implementation">Implementation</h2>
<p>The following is an implementation of Brentâ€™s algorithm in OCaml. The function takes a function <code class="language-plaintext highlighter-rouge">f</code> and two endpoints <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> of an interval <code class="language-plaintext highlighter-rouge">[a, b]</code> as input, and returns an approximate root of <code class="language-plaintext highlighter-rouge">f</code> in the interval. The optional parameters <code class="language-plaintext highlighter-rouge">max_iter</code> and <code class="language-plaintext highlighter-rouge">xtol</code> are the maximum number of iterations and the tolerance for convergence, respectively.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">brent</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">xa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">a</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">xb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">b</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fa</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">3e-16</span> <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xc</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xa</span><span class="p">;</span>
          <span class="n">fc</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fa</span><span class="p">;</span>
          <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">;</span>
          <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">fc</span> <span class="o">&lt;</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">fb</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span><span class="p">;</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xc</span><span class="p">;</span>
          <span class="n">xc</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xa</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fb</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fc</span><span class="p">;</span>
          <span class="n">fc</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fa</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">eps</span> <span class="o">*.</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">xb</span><span class="p">)</span> <span class="o">+.</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="n">xtol</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="n">xm</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">xc</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xb</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="n">xm</span> <span class="o">&gt;=</span> <span class="n">tol</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fb</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">);</span>
        <span class="c">(* 1st strategy: inverse quadratic interpolation *)</span>
        <span class="k">if</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">tol</span> <span class="o">&amp;&amp;</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">fa</span> <span class="o">&gt;</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">fb</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="o">!</span><span class="n">fb</span> <span class="o">/.</span> <span class="o">!</span><span class="n">fa</span> <span class="k">in</span>
          <span class="k">if</span> <span class="o">!</span><span class="n">xa</span> <span class="o">=</span> <span class="o">!</span><span class="n">xc</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="n">p</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">xm</span> <span class="o">*.</span> <span class="n">s</span><span class="p">;</span>
            <span class="n">q</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.</span> <span class="o">-.</span> <span class="n">s</span><span class="p">)</span>
          <span class="k">else</span> <span class="p">(</span>
            <span class="n">q</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fa</span> <span class="o">/.</span> <span class="o">!</span><span class="n">fc</span><span class="p">;</span>
            <span class="n">r</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fb</span> <span class="o">/.</span> <span class="o">!</span><span class="n">fc</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">:=</span> <span class="n">s</span> <span class="o">*.</span> <span class="p">((</span><span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">xm</span> <span class="o">*.</span> <span class="o">!</span><span class="n">q</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span> <span class="o">-.</span> <span class="o">!</span><span class="n">r</span><span class="p">))</span> <span class="o">-.</span> <span class="p">((</span><span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span><span class="p">)</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)));</span>
            <span class="n">q</span> <span class="o">:=</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="p">(</span><span class="n">s</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">));</span>
          <span class="k">if</span> <span class="o">!</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">q</span> <span class="o">:=</span> <span class="o">-.</span> <span class="o">!</span><span class="n">q</span><span class="p">;</span>
          <span class="n">p</span> <span class="o">:=</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">p</span><span class="p">;</span>
          <span class="k">let</span> <span class="n">min1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">.</span> <span class="o">*.</span> <span class="n">xm</span> <span class="o">*.</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="o">-.</span> <span class="n">abs_float</span> <span class="p">(</span><span class="n">tol</span> <span class="o">*.</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">min2</span> <span class="o">=</span> <span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span> <span class="o">*.</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">in</span>
          <span class="k">if</span> <span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="n">min1</span> <span class="n">min2</span>
          <span class="k">then</span> <span class="p">(</span>
            <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span><span class="p">;</span>
            <span class="n">d</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p</span> <span class="o">/.</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span>
          <span class="k">else</span> <span class="p">(</span>
            <span class="n">d</span> <span class="o">:=</span> <span class="n">xm</span><span class="p">;</span>
            <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span><span class="p">)</span>
          <span class="c">(* 2nd strategy: bisection method *)</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">(</span>
          <span class="n">d</span> <span class="o">:=</span> <span class="n">xm</span><span class="p">;</span>
          <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">d</span><span class="p">);</span>
        <span class="c">(* adjust the position *)</span>
        <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span><span class="p">;</span>
        <span class="n">fa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">fb</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">abs_float</span> <span class="o">!</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">tol</span>
        <span class="k">then</span> <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span> <span class="o">+.</span> <span class="o">!</span><span class="n">d</span>
        <span class="k">else</span> <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span> <span class="o">+.</span> <span class="k">if</span> <span class="n">tol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">.</span> <span class="k">then</span> <span class="n">xm</span> <span class="k">else</span> <span class="o">-.</span><span class="n">xm</span><span class="p">;</span>
        <span class="n">fb</span> <span class="o">:=</span> <span class="n">f</span> <span class="o">!</span><span class="n">xb</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">xb</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">xb</span><span class="p">)</span> 
</code></pre></div></div>

<p>Here is an example of using the function to find the root of the function <code class="language-plaintext highlighter-rouge">f(x) = x^3 - 2x - 5</code> in the interval <code class="language-plaintext highlighter-rouge">[2, 3]</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span><span class="o">.</span> <span class="o">-.</span> <span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">x</span> <span class="o">-.</span> <span class="mi">5</span><span class="o">.</span>  
 
<span class="k">let</span> <span class="n">root</span> <span class="o">=</span> <span class="n">brent</span> <span class="n">f</span> <span class="mi">2</span><span class="o">.</span> <span class="mi">3</span><span class="o">.</span>  
 
<span class="k">let</span> <span class="bp">()</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">"The root of f(x) = x^3 - 2x - 5 in [2, 3] is %g.</span><span class="se">\n</span><span class="s2">"</span> <span class="n">root</span>  
</code></pre></div></div>

<p>The output should be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The root of f(x) = x^3 - 2x - 5 in [2, 3] is 2.09455.  
</code></pre></div></div>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>Brentâ€™s algorithm is an iterative algorithm that combines the bisection method, the secant method, and inverse quadratic interpolation. The algorithm starts with two endpoints <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> of an interval <code class="language-plaintext highlighter-rouge">[a, b]</code> that contains a root of a continuous function <code class="language-plaintext highlighter-rouge">f(x)</code>. The algorithm then iteratively refines the estimate of the root until it converges to a desired level of accuracy.</p>

<ol>
  <li>Initialize variables</li>
</ol>

<p>Let <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> be the values of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>, respectively. If <code class="language-plaintext highlighter-rouge">fa</code> or <code class="language-plaintext highlighter-rouge">fb</code> is zero, return the corresponding endpoint as the root. Otherwise, initialize the following variables:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">xa</code>: the previous value of <code class="language-plaintext highlighter-rouge">xb</code></li>
  <li><code class="language-plaintext highlighter-rouge">xb</code>: the current estimate of the root</li>
  <li><code class="language-plaintext highlighter-rouge">xc</code>: the previous value of <code class="language-plaintext highlighter-rouge">xa</code></li>
  <li><code class="language-plaintext highlighter-rouge">fa</code>: the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">a</code></li>
  <li><code class="language-plaintext highlighter-rouge">fb</code>: the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">b</code></li>
  <li><code class="language-plaintext highlighter-rouge">fc</code>: the value of <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">c</code></li>
  <li><code class="language-plaintext highlighter-rouge">d</code>: the step size</li>
  <li><code class="language-plaintext highlighter-rouge">e</code>: the previous value of <code class="language-plaintext highlighter-rouge">d</code></li>
  <li><code class="language-plaintext highlighter-rouge">p</code>, <code class="language-plaintext highlighter-rouge">q</code>, <code class="language-plaintext highlighter-rouge">r</code>: variables used in inverse quadratic interpolation</li>
  <li><code class="language-plaintext highlighter-rouge">eps</code>: a small number used for floating-point comparison</li>
</ul>

<ol>
  <li>Check for sign change</li>
</ol>

<p>Verify that <code class="language-plaintext highlighter-rouge">fa</code> and <code class="language-plaintext highlighter-rouge">fb</code> have opposite signs. If not, raise an error.</p>

<ol>
  <li>Iterate until convergence</li>
</ol>

<p>Repeat the following steps until convergence or the maximum number of iterations is reached:</p>

<ol>
  <li>
    <p>Check for convergence</p>

    <p>Compute the tolerance <code class="language-plaintext highlighter-rouge">tol</code> for convergence. If <code class="language-plaintext highlighter-rouge">|f(b)|</code> is small enough or the step size <code class="language-plaintext highlighter-rouge">d</code> is smaller than <code class="language-plaintext highlighter-rouge">tol</code>, return <code class="language-plaintext highlighter-rouge">b</code> as the root.</p>
  </li>
  <li>
    <p>Compute the step size</p>

    <p>Compute the midpoint <code class="language-plaintext highlighter-rouge">xm</code> of the interval <code class="language-plaintext highlighter-rouge">[b, c]</code>, where <code class="language-plaintext highlighter-rouge">c</code> is the previous value of <code class="language-plaintext highlighter-rouge">a</code> or <code class="language-plaintext highlighter-rouge">b</code>. If <code class="language-plaintext highlighter-rouge">|e| &gt;= tol</code> and <code class="language-plaintext highlighter-rouge">|f(a)| &gt; |f(b)|</code>, use inverse quadratic interpolation to compute a new step size <code class="language-plaintext highlighter-rouge">d</code>. Otherwise, use bisection method to compute <code class="language-plaintext highlighter-rouge">d</code>.</p>
  </li>
  <li>
    <p>Update the estimate of the root</p>

    <p>Compute the new estimate of the root by adding <code class="language-plaintext highlighter-rouge">d</code> to <code class="language-plaintext highlighter-rouge">xb</code>. If <code class="language-plaintext highlighter-rouge">d</code> is too small, add or subtract <code class="language-plaintext highlighter-rouge">tol</code> instead.</p>
  </li>
  <li>
    <p>Evaluate the function</p>

    <p>Compute the value of <code class="language-plaintext highlighter-rouge">f</code> at the new estimate <code class="language-plaintext highlighter-rouge">xb</code>.</p>
  </li>
  <li>
    <p>Update variables</p>

    <p>Update the variables <code class="language-plaintext highlighter-rouge">xa</code>, <code class="language-plaintext highlighter-rouge">xb</code>, <code class="language-plaintext highlighter-rouge">xc</code>, <code class="language-plaintext highlighter-rouge">fa</code>, <code class="language-plaintext highlighter-rouge">fb</code>, <code class="language-plaintext highlighter-rouge">fc</code>, <code class="language-plaintext highlighter-rouge">d</code>, and <code class="language-plaintext highlighter-rouge">e</code> with their new values.</p>
  </li>
  <li>
    <p>Check for convergence</p>

    <p>If <code class="language-plaintext highlighter-rouge">|f(b)|</code> is small enough or the step size <code class="language-plaintext highlighter-rouge">d</code> is smaller than <code class="language-plaintext highlighter-rouge">tol</code>, return <code class="language-plaintext highlighter-rouge">b</code> as the root.</p>
  </li>
  <li>
    <p>Check for oscillation</p>

    <p>If the function value at the new estimate <code class="language-plaintext highlighter-rouge">xb</code> has the same sign as the function value at the previous estimate <code class="language-plaintext highlighter-rouge">xc</code>, replace <code class="language-plaintext highlighter-rouge">xc</code> and <code class="language-plaintext highlighter-rouge">fc</code> with <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">fa</code>, and set <code class="language-plaintext highlighter-rouge">d</code> and <code class="language-plaintext highlighter-rouge">e</code> to their initial values.</p>
  </li>
  <li>
    <p>Check for convergence</p>

    <p>If <code class="language-plaintext highlighter-rouge">|f(b)|</code> is small enough or the step size <code class="language-plaintext highlighter-rouge">d</code> is smaller than <code class="language-plaintext highlighter-rouge">tol</code>, return <code class="language-plaintext highlighter-rouge">b</code> as the root.</p>
  </li>
  <li>
    <p>Choose the interpolation method</p>

    <p>If <code class="language-plaintext highlighter-rouge">|f(b)| &lt; |f(a)|</code>, use secant method to compute a new step size <code class="language-plaintext highlighter-rouge">d</code>. Otherwise, use inverse quadratic interpolation.</p>
  </li>
  <li>
    <p>Update the estimate of the root</p>

    <p>Compute the new estimate of the root by adding <code class="language-plaintext highlighter-rouge">d</code> to <code class="language-plaintext highlighter-rouge">xb</code>. If <code class="language-plaintext highlighter-rouge">d</code> is too small, add or subtract <code class="language-plaintext highlighter-rouge">tol</code> instead.</p>
  </li>
  <li>
    <p>Evaluate the function</p>

    <p>Compute the value of <code class="language-plaintext highlighter-rouge">f</code> at the new estimate <code class="language-plaintext highlighter-rouge">xb</code>.</p>
  </li>
  <li>
    <p>Update variables</p>

    <p>Update the variables <code class="language-plaintext highlighter-rouge">xa</code>, <code class="language-plaintext highlighter-rouge">xb</code>, <code class="language-plaintext highlighter-rouge">xc</code>, <code class="language-plaintext highlighter-rouge">fa</code>, <code class="language-plaintext highlighter-rouge">fb</code>, <code class="language-plaintext highlighter-rouge">fc</code>, <code class="language-plaintext highlighter-rouge">d</code>, and <code class="language-plaintext highlighter-rouge">e</code> with their new values.</p>
  </li>
  <li>
    <p>Return the root</p>

    <p>If the algorithm does not converge within the maximum number of iterations, return the last estimate of the root.</p>
  </li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of Brentâ€™s algorithm is O(log(tol/eps) * f_evals), where tol is the tolerance for convergence, eps is a small number used for floating-point comparison, and f_evals is the number of evaluations of the function <code class="language-plaintext highlighter-rouge">f</code> required by the algorithm. The algorithm is guaranteed to converge if the function <code class="language-plaintext highlighter-rouge">f</code> is continuous and has a root in the initial interval <code class="language-plaintext highlighter-rouge">[a, b]</code>. The algorithm is also robust to some types of singularities, such as poles and branch cuts. However, the algorithm may fail to converge if the function has multiple roots or if the initial interval is too large. In practice, Brentâ€™s algorithm is often more efficient than other root-finding algorithms, such as the bisection method and the secant method, especially for functions that are smooth but not necessarily analytic.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction Brentâ€™s algorithm, also known as Brentâ€™s method or the Brentâ€“dekker method, is a root-finding algorithm that combines the bisection method, the secant method, and inverse quadratic interpolation. It is an iterative algorithm that can find the root of a continuous function in a given interval. The algorithm is widely used in numerical analysis, optimization, and computer science. Implementation The following is an implementation of Brentâ€™s algorithm in OCaml. The function takes a function f and two endpoints a and b of an interval [a, b] as input, and returns an approximate root of f in the interval. The optional parameters max_iter and xtol are the maximum number of iterations and the tolerance for convergence, respectively. let brent ?(max_iter = 1000) ?(xtol = 1e-6) f a b = let fa = f a in let fb = f b in let error () = let s = Printf.sprintf "f(a) *. f(b) = %g *. %g should be negative." fa fb in Owl_exception.INVALID_ARGUMENT s in Owl_exception.verify (fa *. fb &lt; 0.) error; if fa = 0. then a else if fb = 0. then b else ( let xa = ref a in let xb = ref b in let xc = ref b in let fc = ref fb in let fa = ref fa in let fb = ref fb in let d = ref infinity in let e = ref infinity in let p = ref infinity in let q = ref infinity in let r = ref infinity in let eps = 3e-16 in try for _i = 1 to max_iter do if (!fb &gt; 0. &amp;&amp; !fc &gt; 0.) || (!fb &lt; 0. &amp;&amp; !fc &lt; 0.) then ( xc := !xa; fc := !fa; d := !xb -. !xa; e := !d); if abs_float !fc &lt; abs_float !fb then ( xa := !xb; xb := !xc; xc := !xa; fa := !fb; fb := !fc; fc := !fa); let tol = (2. *. eps *. abs_float !xb) +. (0.5 *. xtol) in let xm = 0.5 *. (!xc -. !xb) in assert (abs_float xm &gt;= tol &amp;&amp; !fb != 0.); (* 1st strategy: inverse quadratic interpolation *) if abs_float !e &gt;= tol &amp;&amp; abs_float !fa &gt; abs_float !fb then ( let s = !fb /. !fa in if !xa = !xc then ( p := 2. *. xm *. s; q := 1. -. s) else ( q := !fa /. !fc; r := !fb /. !fc; p := s *. ((2. *. xm *. !q *. (!q -. !r)) -. ((!xb -. !xa) *. (!r -. 1.))); q := (!q -. 1.) *. (!r -. 1.) *. (s -. 1.)); if !p &gt; 0. then q := -. !q; p := abs_float !p; let min1 = (3. *. xm *. !q) -. abs_float (tol *. !q) in let min2 = abs_float (!e *. !q) in if 2. *. !p &lt; min min1 min2 then ( e := !d; d := !p /. !q) else ( d := xm; e := !d) (* 2nd strategy: bisection method *)) else ( d := xm; e := !d); (* adjust the position *) xa := !xb; fa := !fb; if abs_float !d &gt; tol then xb := !xb +. !d else xb := !xb +. if tol &gt; 0. then xm else -.xm; fb := f !xb done; !xb with | _ -&gt; !xb) Here is an example of using the function to find the root of the function f(x) = x^3 - 2x - 5 in the interval [2, 3]. let f x = x ** 3. -. 2. *. x -. 5. let root = brent f 2. 3. let () = Printf.printf "The root of f(x) = x^3 - 2x - 5 in [2, 3] is %g.\n" root The output should be: The root of f(x) = x^3 - 2x - 5 in [2, 3] is 2.09455. Step-by-step Explanation Brentâ€™s algorithm is an iterative algorithm that combines the bisection method, the secant method, and inverse quadratic interpolation. The algorithm starts with two endpoints a and b of an interval [a, b] that contains a root of a continuous function f(x). The algorithm then iteratively refines the estimate of the root until it converges to a desired level of accuracy. Initialize variables]]></summary></entry><entry><title type="html">False Position Algorithm</title><link href="/algorithm/2023/11/22/false-pos.html" rel="alternate" type="text/html" title="False Position Algorithm" /><published>2023-11-22T00:00:00+02:00</published><updated>2023-11-22T00:00:00+02:00</updated><id>/algorithm/2023/11/22/false-pos</id><content type="html" xml:base="/algorithm/2023/11/22/false-pos.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The false position algorithm, also known as the regula falsi method, is a root-finding algorithm that uses linear interpolation to approximate the root of a given function. It is a bracketing method, which means that it requires an initial interval containing the root. The algorithm is commonly used in engineering, physics, and other scientific fields to solve equations that cannot be solved analytically.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="bp">false</span><span class="n">_pos</span> <span class="o">?</span><span class="p">(</span><span class="n">max_iter</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">error</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"f(a) *. f(b) = %g *. %g should be negative."</span> <span class="n">fa</span> <span class="n">fb</span> <span class="k">in</span>
    <span class="nn">Owl_exception</span><span class="p">.</span><span class="nc">INVALID_ARGUMENT</span> <span class="n">s</span>
  <span class="k">in</span>
  <span class="nn">Owl_exception</span><span class="p">.</span><span class="n">verify</span> <span class="p">(</span><span class="n">fa</span> <span class="o">*.</span> <span class="n">fb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span> <span class="n">error</span><span class="p">;</span>
  <span class="k">if</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">a</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">fb</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span>
  <span class="k">then</span> <span class="n">b</span>
  <span class="k">else</span> <span class="p">(</span>
    <span class="k">let</span> <span class="n">xa</span><span class="o">,</span> <span class="n">xb</span><span class="o">,</span> <span class="n">fa</span><span class="o">,</span> <span class="n">fb</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">fa</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span> <span class="k">with</span>
      <span class="o">|</span> <span class="bp">true</span>  <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">a</span><span class="o">,</span> <span class="n">ref</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="n">fa</span><span class="o">,</span> <span class="n">ref</span> <span class="n">fb</span>
      <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">ref</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="n">a</span><span class="o">,</span> <span class="n">ref</span> <span class="n">fb</span><span class="o">,</span> <span class="n">ref</span> <span class="n">fa</span>
    <span class="k">in</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
    <span class="k">try</span>
      <span class="k">for</span> <span class="n">_i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">max_iter</span> <span class="k">do</span>
        <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">xa</span> <span class="k">in</span>
        <span class="n">x</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xa</span> <span class="o">+.</span> <span class="p">(</span><span class="n">d</span> <span class="o">*.</span> <span class="o">!</span><span class="n">fa</span> <span class="o">/.</span> <span class="p">(</span><span class="o">!</span><span class="n">fa</span> <span class="o">-.</span> <span class="o">!</span><span class="n">fb</span><span class="p">));</span>
        <span class="k">let</span> <span class="n">fc</span> <span class="o">=</span> <span class="n">f</span> <span class="o">!</span><span class="n">x</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">.</span>
        <span class="k">then</span> <span class="p">(</span>
          <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xa</span> <span class="o">-.</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">xa</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fa</span> <span class="o">:=</span> <span class="n">fc</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">(</span>
          <span class="n">e</span> <span class="o">:=</span> <span class="o">!</span><span class="n">xb</span> <span class="o">-.</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">xb</span> <span class="o">:=</span> <span class="o">!</span><span class="n">x</span><span class="p">;</span>
          <span class="n">fb</span> <span class="o">:=</span> <span class="n">fc</span><span class="p">);</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="o">!</span><span class="n">e</span> <span class="o">&gt;=</span> <span class="n">xtol</span> <span class="o">&amp;&amp;</span> <span class="n">fc</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">.</span><span class="p">)</span>
      <span class="k">done</span><span class="p">;</span>
      <span class="o">!</span><span class="n">x</span>
    <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>The false position algorithm is implemented in OCaml in the code above. The function <code class="language-plaintext highlighter-rouge">false_pos</code> takes as input a function <code class="language-plaintext highlighter-rouge">f</code> and two initial guesses <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. The optional arguments <code class="language-plaintext highlighter-rouge">max_iter</code> and <code class="language-plaintext highlighter-rouge">xtol</code> specify the maximum number of iterations and the tolerance for the solution, respectively. The function returns an approximation of the root of <code class="language-plaintext highlighter-rouge">f</code> within the interval <code class="language-plaintext highlighter-rouge">[a,b]</code>.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<ol>
  <li>Verify that the function <code class="language-plaintext highlighter-rouge">f</code> changes sign between <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. If not, raise an error.</li>
  <li>If <code class="language-plaintext highlighter-rouge">f(a) = 0</code>, return <code class="language-plaintext highlighter-rouge">a</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">f(b) = 0</code>, return <code class="language-plaintext highlighter-rouge">b</code>.</li>
  <li>Choose the interval endpoints <code class="language-plaintext highlighter-rouge">xa</code> and <code class="language-plaintext highlighter-rouge">xb</code> such that <code class="language-plaintext highlighter-rouge">f(xa) &lt; 0</code> and <code class="language-plaintext highlighter-rouge">f(xb) &gt; 0</code>.</li>
  <li>Initialize <code class="language-plaintext highlighter-rouge">x</code> to infinity and <code class="language-plaintext highlighter-rouge">e</code> to infinity.</li>
  <li>Repeat the following steps until the maximum number of iterations is reached or the solution is within the tolerance:
    <ul>
      <li>Compute the new estimate of the root <code class="language-plaintext highlighter-rouge">x</code> using linear interpolation:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = xa - (f(xa) * (xb - xa)) / (f(xb) - f(xa))  
</code></pre></div>        </div>
      </li>
      <li>Evaluate the function <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">x</code>.</li>
      <li>If <code class="language-plaintext highlighter-rouge">f(x) &lt; 0</code>, update <code class="language-plaintext highlighter-rouge">xa</code>, <code class="language-plaintext highlighter-rouge">fa</code>, and <code class="language-plaintext highlighter-rouge">e</code>:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xa = x  
fa = f(xa)  
e = xa - xb  
</code></pre></div>        </div>
      </li>
      <li>If <code class="language-plaintext highlighter-rouge">f(x) &gt; 0</code>, update <code class="language-plaintext highlighter-rouge">xb</code>, <code class="language-plaintext highlighter-rouge">fb</code>, and <code class="language-plaintext highlighter-rouge">e</code>:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xb = x  
fb = f(xb)  
e = xb - xa  
</code></pre></div>        </div>
      </li>
      <li>Check if the solution is within the tolerance:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|e| &gt;= xtol &amp;&amp; f(x) != 0  
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Return the final estimate of the root <code class="language-plaintext highlighter-rouge">x</code>.</li>
</ol>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The false position algorithm is guaranteed to converge to a root of a continuous function if the initial interval contains the root and the function is continuous and changes sign within the interval. The rate of convergence is linear, which means that the error decreases at a rate proportional to the error of the previous iteration. The algorithm is also sensitive to the choice of the initial interval, and may converge slowly or not at all if the interval is not well-chosen.</p>

<p>The time complexity of the false position algorithm is proportional to the maximum number of iterations <code class="language-plaintext highlighter-rouge">max_iter</code> specified by the user. The choice of <code class="language-plaintext highlighter-rouge">max_iter</code> depends on the desired accuracy of the solution and the complexity of the function <code class="language-plaintext highlighter-rouge">f</code>. The space complexity of the algorithm is constant, as it only requires a small number of variables to store the current estimates of the root and the function values.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The false position algorithm, also known as the regula falsi method, is a root-finding algorithm that uses linear interpolation to approximate the root of a given function. It is a bracketing method, which means that it requires an initial interval containing the root. The algorithm is commonly used in engineering, physics, and other scientific fields to solve equations that cannot be solved analytically. Implementation]]></summary></entry><entry><title type="html">Gauss-Legendre Algorithm</title><link href="/algorithm/2023/11/21/gaussian-legendre.html" rel="alternate" type="text/html" title="Gauss-Legendre Algorithm" /><published>2023-11-21T12:00:00+02:00</published><updated>2023-11-21T12:00:00+02:00</updated><id>/algorithm/2023/11/21/gaussian-legendre</id><content type="html" xml:base="/algorithm/2023/11/21/gaussian-legendre.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The Gauss-Legendre algorithm is an iterative numerical integration technique used for approximating definite integrals. The algorithm is based on the idea of interpolating a function over a given interval using Legendre polynomials. The resulting approximation is then used to compute the integral of the function over the same interval. The Gauss-Legendre algorithm is widely used in numerical analysis and scientific computing.</p>

<h2 id="implementation">Implementation</h2>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">gauss_legendre</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">3e-11</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create_float</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create_float</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">xm</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">+.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">xl</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">m</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">i'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">i</span> <span class="k">in</span>
    <span class="n">z</span> <span class="o">:=</span> <span class="n">cos</span> <span class="p">(</span><span class="nn">Owl_const</span><span class="p">.</span><span class="n">pi</span> <span class="o">*.</span> <span class="p">(</span><span class="n">i'</span> <span class="o">-.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">25</span><span class="p">)</span> <span class="o">/.</span> <span class="p">(</span><span class="n">n'</span> <span class="o">+.</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">));</span>
    <span class="p">(</span><span class="k">try</span>
       <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="n">p1</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">.;</span>
         <span class="n">p2</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">.;</span>
         <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
           <span class="n">p3</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p2</span><span class="p">;</span>
           <span class="n">p2</span> <span class="o">:=</span> <span class="o">!</span><span class="n">p1</span><span class="p">;</span>
           <span class="k">let</span> <span class="n">j'</span> <span class="o">=</span> <span class="n">float_of_int</span> <span class="n">j</span> <span class="k">in</span>
           <span class="n">p1</span> <span class="o">:=</span> <span class="p">((((</span><span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">j'</span><span class="p">)</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p2</span><span class="p">)</span> <span class="o">-.</span> <span class="p">((</span><span class="n">j'</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">)</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p3</span><span class="p">))</span> <span class="o">/.</span> <span class="n">j'</span>
         <span class="k">done</span><span class="p">;</span>
         <span class="n">pp</span> <span class="o">:=</span> <span class="n">n'</span> <span class="o">*.</span> <span class="p">((</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">p1</span><span class="p">)</span> <span class="o">-.</span> <span class="o">!</span><span class="n">p2</span><span class="p">)</span> <span class="o">/.</span> <span class="p">((</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">)</span> <span class="o">-.</span> <span class="mi">1</span><span class="o">.</span><span class="p">);</span>
         <span class="k">let</span> <span class="n">z1</span> <span class="o">=</span> <span class="o">!</span><span class="n">z</span> <span class="k">in</span>
         <span class="n">z</span> <span class="o">:=</span> <span class="n">z1</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">p1</span> <span class="o">/.</span> <span class="o">!</span><span class="n">pp</span><span class="p">);</span>
         <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">z</span> <span class="o">-.</span> <span class="n">z1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">)</span>
       <span class="k">done</span>
     <span class="k">with</span>
    <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xm</span> <span class="o">-.</span> <span class="p">(</span><span class="n">xl</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">);</span>
    <span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xm</span> <span class="o">+.</span> <span class="p">(</span><span class="n">xl</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">);</span>
    <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="mi">2</span><span class="o">.</span> <span class="o">*.</span> <span class="n">xl</span> <span class="o">/.</span> <span class="p">((</span><span class="mi">1</span><span class="o">.</span> <span class="o">-.</span> <span class="p">(</span><span class="o">!</span><span class="n">z</span> <span class="o">*.</span> <span class="o">!</span><span class="n">z</span><span class="p">))</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pp</span> <span class="o">*.</span> <span class="o">!</span><span class="n">pp</span><span class="p">);</span>
    <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="n">x</span><span class="o">,</span> <span class="n">w</span>


<span class="k">let</span> <span class="n">gauss_legendre_cache</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">init</span> <span class="mi">50</span> <span class="n">gauss_legendre</span>

<span class="k">let</span> <span class="n">_gauss_laguerre</span> <span class="o">?</span><span class="p">(</span><span class="n">_eps</span> <span class="o">=</span> <span class="mf">3e-11</span><span class="p">)</span> <span class="n">_a</span> <span class="n">_b</span> <span class="n">_n</span> <span class="o">=</span> <span class="bp">()</span>

<span class="k">let</span> <span class="n">gaussian_fixed</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">x</span><span class="o">,</span> <span class="n">w</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">gauss_legendre_cache</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">true</span>  <span class="o">-&gt;</span> <span class="n">gauss_legendre_cache</span><span class="o">.</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="o">|</span> <span class="bp">false</span> <span class="o">-&gt;</span> <span class="n">gauss_legendre</span> <span class="n">n</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">xr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span> <span class="o">*.</span> <span class="p">(</span><span class="n">b</span> <span class="o">-.</span> <span class="n">a</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">.</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span> <span class="o">*.</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+.</span> <span class="mi">1</span><span class="o">.</span><span class="p">))</span> <span class="o">+.</span> <span class="n">a</span> <span class="k">in</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s</span> <span class="o">+.</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*.</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span>
  <span class="k">done</span><span class="p">;</span>
  <span class="o">!</span><span class="n">s</span> <span class="o">*.</span> <span class="n">xr</span>


<span class="k">let</span> <span class="n">gaussian</span> <span class="o">?</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">?</span><span class="p">(</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">s_old</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">infinity</span> <span class="k">in</span>
  <span class="p">(</span><span class="k">try</span>
     <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">to</span> <span class="n">n</span> <span class="k">do</span>
       <span class="n">s_new</span> <span class="o">:=</span> <span class="n">gaussian_fixed</span> <span class="o">~</span><span class="n">n</span><span class="o">:</span><span class="n">i</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">;</span>
       <span class="k">assert</span> <span class="p">(</span><span class="n">abs_float</span> <span class="p">(</span><span class="o">!</span><span class="n">s_new</span> <span class="o">-.</span> <span class="o">!</span><span class="n">s_old</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">);</span>
       <span class="n">s_old</span> <span class="o">:=</span> <span class="o">!</span><span class="n">s_new</span>
     <span class="k">done</span>
   <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="p">);</span>
  <span class="o">!</span><span class="n">s_new</span>
</code></pre></div></div>

<p>The Gauss-Legendre algorithm is implemented in OCaml as a function <code class="language-plaintext highlighter-rouge">gaussian</code> which takes in the following arguments:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">n</code>: the number of iterations to perform (default 50)</li>
  <li><code class="language-plaintext highlighter-rouge">eps</code>: the desired accuracy of the approximation (default 1e-6)</li>
  <li><code class="language-plaintext highlighter-rouge">f</code>: the function to integrate</li>
  <li><code class="language-plaintext highlighter-rouge">a</code>: the lower bound of the integration interval</li>
  <li><code class="language-plaintext highlighter-rouge">b</code>: the upper bound of the integration interval</li>
</ul>

<p>The implementation is split into two functions: <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> and <code class="language-plaintext highlighter-rouge">gaussian</code>. The former performs a single iteration of the algorithm, while the latter performs a specified number of iterations until the desired accuracy is achieved. The <code class="language-plaintext highlighter-rouge">gaussian</code> function first checks if the desired number of iterations is available in a precomputed cache, otherwise it computes them using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function.</p>

<h2 id="step-by-step-explanation">Step-by-step Explanation</h2>
<p>The Gauss-Legendre algorithm works by approximating the integral of a function <code class="language-plaintext highlighter-rouge">f</code> over an interval <code class="language-plaintext highlighter-rouge">[a,b]</code> using Legendre polynomials. The algorithm proceeds as follows:</p>
<ol>
  <li>Compute the Legendre-Gauss nodes and weights for the given interval <code class="language-plaintext highlighter-rouge">[a,b]</code> and number of nodes <code class="language-plaintext highlighter-rouge">n</code>.</li>
  <li>Transform the integral over <code class="language-plaintext highlighter-rouge">[a,b]</code> into an integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the change of variables <code class="language-plaintext highlighter-rouge">x = ((b-a)t + b + a)/2</code>.</li>
  <li>Approximate the integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the Legendre-Gauss nodes and weights.</li>
  <li>Transform the approximation back to the integral over <code class="language-plaintext highlighter-rouge">[a,b]</code> using the same change of variables as in step 2.</li>
</ol>

<p>The Legendre-Gauss nodes and weights are computed using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function. This function uses the iterative method described by the algorithm to approximate the roots of the Legendre polynomial of degree <code class="language-plaintext highlighter-rouge">n</code>. The roots are then used as the nodes for the Gauss-Legendre quadrature, and the corresponding weights are computed using the formula <code class="language-plaintext highlighter-rouge">w_i = 2 / [(1 - z_i^2) * (P_n'(z_i))^2]</code>, where <code class="language-plaintext highlighter-rouge">P_n</code> is the Legendre polynomial of degree <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">z_i</code> is the <code class="language-plaintext highlighter-rouge">i</code>-th root.</p>

<p>The <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> function approximates the integral over <code class="language-plaintext highlighter-rouge">[-1,1]</code> using the Legendre-Gauss nodes and weights. It first computes the midpoint <code class="language-plaintext highlighter-rouge">xr</code> of the interval <code class="language-plaintext highlighter-rouge">[-1,1]</code> and then evaluates the function <code class="language-plaintext highlighter-rouge">f</code> at each of the nodes <code class="language-plaintext highlighter-rouge">x_i</code> transformed to the interval <code class="language-plaintext highlighter-rouge">[a,b]</code> using the change of variables described above. The approximation is then computed as the sum of the products of the weights <code class="language-plaintext highlighter-rouge">w_i</code> and the function values <code class="language-plaintext highlighter-rouge">f(x_i)</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">gaussian</code> function iteratively calls <code class="language-plaintext highlighter-rouge">gaussian_fixed</code> with increasing numbers of nodes until the desired accuracy is achieved. It uses the precomputed cache of Legendre-Gauss nodes and weights if available, otherwise it computes them using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function.</p>

<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The time complexity of the Gauss-Legendre algorithm is dominated by the number of iterations <code class="language-plaintext highlighter-rouge">n</code> performed by the <code class="language-plaintext highlighter-rouge">gaussian</code> function. Each iteration of <code class="language-plaintext highlighter-rouge">gaussian</code> requires evaluating the function <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points and computing the Legendre-Gauss nodes and weights. The latter is precomputed and cached for up to 50 nodes, and computed on-the-fly using the <code class="language-plaintext highlighter-rouge">gauss_legendre</code> function for larger values of <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>The time complexity of computing the Legendre-Gauss nodes and weights using <code class="language-plaintext highlighter-rouge">gauss_legendre</code> is <code class="language-plaintext highlighter-rouge">O(n^2)</code>, due to the nested loop over <code class="language-plaintext highlighter-rouge">j</code> and <code class="language-plaintext highlighter-rouge">i</code>. However, this function is only called once for each unique <code class="language-plaintext highlighter-rouge">n</code>, so its time complexity is not a bottleneck for the overall algorithm.</p>

<p>The time complexity of evaluating the function <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points is dependent on the implementation of <code class="language-plaintext highlighter-rouge">f</code>. Assuming that <code class="language-plaintext highlighter-rouge">f</code> has a time complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> for each evaluation, the time complexity of evaluating <code class="language-plaintext highlighter-rouge">f</code> at <code class="language-plaintext highlighter-rouge">n</code> points is <code class="language-plaintext highlighter-rouge">O(n)</code>.</p>

<p>Therefore, the overall time complexity of the Gauss-Legendre algorithm is <code class="language-plaintext highlighter-rouge">O(n^3)</code> for large values of <code class="language-plaintext highlighter-rouge">n</code>. The space complexity is <code class="language-plaintext highlighter-rouge">O(n)</code> for storing the Legendre-Gauss nodes and weights.</p>]]></content><author><name>Liang Wang</name><email>liang@ocaml.xyz</email></author><category term="algorithm" /><summary type="html"><![CDATA[Introduction The Gauss-Legendre algorithm is an iterative numerical integration technique used for approximating definite integrals. The algorithm is based on the idea of interpolating a function over a given interval using Legendre polynomials. The resulting approximation is then used to compute the integral of the function over the same interval. The Gauss-Legendre algorithm is widely used in numerical analysis and scientific computing. Implementation]]></summary></entry></feed>